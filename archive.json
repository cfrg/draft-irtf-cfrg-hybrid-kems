{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-03-25T01:05:11.843069+00:00",
  "repo": "cfrg/draft-irtf-cfrg-hybrid-kems",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 4,
      "id": "I_kwDOMmhxws6rCIMm",
      "title": "Should instance labels include the XOF that's used for key generation?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/4",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "For example, `QSF-SHA3-256-ML-KEM-768-P-256` doesn't say that it uses SHAKE256 for the XOF. Should we?",
      "createdAt": "2025-02-21T16:15:05Z",
      "updatedAt": "2025-02-25T17:22:50Z",
      "closedAt": "2025-02-25T17:22:50Z",
      "comments": []
    },
    {
      "number": 7,
      "id": "I_kwDOMmhxws6rz1bb",
      "title": "Consider renaming KitchenSink to TranscriptHash",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/7",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See [this post](https://mailarchive.ietf.org/arch/msg/cfrg/L7G1rXH9g_acH1uhs4G2IKRN7dU/).",
      "createdAt": "2025-02-26T18:39:03Z",
      "updatedAt": "2025-02-26T20:24:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "NONE",
          "body": "I'm not sure that's right thought\n\n``` \nss = LabeledHKDF(pq_SS, trad_SS, pq_CT, pq_PK, trad_CT, trad_PK, label)\n```\n\nThere's no \"transcript\" in there, unless you jam it into the label, but that's not required by the text? And I think that TLS has a well-defined concept of a \"transcript\", but I think it's less clear what counts as \"transcript\" for example if you have a JWT payload on an HTTP POST -- does \"transcript\" mean that the entire payload of the JWT should be included in the label? Or does \"transcript\" mean the entire sequence of HTTP messages exchanged so far on this connection? Obviously that's not what's intended, but might be how a non-cryptographer interprets the word \"transcript\". I don't have a better suggestion than \"KitchenSink\", but I don't think that \"TranscriptHash\" is the right connotation for protocols that aren't TLS.",
          "createdAt": "2025-02-26T20:06:05Z",
          "updatedAt": "2025-02-26T20:24:15Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOMmhxws6sPD0w",
      "title": "IANA Register HPKE KDFs?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/8",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The IANA \"Hybrid Public Key Encryption (HPKE)\" page has registries for KEMs, KDFs, and AEADs. Currently, the only KDFs registered are HKDF-SHA256/384512.\n\nI believe that someone needs to register at least these two KDFs in the IANA registry before HPKE key derivation is truly supported:\n- KDF(SHA3-256) \u2014 referring to Section 6.1 of FIPS202\n- XOF(SHAKE256) \u2014 referring to Section 6.2 of FIPS202\n\nThis document seems a likely place for that registration. It may have the nice side effect that the names of the QSF-based KEMs can become shorter.\n",
      "createdAt": "2025-03-02T15:52:34Z",
      "updatedAt": "2025-03-07T20:34:52Z",
      "closedAt": "2025-03-07T20:34:52Z",
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.",
          "createdAt": "2025-03-02T19:48:41Z",
          "updatedAt": "2025-03-02T19:49:02Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.\n\nA separate document to register SHA3 as an HPKE KDF will probably be useful but that's apart from this one",
          "createdAt": "2025-03-02T19:54:50Z",
          "updatedAt": "2025-03-02T19:54:50Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.\n> \n> A separate document to register SHA3 as an HPKE KDF will probably be useful but that's apart from this one\n\nSimilarly, X-Wing is registered In IANA as an HPKE KEM. X-Wing uses SHA3 as its KDF and SHAKE256 as an XOF in its key generation/derivation. Those functions are separate from the HPKE KDFs, same with the KEMs defined and registered in this document and the functions they use internally.",
          "createdAt": "2025-03-02T20:00:26Z",
          "updatedAt": "2025-03-02T20:00:26Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> > > Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.\n> > \n> > \n> > A separate document to register SHA3 as an HPKE KDF will probably be useful but that's apart from this one\n> \n> Similarly, X-Wing is registered In IANA as an HPKE KEM. X-Wing uses SHA3 as its KDF and SHAKE256 as an XOF in its key generation/derivation. Those functions are separate from the HPKE KDFs, same with the KEMs defined and registered in this document and the functions they use internally.\n\n@rohanmahy I've created this to register SHA-3 for HPKE KDFs: https://datatracker.ietf.org/doc/draft-connolly-cfrg-sha3-hpke/",
          "createdAt": "2025-03-04T00:03:04Z",
          "updatedAt": "2025-03-04T00:03:04Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "SHA-3 unfortunately doesn't match the Extract/Expand API expected by HPKE spec so it's not as easy but we can keep working on it",
          "createdAt": "2025-03-07T20:34:44Z",
          "updatedAt": "2025-03-07T20:34:44Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOMmhxws6tFcFU",
      "title": "Make concatenation of KDF inputs explicit in concrete pseudocode",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/10",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We can clarify this concatenation to match the generic QSF construction more closely using the explicit concat() routine described earlier",
      "createdAt": "2025-03-07T20:35:32Z",
      "updatedAt": "2025-03-07T20:35:32Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 11,
      "id": "I_kwDOMmhxws6tFlU6",
      "title": "Type inconsistency for `trad_PK`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/11",
      "state": "OPEN",
      "author": "bluegate010",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "- In `expandDecapsulationKey` (and therefore in `KeyGen`, `DeriveKey`, and `Decaps`), `trad_PK` is a serialized byte array (`trad_PK = G.SerializeElement(NominalGroup.ScalarMultBase(trad_SK))`)\n- In `Encaps`, `trad_PK` is a deserialized element (`trad_PK = P-256.DeserializeElement(pk[1184:1217])`)\n- In `EncapsDerand` for QSF-P256, `trad_PK` is a deserialized element (`trad_PK = P-256.DeserializeElement(pk[1184:1217])`), but is later treated as a serialized byte array (`ss = SHA3-256(pq_SS, trad_SS, trad_CT, trad_PK, label)`)\n- In `EncapsDerand` for KS-X25519, `trad_PK` is a serialized byte array (`trad_PK = pk[1184:1216]`)\n- In `EncapsDerand` for QSF-P384, `trad_PK` is deserialized element (`trad_PK = P-384.DeserializeElement(pk[1568:1629])`)\n\nFor clarity, it seems reasonable for `trad_PK` to always be a serialized byte array.",
      "createdAt": "2025-03-07T20:55:14Z",
      "updatedAt": "2025-03-07T20:55:14Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOMmhxws6G-GIs",
      "title": "Fix build and references",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/1",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-01-07T18:01:15Z",
      "updatedAt": "2025-01-08T04:15:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "8f18831dc6e7d2b4cbe13e809c0481aa350625e6",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/fix-refs",
      "headRefOid": "f795b47e09e04f14fc9afae5b8591ec55dd4fd58",
      "closedAt": "2025-01-08T04:15:08Z",
      "mergedAt": "2025-01-08T04:15:08Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "503214de9161bbabeb9ffeb76d24596d8af66752"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6XJ7HM",
          "commit": {
            "abbreviatedOid": "f795b47"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-01-08T04:14:54Z",
          "updatedAt": "2025-01-08T04:14:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 2,
      "id": "PR_kwDOMmhxws6HIQRB",
      "title": "Refactor, cleanup, reorganize",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/2",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This change refactors some stuff and cleans up the in-lined KEM implementation details.",
      "createdAt": "2025-01-08T21:24:34Z",
      "updatedAt": "2025-01-23T18:47:30Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ea0a9337871b8f52777783e10780d40f21b6ca14",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/reorg",
      "headRefOid": "75a1f6564a51ae64ddb2ae86cb25355a8997b705",
      "closedAt": "2025-01-23T18:47:30Z",
      "mergedAt": "2025-01-23T18:47:30Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "5557ce637cb791f95f09cf3271ec5623825047b1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6XcYyA",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-09T19:48:22Z",
          "updatedAt": "2025-01-09T19:48:23Z",
          "comments": [
            {
              "originalPosition": 477,
              "body": "\ud83d\udc4d",
              "createdAt": "2025-01-09T19:48:22Z",
              "updatedAt": "2025-01-09T19:48:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOLdI",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:01:46Z",
          "updatedAt": "2025-01-23T18:01:47Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "```suggestion\r\n- `EncapsDerand(pk, randomness) -> (ct, shared_secret)`: A deterministic encapsulation\r\n   algorithm, which takes as input a public encapsulation key `pk` and randomness\r\n   `randomness`, and outputs a ciphertext `ct` and shared secret `shared_secret`.\r\n```",
              "createdAt": "2025-01-23T18:01:46Z",
              "updatedAt": "2025-01-23T18:01:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOMAE",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:02:53Z",
          "updatedAt": "2025-01-23T18:02:53Z",
          "comments": [
            {
              "originalPosition": 610,
              "body": "```suggestion\r\ndef EncapsDerand(pk, randomness):\r\n  pq_PK = pk[0:1184]\r\n  trad_PK = pk[1184:1217]\r\n  (pq_SS, pq_CT) = ML-KEM-768.EncapsDerand(pq_PK, randomness[0:32])\r\n  ek = randomness[32:65]\r\n  trad_CT = P-256.ScalarMultBase(ek)\r\n  trad_SS = P-256.ScalarMult(ek, trad_PK)\r\n  ss = SHA3-256(pq_SS, trad_SS, trad_CT, trad_PK, label)\r\n  ct = concat(pq_CT, trad_CT)\r\n```",
              "createdAt": "2025-01-23T18:02:53Z",
              "updatedAt": "2025-01-23T18:02:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOMGw",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:03:05Z",
          "updatedAt": "2025-01-23T18:03:06Z",
          "comments": [
            {
              "originalPosition": 619,
              "body": "```suggestion\r\nNote that `randomness` MUST be 65 bytes.\r\n```",
              "createdAt": "2025-01-23T18:03:05Z",
              "updatedAt": "2025-01-23T18:03:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOMoP",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:04:11Z",
          "updatedAt": "2025-01-23T18:04:12Z",
          "comments": [
            {
              "originalPosition": 864,
              "body": "```suggestion\r\ndef EncapsDerand(pk, randomness):\r\n  pq_PK = pk[0:1184]\r\n  trad_PK = pk[1184:1216]\r\n  (pq_SS, pq_CT) = PQ-KEM.EncapsDerand(pq_PK, randomness[0:32])\r\n  ek = randomness[32:64]\r\n```",
              "createdAt": "2025-01-23T18:04:11Z",
              "updatedAt": "2025-01-23T18:04:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZONxs",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:06:33Z",
          "updatedAt": "2025-01-23T18:06:34Z",
          "comments": [
            {
              "originalPosition": 877,
              "body": "```suggestion\r\nNote that `randomness` MUST be 64 bytes.\r\n```",
              "createdAt": "2025-01-23T18:06:33Z",
              "updatedAt": "2025-01-23T18:06:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOPiO",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:10:14Z",
          "updatedAt": "2025-01-23T18:10:14Z",
          "comments": [
            {
              "originalPosition": 1161,
              "body": "```suggestion\r\ndef EncapsDerand(pk, randomness):\r\n  pq_PK = pk[0:1568]\r\n  trad_PK = pk[1568:1629]\r\n  (pq_SS, pq_CT) = ML-KEM-1024.EncapsDerand(pq_PK, randomness[0:32])\r\n  ek = randomness[32:80]\r\n  trad_CT = P-384.ScalarMultBase(ek)\r\n  trad_SS = P-384.ScalarMult(ek, trad_PK)\r\n  ss = SHA3-256(pq_SS, trad_SS, trad_CT, trad_PK, label)\r\n  ct = concat(pq_CT, trad_CT)\r\n```",
              "createdAt": "2025-01-23T18:10:14Z",
              "updatedAt": "2025-01-23T18:10:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOPoo",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:10:28Z",
          "updatedAt": "2025-01-23T18:10:28Z",
          "comments": [
            {
              "originalPosition": 1170,
              "body": "```suggestion\r\nNote that `randomness` MUST be 80 bytes.\r\n```",
              "createdAt": "2025-01-23T18:10:28Z",
              "updatedAt": "2025-01-23T18:10:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOk4A",
          "commit": {
            "abbreviatedOid": "75a1f65"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-01-23T18:46:24Z",
          "updatedAt": "2025-01-23T18:46:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 3,
      "id": "PR_kwDOMmhxws6I0Zg9",
      "title": "Preliminary reference implementations and test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/3",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This mirrors the spec implementation for X-Wing, but it uses Sage for the NIST curve implementation. (Primarily because I had that laying around from other specs. We can replace with a Python implementation in the future if desired.) It fixes some things in the primary spec around key generation (formatting keys as byte strings), fully specifying the DH operations, etc. It also includes preliminary HPKE KEM codepoint registration requests. And, importantly, adds the test vectors produced from the reference implementation.",
      "createdAt": "2025-01-23T21:30:19Z",
      "updatedAt": "2025-02-03T18:44:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "5557ce637cb791f95f09cf3271ec5623825047b1",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/vectors",
      "headRefOid": "9771afd2307ec7032d8d6e8298849e06017c0264",
      "closedAt": "2025-02-03T18:44:49Z",
      "mergedAt": "2025-02-03T18:44:49Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "2f0ea74c9e3e93b7dd4fbd3f0c33fb76256e6fef"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@dconnolly I added a `ScalarFromBytes` function, distinct from `DeserializeScalar`, as an infallible constructor that takes bytes and produces `Scalar` values, with an implementation that matches the reference code under the hood. Please take another look!",
          "createdAt": "2025-02-03T17:35:02Z",
          "updatedAt": "2025-02-03T17:35:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6aOQeU",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\ud83d\ude4f",
          "createdAt": "2025-01-31T17:50:01Z",
          "updatedAt": "2025-01-31T17:50:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6aOT4_",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-31T17:52:25Z",
          "updatedAt": "2025-01-31T17:52:25Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "`%` needs defining above",
              "createdAt": "2025-01-31T17:52:25Z",
              "updatedAt": "2025-01-31T17:52:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6aOXz0",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-31T17:55:37Z",
          "updatedAt": "2025-01-31T17:55:37Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "We could leverage the text above about `Scalar`s and `Element`s to enforce that all instances of `Scalar`s MUST be modulo their order, otherwise they aren't real `Scalar`s ",
              "createdAt": "2025-01-31T17:55:37Z",
              "updatedAt": "2025-01-31T17:55:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6aOYml",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Do we want to enforce the `Scalar` being always modulo its `Order()` via its instantiation? Otherwise we need to define `%` as used in `expandDecapsulationKey` etc",
          "createdAt": "2025-01-31T17:57:13Z",
          "updatedAt": "2025-01-31T17:57:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6aaI9p",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-03T17:11:55Z",
          "updatedAt": "2025-02-03T17:11:55Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "That's a cleaner way to handle this. I'll update the textual description of Scalar to include something about mapping from bytes, and say that the bytes are reduced modulo the order, or something.",
              "createdAt": "2025-02-03T17:11:55Z",
              "updatedAt": "2025-02-03T17:11:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6aa29j",
          "commit": {
            "abbreviatedOid": "9771afd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-03T18:44:32Z",
          "updatedAt": "2025-02-03T18:44:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOMmhxws6MFI2K",
      "title": "Update labels to include XOF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/5",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hopefully these labels are not too terrible on the eyes \ud83e\udd37 \r\n\r\nCloses #4.",
      "createdAt": "2025-02-21T17:19:15Z",
      "updatedAt": "2025-02-25T17:22:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "a1093192626f720d448880692a5d8b258fbf783c",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/update-labels",
      "headRefOid": "9abc6fcfb262e42878b0b67cece04cec09bba491",
      "closedAt": "2025-02-25T17:22:49Z",
      "mergedAt": "2025-02-25T17:22:49Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "10867607a87847ff4d9e03029dcfcd4117b83620"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6dAy3d",
          "commit": {
            "abbreviatedOid": "a7175ff"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T21:14:24Z",
          "updatedAt": "2025-02-21T21:14:24Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\n2. `KitchenSink-KEM(ML-KEM-768,X25519)-XOF(SHAKE256)-KDF(HKDF-SHA-256)` {{ks-x25519}}:\r\n```\r\n\r\nHm I worry about a comma in a label like this, have we done this in other i*tf crypto protocols? Is it fine in practice?",
              "createdAt": "2025-02-21T21:14:24Z",
              "updatedAt": "2025-02-21T21:14:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6deCz8",
          "commit": {
            "abbreviatedOid": "a7175ff"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-25T17:21:26Z",
          "updatedAt": "2025-02-25T17:21:27Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "merging for now, but may want to keep an eye on it",
              "createdAt": "2025-02-25T17:21:27Z",
              "updatedAt": "2025-02-25T17:21:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOMmhxws6MGGlY",
      "title": "Add generic keygen and derivation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/6",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@chris-wood wdyt of the attempt at including slicing of the XOF output into the bytes that go into each component algorithm? \ud83d\ude05",
      "createdAt": "2025-02-21T19:50:44Z",
      "updatedAt": "2025-02-25T17:20:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "f50c9557531cb1237d8be28871842f6fa8675134",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "generic-keygen",
      "headRefOid": "9fcef57ff286640cf383b48579c201ecec104507",
      "closedAt": "2025-02-25T17:20:28Z",
      "mergedAt": "2025-02-25T17:20:28Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "a1093192626f720d448880692a5d8b258fbf783c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6dASs8",
          "commit": {
            "abbreviatedOid": "d76eae8"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T19:57:03Z",
          "updatedAt": "2025-02-21T19:57:11Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Maybe we replace `Nxofout` with `Npqseed + Ntradseed`? I think the `expanded[..Npqseed]` is fairly clear, but we should probably add some text to the terminology section that describes how it works. Something like:\r\n\r\n```\r\nWhen `x` is a byte string, we use the notation `x[..i]` and `x[i..]` to denote the slice of bytes in `x` starting from the beginning of `x` and leading up to index `i`, including the `i`-th byte, and the slice the bytes in `x` starting from index `i` to the end of `x`, respectively. For example, if `x = [0, 1, 2, 3]`, then `x[..2] = [0, 1]` and `x[2..] = [2, 3]`.\r\n```",
              "createdAt": "2025-02-21T19:57:03Z",
              "updatedAt": "2025-02-21T19:57:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6dAzLR",
          "commit": {
            "abbreviatedOid": "d76eae8"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T21:15:08Z",
          "updatedAt": "2025-02-21T21:15:08Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done; can you cross check the numbers for Ntradseed for the p256 and p384 instances?",
              "createdAt": "2025-02-21T21:15:08Z",
              "updatedAt": "2025-02-21T21:15:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6deB_p",
          "commit": {
            "abbreviatedOid": "9fcef57"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-25T17:20:13Z",
          "updatedAt": "2025-02-25T17:20:13Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "confirmed out of bad - they are larger than expected  to make sure the Scalar isn't biased (not a power of 2), these match HashToCurve",
              "createdAt": "2025-02-25T17:20:13Z",
              "updatedAt": "2025-02-25T17:20:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 9,
      "id": "PR_kwDOMmhxws6N0rBY",
      "title": "Clarify concatenation operations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/9",
      "state": "OPEN",
      "author": "bluegate010",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Clarify that SHA3-256 takes one input which is a concatenation of multiple values.",
      "createdAt": "2025-03-07T20:30:38Z",
      "updatedAt": "2025-03-07T21:01:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ca4807c8b1249830e36a18dbc8b218087eb7bcb8",
      "headRepository": "bluegate010/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "patch-1",
      "headRefOid": "ec575c84b83fe47edd02460667e9e1eda3cc561b",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "We can clarify this concatenation to match the generic QSF construction more closely using the explicit `concat()` routine described earlier ",
          "createdAt": "2025-03-07T20:33:31Z",
          "updatedAt": "2025-03-07T20:33:31Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "Opened https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/10 for this ",
          "createdAt": "2025-03-07T20:35:50Z",
          "updatedAt": "2025-03-07T20:35:50Z"
        },
        {
          "author": "bluegate010",
          "authorAssociation": "NONE",
          "body": "> We can clarify this concatenation to match the generic QSF construction more closely using the explicit `concat()` routine described earlier\r\n\r\nGot it, have made this adjustment.",
          "createdAt": "2025-03-07T21:01:07Z",
          "updatedAt": "2025-03-07T21:01:07Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOMmhxws6N01c3",
      "title": "Make trad_PK consistently a serialized byte array.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/12",
      "state": "OPEN",
      "author": "bluegate010",
      "authorAssociation": "NONE",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Resolves https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/11",
      "createdAt": "2025-03-07T20:55:55Z",
      "updatedAt": "2025-03-07T20:59:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ca4807c8b1249830e36a18dbc8b218087eb7bcb8",
      "headRepository": "bluegate010/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "trad_PK",
      "headRefOid": "96dac879d6c53b62e542a06d902b46db8666e6ab",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}