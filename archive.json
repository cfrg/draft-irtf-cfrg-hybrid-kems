{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-05-11T01:13:47.145969+00:00",
  "repo": "cfrg/draft-irtf-cfrg-hybrid-kems",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 4,
      "id": "I_kwDOMmhxws6rCIMm",
      "title": "Should instance labels include the XOF that's used for key generation?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/4",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "For example, `QSF-SHA3-256-ML-KEM-768-P-256` doesn't say that it uses SHAKE256 for the XOF. Should we?",
      "createdAt": "2025-02-21T16:15:05Z",
      "updatedAt": "2025-02-25T17:22:50Z",
      "closedAt": "2025-02-25T17:22:50Z",
      "comments": []
    },
    {
      "number": 7,
      "id": "I_kwDOMmhxws6rz1bb",
      "title": "Consider renaming KitchenSink to TranscriptHash",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/7",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See [this post](https://mailarchive.ietf.org/arch/msg/cfrg/L7G1rXH9g_acH1uhs4G2IKRN7dU/).",
      "createdAt": "2025-02-26T18:39:03Z",
      "updatedAt": "2025-02-26T20:24:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "NONE",
          "body": "I'm not sure that's right thought\n\n``` \nss = LabeledHKDF(pq_SS, trad_SS, pq_CT, pq_PK, trad_CT, trad_PK, label)\n```\n\nThere's no \"transcript\" in there, unless you jam it into the label, but that's not required by the text? And I think that TLS has a well-defined concept of a \"transcript\", but I think it's less clear what counts as \"transcript\" for example if you have a JWT payload on an HTTP POST -- does \"transcript\" mean that the entire payload of the JWT should be included in the label? Or does \"transcript\" mean the entire sequence of HTTP messages exchanged so far on this connection? Obviously that's not what's intended, but might be how a non-cryptographer interprets the word \"transcript\". I don't have a better suggestion than \"KitchenSink\", but I don't think that \"TranscriptHash\" is the right connotation for protocols that aren't TLS.",
          "createdAt": "2025-02-26T20:06:05Z",
          "updatedAt": "2025-02-26T20:24:15Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOMmhxws6sPD0w",
      "title": "IANA Register HPKE KDFs?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/8",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The IANA \"Hybrid Public Key Encryption (HPKE)\" page has registries for KEMs, KDFs, and AEADs. Currently, the only KDFs registered are HKDF-SHA256/384512.\n\nI believe that someone needs to register at least these two KDFs in the IANA registry before HPKE key derivation is truly supported:\n- KDF(SHA3-256) \u2014 referring to Section 6.1 of FIPS202\n- XOF(SHAKE256) \u2014 referring to Section 6.2 of FIPS202\n\nThis document seems a likely place for that registration. It may have the nice side effect that the names of the QSF-based KEMs can become shorter.\n",
      "createdAt": "2025-03-02T15:52:34Z",
      "updatedAt": "2025-03-07T20:34:52Z",
      "closedAt": "2025-03-07T20:34:52Z",
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.",
          "createdAt": "2025-03-02T19:48:41Z",
          "updatedAt": "2025-03-02T19:49:02Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.\n\nA separate document to register SHA3 as an HPKE KDF will probably be useful but that's apart from this one",
          "createdAt": "2025-03-02T19:54:50Z",
          "updatedAt": "2025-03-02T19:54:50Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.\n> \n> A separate document to register SHA3 as an HPKE KDF will probably be useful but that's apart from this one\n\nSimilarly, X-Wing is registered In IANA as an HPKE KEM. X-Wing uses SHA3 as its KDF and SHAKE256 as an XOF in its key generation/derivation. Those functions are separate from the HPKE KDFs, same with the KEMs defined and registered in this document and the functions they use internally.",
          "createdAt": "2025-03-02T20:00:26Z",
          "updatedAt": "2025-03-02T20:00:26Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> > > Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.\n> > \n> > \n> > A separate document to register SHA3 as an HPKE KDF will probably be useful but that's apart from this one\n> \n> Similarly, X-Wing is registered In IANA as an HPKE KEM. X-Wing uses SHA3 as its KDF and SHAKE256 as an XOF in its key generation/derivation. Those functions are separate from the HPKE KDFs, same with the KEMs defined and registered in this document and the functions they use internally.\n\n@rohanmahy I've created this to register SHA-3 for HPKE KDFs: https://datatracker.ietf.org/doc/draft-connolly-cfrg-sha3-hpke/",
          "createdAt": "2025-03-04T00:03:04Z",
          "updatedAt": "2025-03-04T00:03:04Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "SHA-3 unfortunately doesn't match the Extract/Expand API expected by HPKE spec so it's not as easy but we can keep working on it",
          "createdAt": "2025-03-07T20:34:44Z",
          "updatedAt": "2025-03-07T20:34:44Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOMmhxws6tFcFU",
      "title": "Make concatenation of KDF inputs explicit in concrete pseudocode",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/10",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We can clarify this concatenation to match the generic QSF construction more closely using the explicit concat() routine described earlier",
      "createdAt": "2025-03-07T20:35:32Z",
      "updatedAt": "2025-03-07T20:35:32Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 11,
      "id": "I_kwDOMmhxws6tFlU6",
      "title": "Type inconsistency for `trad_PK`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/11",
      "state": "OPEN",
      "author": "bluegate010",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "- In `expandDecapsulationKey` (and therefore in `KeyGen`, `DeriveKey`, and `Decaps`), `trad_PK` is a serialized byte array (`trad_PK = G.SerializeElement(NominalGroup.ScalarMultBase(trad_SK))`)\n- In `Encaps`, `trad_PK` is a deserialized element (`trad_PK = P-256.DeserializeElement(pk[1184:1217])`)\n- In `EncapsDerand` for QSF-P256, `trad_PK` is a deserialized element (`trad_PK = P-256.DeserializeElement(pk[1184:1217])`), but is later treated as a serialized byte array (`ss = SHA3-256(pq_SS, trad_SS, trad_CT, trad_PK, label)`)\n- In `EncapsDerand` for KS-X25519, `trad_PK` is a serialized byte array (`trad_PK = pk[1184:1216]`)\n- In `EncapsDerand` for QSF-P384, `trad_PK` is deserialized element (`trad_PK = P-384.DeserializeElement(pk[1568:1629])`)\n\nFor clarity, it seems reasonable for `trad_PK` to always be a serialized byte array.",
      "createdAt": "2025-03-07T20:55:14Z",
      "updatedAt": "2025-03-07T20:55:14Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 13,
      "id": "I_kwDOMmhxws6y1iX9",
      "title": "Flesh out the 'out of scope' details more",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/13",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dconnolly"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-04-16T18:10:07Z",
      "updatedAt": "2025-04-16T18:10:11Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 14,
      "id": "I_kwDOMmhxws6y1lj0",
      "title": "Flesh out tradeoffs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/14",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- [ ] include not looking at 'layered' style hybrids\n- [ ] include not looking at split/dualPRF style",
      "createdAt": "2025-04-16T18:15:46Z",
      "updatedAt": "2025-05-01T14:51:54Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 16,
      "id": "I_kwDOMmhxws6016Gs",
      "title": "Rename to '-generic-hybrid-kems' to match '-concrete-hybrid-kems'",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/16",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-01T14:50:46Z",
      "updatedAt": "2025-05-01T14:50:46Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOMmhxws6G-GIs",
      "title": "Fix build and references",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/1",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-01-07T18:01:15Z",
      "updatedAt": "2025-01-08T04:15:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "8f18831dc6e7d2b4cbe13e809c0481aa350625e6",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/fix-refs",
      "headRefOid": "f795b47e09e04f14fc9afae5b8591ec55dd4fd58",
      "closedAt": "2025-01-08T04:15:08Z",
      "mergedAt": "2025-01-08T04:15:08Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "503214de9161bbabeb9ffeb76d24596d8af66752"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6XJ7HM",
          "commit": {
            "abbreviatedOid": "f795b47"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-01-08T04:14:54Z",
          "updatedAt": "2025-01-08T04:14:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 2,
      "id": "PR_kwDOMmhxws6HIQRB",
      "title": "Refactor, cleanup, reorganize",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/2",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This change refactors some stuff and cleans up the in-lined KEM implementation details.",
      "createdAt": "2025-01-08T21:24:34Z",
      "updatedAt": "2025-01-23T18:47:30Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ea0a9337871b8f52777783e10780d40f21b6ca14",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/reorg",
      "headRefOid": "75a1f6564a51ae64ddb2ae86cb25355a8997b705",
      "closedAt": "2025-01-23T18:47:30Z",
      "mergedAt": "2025-01-23T18:47:30Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "5557ce637cb791f95f09cf3271ec5623825047b1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6XcYyA",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-09T19:48:22Z",
          "updatedAt": "2025-01-09T19:48:23Z",
          "comments": [
            {
              "originalPosition": 477,
              "body": "\ud83d\udc4d",
              "createdAt": "2025-01-09T19:48:22Z",
              "updatedAt": "2025-01-09T19:48:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOLdI",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:01:46Z",
          "updatedAt": "2025-01-23T18:01:47Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "```suggestion\r\n- `EncapsDerand(pk, randomness) -> (ct, shared_secret)`: A deterministic encapsulation\r\n   algorithm, which takes as input a public encapsulation key `pk` and randomness\r\n   `randomness`, and outputs a ciphertext `ct` and shared secret `shared_secret`.\r\n```",
              "createdAt": "2025-01-23T18:01:46Z",
              "updatedAt": "2025-01-23T18:01:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOMAE",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:02:53Z",
          "updatedAt": "2025-01-23T18:02:53Z",
          "comments": [
            {
              "originalPosition": 610,
              "body": "```suggestion\r\ndef EncapsDerand(pk, randomness):\r\n  pq_PK = pk[0:1184]\r\n  trad_PK = pk[1184:1217]\r\n  (pq_SS, pq_CT) = ML-KEM-768.EncapsDerand(pq_PK, randomness[0:32])\r\n  ek = randomness[32:65]\r\n  trad_CT = P-256.ScalarMultBase(ek)\r\n  trad_SS = P-256.ScalarMult(ek, trad_PK)\r\n  ss = SHA3-256(pq_SS, trad_SS, trad_CT, trad_PK, label)\r\n  ct = concat(pq_CT, trad_CT)\r\n```",
              "createdAt": "2025-01-23T18:02:53Z",
              "updatedAt": "2025-01-23T18:02:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOMGw",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:03:05Z",
          "updatedAt": "2025-01-23T18:03:06Z",
          "comments": [
            {
              "originalPosition": 619,
              "body": "```suggestion\r\nNote that `randomness` MUST be 65 bytes.\r\n```",
              "createdAt": "2025-01-23T18:03:05Z",
              "updatedAt": "2025-01-23T18:03:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOMoP",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:04:11Z",
          "updatedAt": "2025-01-23T18:04:12Z",
          "comments": [
            {
              "originalPosition": 864,
              "body": "```suggestion\r\ndef EncapsDerand(pk, randomness):\r\n  pq_PK = pk[0:1184]\r\n  trad_PK = pk[1184:1216]\r\n  (pq_SS, pq_CT) = PQ-KEM.EncapsDerand(pq_PK, randomness[0:32])\r\n  ek = randomness[32:64]\r\n```",
              "createdAt": "2025-01-23T18:04:11Z",
              "updatedAt": "2025-01-23T18:04:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZONxs",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:06:33Z",
          "updatedAt": "2025-01-23T18:06:34Z",
          "comments": [
            {
              "originalPosition": 877,
              "body": "```suggestion\r\nNote that `randomness` MUST be 64 bytes.\r\n```",
              "createdAt": "2025-01-23T18:06:33Z",
              "updatedAt": "2025-01-23T18:06:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOPiO",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:10:14Z",
          "updatedAt": "2025-01-23T18:10:14Z",
          "comments": [
            {
              "originalPosition": 1161,
              "body": "```suggestion\r\ndef EncapsDerand(pk, randomness):\r\n  pq_PK = pk[0:1568]\r\n  trad_PK = pk[1568:1629]\r\n  (pq_SS, pq_CT) = ML-KEM-1024.EncapsDerand(pq_PK, randomness[0:32])\r\n  ek = randomness[32:80]\r\n  trad_CT = P-384.ScalarMultBase(ek)\r\n  trad_SS = P-384.ScalarMult(ek, trad_PK)\r\n  ss = SHA3-256(pq_SS, trad_SS, trad_CT, trad_PK, label)\r\n  ct = concat(pq_CT, trad_CT)\r\n```",
              "createdAt": "2025-01-23T18:10:14Z",
              "updatedAt": "2025-01-23T18:10:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOPoo",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:10:28Z",
          "updatedAt": "2025-01-23T18:10:28Z",
          "comments": [
            {
              "originalPosition": 1170,
              "body": "```suggestion\r\nNote that `randomness` MUST be 80 bytes.\r\n```",
              "createdAt": "2025-01-23T18:10:28Z",
              "updatedAt": "2025-01-23T18:10:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOk4A",
          "commit": {
            "abbreviatedOid": "75a1f65"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-01-23T18:46:24Z",
          "updatedAt": "2025-01-23T18:46:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 3,
      "id": "PR_kwDOMmhxws6I0Zg9",
      "title": "Preliminary reference implementations and test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/3",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This mirrors the spec implementation for X-Wing, but it uses Sage for the NIST curve implementation. (Primarily because I had that laying around from other specs. We can replace with a Python implementation in the future if desired.) It fixes some things in the primary spec around key generation (formatting keys as byte strings), fully specifying the DH operations, etc. It also includes preliminary HPKE KEM codepoint registration requests. And, importantly, adds the test vectors produced from the reference implementation.",
      "createdAt": "2025-01-23T21:30:19Z",
      "updatedAt": "2025-02-03T18:44:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "5557ce637cb791f95f09cf3271ec5623825047b1",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/vectors",
      "headRefOid": "9771afd2307ec7032d8d6e8298849e06017c0264",
      "closedAt": "2025-02-03T18:44:49Z",
      "mergedAt": "2025-02-03T18:44:49Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "2f0ea74c9e3e93b7dd4fbd3f0c33fb76256e6fef"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@dconnolly I added a `ScalarFromBytes` function, distinct from `DeserializeScalar`, as an infallible constructor that takes bytes and produces `Scalar` values, with an implementation that matches the reference code under the hood. Please take another look!",
          "createdAt": "2025-02-03T17:35:02Z",
          "updatedAt": "2025-02-03T17:35:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6aOQeU",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\ud83d\ude4f",
          "createdAt": "2025-01-31T17:50:01Z",
          "updatedAt": "2025-01-31T17:50:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6aOT4_",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-31T17:52:25Z",
          "updatedAt": "2025-01-31T17:52:25Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "`%` needs defining above",
              "createdAt": "2025-01-31T17:52:25Z",
              "updatedAt": "2025-01-31T17:52:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6aOXz0",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-31T17:55:37Z",
          "updatedAt": "2025-01-31T17:55:37Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "We could leverage the text above about `Scalar`s and `Element`s to enforce that all instances of `Scalar`s MUST be modulo their order, otherwise they aren't real `Scalar`s ",
              "createdAt": "2025-01-31T17:55:37Z",
              "updatedAt": "2025-01-31T17:55:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6aOYml",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Do we want to enforce the `Scalar` being always modulo its `Order()` via its instantiation? Otherwise we need to define `%` as used in `expandDecapsulationKey` etc",
          "createdAt": "2025-01-31T17:57:13Z",
          "updatedAt": "2025-01-31T17:57:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6aaI9p",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-03T17:11:55Z",
          "updatedAt": "2025-02-03T17:11:55Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "That's a cleaner way to handle this. I'll update the textual description of Scalar to include something about mapping from bytes, and say that the bytes are reduced modulo the order, or something.",
              "createdAt": "2025-02-03T17:11:55Z",
              "updatedAt": "2025-02-03T17:11:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6aa29j",
          "commit": {
            "abbreviatedOid": "9771afd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-03T18:44:32Z",
          "updatedAt": "2025-02-03T18:44:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOMmhxws6MFI2K",
      "title": "Update labels to include XOF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/5",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hopefully these labels are not too terrible on the eyes \ud83e\udd37 \r\n\r\nCloses #4.",
      "createdAt": "2025-02-21T17:19:15Z",
      "updatedAt": "2025-02-25T17:22:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "a1093192626f720d448880692a5d8b258fbf783c",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/update-labels",
      "headRefOid": "9abc6fcfb262e42878b0b67cece04cec09bba491",
      "closedAt": "2025-02-25T17:22:49Z",
      "mergedAt": "2025-02-25T17:22:49Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "10867607a87847ff4d9e03029dcfcd4117b83620"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6dAy3d",
          "commit": {
            "abbreviatedOid": "a7175ff"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T21:14:24Z",
          "updatedAt": "2025-02-21T21:14:24Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\n2. `KitchenSink-KEM(ML-KEM-768,X25519)-XOF(SHAKE256)-KDF(HKDF-SHA-256)` {{ks-x25519}}:\r\n```\r\n\r\nHm I worry about a comma in a label like this, have we done this in other i*tf crypto protocols? Is it fine in practice?",
              "createdAt": "2025-02-21T21:14:24Z",
              "updatedAt": "2025-02-21T21:14:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6deCz8",
          "commit": {
            "abbreviatedOid": "a7175ff"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-25T17:21:26Z",
          "updatedAt": "2025-02-25T17:21:27Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "merging for now, but may want to keep an eye on it",
              "createdAt": "2025-02-25T17:21:27Z",
              "updatedAt": "2025-02-25T17:21:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOMmhxws6MGGlY",
      "title": "Add generic keygen and derivation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/6",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@chris-wood wdyt of the attempt at including slicing of the XOF output into the bytes that go into each component algorithm? \ud83d\ude05",
      "createdAt": "2025-02-21T19:50:44Z",
      "updatedAt": "2025-02-25T17:20:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "f50c9557531cb1237d8be28871842f6fa8675134",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "generic-keygen",
      "headRefOid": "9fcef57ff286640cf383b48579c201ecec104507",
      "closedAt": "2025-02-25T17:20:28Z",
      "mergedAt": "2025-02-25T17:20:28Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "a1093192626f720d448880692a5d8b258fbf783c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6dASs8",
          "commit": {
            "abbreviatedOid": "d76eae8"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T19:57:03Z",
          "updatedAt": "2025-02-21T19:57:11Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Maybe we replace `Nxofout` with `Npqseed + Ntradseed`? I think the `expanded[..Npqseed]` is fairly clear, but we should probably add some text to the terminology section that describes how it works. Something like:\r\n\r\n```\r\nWhen `x` is a byte string, we use the notation `x[..i]` and `x[i..]` to denote the slice of bytes in `x` starting from the beginning of `x` and leading up to index `i`, including the `i`-th byte, and the slice the bytes in `x` starting from index `i` to the end of `x`, respectively. For example, if `x = [0, 1, 2, 3]`, then `x[..2] = [0, 1]` and `x[2..] = [2, 3]`.\r\n```",
              "createdAt": "2025-02-21T19:57:03Z",
              "updatedAt": "2025-02-21T19:57:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6dAzLR",
          "commit": {
            "abbreviatedOid": "d76eae8"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T21:15:08Z",
          "updatedAt": "2025-02-21T21:15:08Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done; can you cross check the numbers for Ntradseed for the p256 and p384 instances?",
              "createdAt": "2025-02-21T21:15:08Z",
              "updatedAt": "2025-02-21T21:15:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6deB_p",
          "commit": {
            "abbreviatedOid": "9fcef57"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-25T17:20:13Z",
          "updatedAt": "2025-02-25T17:20:13Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "confirmed out of bad - they are larger than expected  to make sure the Scalar isn't biased (not a power of 2), these match HashToCurve",
              "createdAt": "2025-02-25T17:20:13Z",
              "updatedAt": "2025-02-25T17:20:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 9,
      "id": "PR_kwDOMmhxws6N0rBY",
      "title": "Clarify concatenation operations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/9",
      "state": "OPEN",
      "author": "bluegate010",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Clarify that SHA3-256 takes one input which is a concatenation of multiple values.",
      "createdAt": "2025-03-07T20:30:38Z",
      "updatedAt": "2025-03-07T21:01:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ca4807c8b1249830e36a18dbc8b218087eb7bcb8",
      "headRepository": "bluegate010/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "patch-1",
      "headRefOid": "ec575c84b83fe47edd02460667e9e1eda3cc561b",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "We can clarify this concatenation to match the generic QSF construction more closely using the explicit `concat()` routine described earlier ",
          "createdAt": "2025-03-07T20:33:31Z",
          "updatedAt": "2025-03-07T20:33:31Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "Opened https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/10 for this ",
          "createdAt": "2025-03-07T20:35:50Z",
          "updatedAt": "2025-03-07T20:35:50Z"
        },
        {
          "author": "bluegate010",
          "authorAssociation": "NONE",
          "body": "> We can clarify this concatenation to match the generic QSF construction more closely using the explicit `concat()` routine described earlier\r\n\r\nGot it, have made this adjustment.",
          "createdAt": "2025-03-07T21:01:07Z",
          "updatedAt": "2025-03-07T21:01:07Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOMmhxws6N01c3",
      "title": "Make trad_PK consistently a serialized byte array.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/12",
      "state": "OPEN",
      "author": "bluegate010",
      "authorAssociation": "NONE",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Resolves https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/11",
      "createdAt": "2025-03-07T20:55:55Z",
      "updatedAt": "2025-03-07T20:59:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ca4807c8b1249830e36a18dbc8b218087eb7bcb8",
      "headRepository": "bluegate010/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "trad_PK",
      "headRefOid": "96dac879d6c53b62e542a06d902b46db8666e6ab",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 15,
      "id": "PR_kwDOMmhxws6UNmZE",
      "title": "Remove concrete instantiations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/15",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR removes the following content from this document:\r\n\r\n* The sections defining concrete combiners\r\n* The test vectors section\r\n* The IANA considerations section\r\n* Mentions of specific combinations in the prose\r\n\r\nMost of this text should be moved to the concrete document (https://github.com/cfrg/draft-irtf-cfrg-concrete-hybrid-kems/pull/1).  The only exception is the IANA considerations section, which should be handled by the HPKE WG.",
      "createdAt": "2025-04-28T18:26:12Z",
      "updatedAt": "2025-05-01T14:47:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ca4807c8b1249830e36a18dbc8b218087eb7bcb8",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "no-concrete",
      "headRefOid": "b7fbef939decc1ce486dabe8a60147f4a846fefd",
      "closedAt": "2025-05-01T14:47:40Z",
      "mergedAt": "2025-05-01T14:47:39Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "55400d76088569aad2bffda3dc1aca2ad5095cde"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6nfIH5",
          "commit": {
            "abbreviatedOid": "b7fbef9"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-01T14:47:33Z",
          "updatedAt": "2025-05-01T14:47:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOMmhxws6VGG6-",
      "title": "Refactor KEM Constructions section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/17",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The basic proposal here is to refactor the Hybrid KEM Constructions section so that:\r\n\r\n* It more clearly addresses the whole definition of the hybrid KEM (including all the specified methods)\r\n* It includes a slightly broader range of options (Chempat-like, TLS-like)\r\n\r\nThe current text is just a sketch; it needs to be turned into actual prose.  But it should give a pretty clear idea of the intended direction.",
      "createdAt": "2025-05-06T12:03:54Z",
      "updatedAt": "2025-05-07T17:28:00Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "55400d76088569aad2bffda3dc1aca2ad5095cde",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "draft-text",
      "headRefOid": "b774ed6c28b8d6a8d7a23a9ae36aaaae5b5efb25",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6oNUv0",
          "commit": {
            "abbreviatedOid": "b774ed6"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-07T14:46:08Z",
          "updatedAt": "2025-05-07T17:28:00Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "* Treat Generate-only as an exception case; default assumption is DeriveKeyPair\r\n* RSA for example is missing DKP, though in principle it could be defined",
              "createdAt": "2025-05-07T14:46:08Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 50,
              "body": "TODO: Make sure that we have all the security properties we need for this.\r\n\r\n* SHAKE calls it the \"flat sponge property\" -- capacity is 2x security level.\r\n* Might need to be a dual PRF for some definition?\r\n* Might not be if we use a different tool (KDF) for the combiners.\r\n\r\nTODO: Re-add / maintain that distinction (XOF + KDF)",
              "createdAt": "2025-05-07T14:52:16Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 83,
              "body": "* Having seed expansion makes it hard to manipulate seeds\r\n* Should be `Nseed = max(KEM_T.Nseed, KEM_PQ.Nseed)` ?\r\n* In concept, 2x security level (would need to state the security level)\r\n    * Might have a birthday collision issue?\r\n    * Could lead to generating shorter secrets from longer secrets at the higher security level",
              "createdAt": "2025-05-07T15:03:45Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 86,
              "body": "* Might not be natural for CT to be fixed size in some case\r\n* Only implication to variable length would be length prefixes in combiners\r\n* Assume fixed size for now, let people push back on it\r\n* Fall-back: Document how you could fit a variable-size values",
              "createdAt": "2025-05-07T15:12:13Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 77,
              "body": "* Could start with one label field, then build a structured label that has (construction + app)\r\n* Having a single label field can get the discussion started in the WG about why people want labels\r\n* Might call it a \"context\" if provided by the app\r\n* Some KEMs (e.g., ML-KEM) have a context input, could reflect in KEM API, probably not worthwhile",
              "createdAt": "2025-05-07T15:21:31Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 180,
              "body": "* Might need some additional assumptions on the KEMs to get here.\r\n* Why does it work with X25519 and ML-KEM?\r\n",
              "createdAt": "2025-05-07T15:36:04Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 180,
              "body": "cc @bwesterb ",
              "createdAt": "2025-05-07T15:36:21Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 18,
      "id": "PR_kwDOMmhxws6VpV7t",
      "title": "Several editorial changes and rewrites",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/18",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR makes several primarily editorial changes, in preparation for the more significant edits to the combiners and security properties sections.\r\n\r\n* (pk, sk) -> (ek, dk)\r\n* New text in the abstract and introduction\r\n* Removes a couple of unnecessary function definitions\r\n* Clean up in the definition of the KEM interface\r\n* Rewrote the DH section as a KEM-to-DH construction\r\n\r\nThe last change is the most substantial one.  The current combiner constructions make explicit reference to the DH functions of the T algorithm.  The idea of this rewrite is to handle both the PQ and T algorithms through the KEM interface.  \r\n\r\nHandling both algorithms through the same interface is aesthetically nicer, since things will be more parallel, but could also allow for non-DH options like RSA.  At least in principle; I would object to actually spending words on such a possibility in this document.  In fact, I'm not totally sure we need to have the DH KEM construction in the main text, as opposed to having it in an appendix that is referred to as necessary.  (I also thought about moving it to the concrete combiners document, but it seems generic enough and useful enough as a motivator to be included here.)\r\n\r\nI'm not sure why `includes.mk` got deleted.  I presume it was was something in the tooling; I didn't do it deliberately.",
      "createdAt": "2025-05-09T22:09:06Z",
      "updatedAt": "2025-05-10T20:22:48Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "55400d76088569aad2bffda3dc1aca2ad5095cde",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "edit-pass",
      "headRefOid": "e20cca74d0e78daae816b7f774fe52eee9cba5c3",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for this revision. I think it looks largely good (a few comments added). I similarly would recommend punting description of RSA. For DH, I think it depends on whether the concrete options will be DH-based or DHKEM-based. The latter can be generalized for KEM, but we talked about efficiencies of the former. It would see odd to have a concrete document that uses DH instead of DHKEM, if the generalism is all KEM-based or DH doesn't feature heavily. So I am somewhat inclined to have the DH discussion fairly prominent.",
          "createdAt": "2025-05-10T20:22:47Z",
          "updatedAt": "2025-05-10T20:22:47Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6ovoVv",
          "commit": {
            "abbreviatedOid": "e20cca7"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-10T20:14:33Z",
          "updatedAt": "2025-05-10T20:14:34Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I recommend that we avoid \"timed\" statements in the draft that might not age well. This can be changed to:\r\n\r\nPost-quantum (PQ) algorithms offer a redesign of traditional algorithms tailored towards resisting attack from a quantum computer. Key Encapsulation Mechanisms (KEMs), are a standardized algorithm type that can be used to build protocols in lieu of traditional, quantum-vulnerable variants such as Diffie-Hellman (DH) based protocols. Given the novelty of PQ algorithms, however....",
              "createdAt": "2025-05-10T20:14:33Z",
              "updatedAt": "2025-05-10T20:14:34Z"
            }
          ]
        }
      ]
    }
  ]
}