{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-07-01T01:20:39.949510+00:00",
  "repo": "cfrg/draft-irtf-cfrg-hybrid-kems",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "TODO",
      "description": "Known gap in the document",
      "color": "28F613"
    },
    {
      "name": "discuss",
      "description": "Needs discussion to identify the right outcome",
      "color": "C96DEA"
    }
  ],
  "issues": [
    {
      "number": 4,
      "id": "I_kwDOMmhxws6rCIMm",
      "title": "Should instance labels include the XOF that's used for key generation?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/4",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "For example, `QSF-SHA3-256-ML-KEM-768-P-256` doesn't say that it uses SHAKE256 for the XOF. Should we?",
      "createdAt": "2025-02-21T16:15:05Z",
      "updatedAt": "2025-02-25T17:22:50Z",
      "closedAt": "2025-02-25T17:22:50Z",
      "comments": []
    },
    {
      "number": 7,
      "id": "I_kwDOMmhxws6rz1bb",
      "title": "Consider renaming KitchenSink to TranscriptHash",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/7",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See [this post](https://mailarchive.ietf.org/arch/msg/cfrg/L7G1rXH9g_acH1uhs4G2IKRN7dU/).",
      "createdAt": "2025-02-26T18:39:03Z",
      "updatedAt": "2025-05-29T21:54:19Z",
      "closedAt": "2025-05-29T21:54:18Z",
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "NONE",
          "body": "I'm not sure that's right thought\n\n``` \nss = LabeledHKDF(pq_SS, trad_SS, pq_CT, pq_PK, trad_CT, trad_PK, label)\n```\n\nThere's no \"transcript\" in there, unless you jam it into the label, but that's not required by the text? And I think that TLS has a well-defined concept of a \"transcript\", but I think it's less clear what counts as \"transcript\" for example if you have a JWT payload on an HTTP POST -- does \"transcript\" mean that the entire payload of the JWT should be included in the label? Or does \"transcript\" mean the entire sequence of HTTP messages exchanged so far on this connection? Obviously that's not what's intended, but might be how a non-cryptographer interprets the word \"transcript\". I don't have a better suggestion than \"KitchenSink\", but I don't think that \"TranscriptHash\" is the right connotation for protocols that aren't TLS.",
          "createdAt": "2025-02-26T20:06:05Z",
          "updatedAt": "2025-02-26T20:24:15Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Dupe of #20 ",
          "createdAt": "2025-05-29T21:54:18Z",
          "updatedAt": "2025-05-29T21:54:18Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOMmhxws6sPD0w",
      "title": "IANA Register HPKE KDFs?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/8",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The IANA \"Hybrid Public Key Encryption (HPKE)\" page has registries for KEMs, KDFs, and AEADs. Currently, the only KDFs registered are HKDF-SHA256/384512.\n\nI believe that someone needs to register at least these two KDFs in the IANA registry before HPKE key derivation is truly supported:\n- KDF(SHA3-256) \u2014 referring to Section 6.1 of FIPS202\n- XOF(SHAKE256) \u2014 referring to Section 6.2 of FIPS202\n\nThis document seems a likely place for that registration. It may have the nice side effect that the names of the QSF-based KEMs can become shorter.\n",
      "createdAt": "2025-03-02T15:52:34Z",
      "updatedAt": "2025-03-07T20:34:52Z",
      "closedAt": "2025-03-07T20:34:52Z",
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.",
          "createdAt": "2025-03-02T19:48:41Z",
          "updatedAt": "2025-03-02T19:49:02Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.\n\nA separate document to register SHA3 as an HPKE KDF will probably be useful but that's apart from this one",
          "createdAt": "2025-03-02T19:54:50Z",
          "updatedAt": "2025-03-02T19:54:50Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.\n> \n> A separate document to register SHA3 as an HPKE KDF will probably be useful but that's apart from this one\n\nSimilarly, X-Wing is registered In IANA as an HPKE KEM. X-Wing uses SHA3 as its KDF and SHAKE256 as an XOF in its key generation/derivation. Those functions are separate from the HPKE KDFs, same with the KEMs defined and registered in this document and the functions they use internally.",
          "createdAt": "2025-03-02T20:00:26Z",
          "updatedAt": "2025-03-02T20:00:26Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> > > Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.\n> > \n> > \n> > A separate document to register SHA3 as an HPKE KDF will probably be useful but that's apart from this one\n> \n> Similarly, X-Wing is registered In IANA as an HPKE KEM. X-Wing uses SHA3 as its KDF and SHAKE256 as an XOF in its key generation/derivation. Those functions are separate from the HPKE KDFs, same with the KEMs defined and registered in this document and the functions they use internally.\n\n@rohanmahy I've created this to register SHA-3 for HPKE KDFs: https://datatracker.ietf.org/doc/draft-connolly-cfrg-sha3-hpke/",
          "createdAt": "2025-03-04T00:03:04Z",
          "updatedAt": "2025-03-04T00:03:04Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "SHA-3 unfortunately doesn't match the Extract/Expand API expected by HPKE spec so it's not as easy but we can keep working on it",
          "createdAt": "2025-03-07T20:34:44Z",
          "updatedAt": "2025-03-07T20:34:44Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOMmhxws6tFcFU",
      "title": "Make concatenation of KDF inputs explicit in concrete pseudocode",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/10",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We can clarify this concatenation to match the generic QSF construction more closely using the explicit concat() routine described earlier",
      "createdAt": "2025-03-07T20:35:32Z",
      "updatedAt": "2025-05-29T21:53:00Z",
      "closedAt": "2025-05-29T21:52:58Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in current `main`.",
          "createdAt": "2025-05-29T21:52:59Z",
          "updatedAt": "2025-05-29T21:52:59Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOMmhxws6tFlU6",
      "title": "Type inconsistency for `trad_PK`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/11",
      "state": "CLOSED",
      "author": "bluegate010",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "- In `expandDecapsulationKey` (and therefore in `KeyGen`, `DeriveKey`, and `Decaps`), `trad_PK` is a serialized byte array (`trad_PK = G.SerializeElement(NominalGroup.ScalarMultBase(trad_SK))`)\n- In `Encaps`, `trad_PK` is a deserialized element (`trad_PK = P-256.DeserializeElement(pk[1184:1217])`)\n- In `EncapsDerand` for QSF-P256, `trad_PK` is a deserialized element (`trad_PK = P-256.DeserializeElement(pk[1184:1217])`), but is later treated as a serialized byte array (`ss = SHA3-256(pq_SS, trad_SS, trad_CT, trad_PK, label)`)\n- In `EncapsDerand` for KS-X25519, `trad_PK` is a serialized byte array (`trad_PK = pk[1184:1216]`)\n- In `EncapsDerand` for QSF-P384, `trad_PK` is deserialized element (`trad_PK = P-384.DeserializeElement(pk[1568:1629])`)\n\nFor clarity, it seems reasonable for `trad_PK` to always be a serialized byte array.",
      "createdAt": "2025-03-07T20:55:14Z",
      "updatedAt": "2025-05-29T21:49:21Z",
      "closedAt": "2025-05-29T21:49:21Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This has been fixed in the latest `main`.  All the values the KEM interface deals with are fixed-length byte arrays.",
          "createdAt": "2025-05-29T21:49:21Z",
          "updatedAt": "2025-05-29T21:49:21Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOMmhxws6y1iX9",
      "title": "Flesh out the 'out of scope' details more",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/13",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dconnolly"
      ],
      "labels": [
        "TODO"
      ],
      "body": "",
      "createdAt": "2025-04-16T18:10:07Z",
      "updatedAt": "2025-05-29T21:56:34Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 14,
      "id": "I_kwDOMmhxws6y1lj0",
      "title": "Flesh out tradeoffs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/14",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "TODO"
      ],
      "body": "- [ ] include not looking at 'layered' style hybrids\n- [ ] include not looking at split/dualPRF style",
      "createdAt": "2025-04-16T18:15:46Z",
      "updatedAt": "2025-05-29T21:56:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate / subset of #13 ?",
          "createdAt": "2025-05-29T21:52:38Z",
          "updatedAt": "2025-05-29T21:52:38Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "I_kwDOMmhxws6016Gs",
      "title": "Rename to '-generic-hybrid-kems' to match '-concrete-hybrid-kems'",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/16",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "",
      "createdAt": "2025-05-01T14:50:46Z",
      "updatedAt": "2025-05-29T22:45:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems like more keystrokes for no real value.",
          "createdAt": "2025-05-29T21:57:18Z",
          "updatedAt": "2025-05-29T21:57:18Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOMmhxws63zN4v",
      "title": "Names for the schemes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/20",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "GHP? ",
      "createdAt": "2025-05-22T14:51:19Z",
      "updatedAt": "2025-05-29T21:55:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I presume you mean \"KitchenSink\" \ud83d\ude04  \n\nWhat does \"GHP\" mean?",
          "createdAt": "2025-05-27T21:32:25Z",
          "updatedAt": "2025-05-27T21:32:25Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "I presume [Giacon, Heuer, Poettering](https://eprint.iacr.org/2018/024.pdf)\n",
          "createdAt": "2025-05-27T21:41:19Z",
          "updatedAt": "2025-05-27T21:41:19Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Renamed the issue to be a little more generic.  Current `main` renames things to try to be more neutral / descriptive: HashEverything / PreHashKeys / HashTraditionalOnly.  The original names (KitchenSink / Chempat / QSF) are a little catchier.  It would be nice if there were something catchy that was also more descriptive of what's going on.  Suggestions welcome.",
          "createdAt": "2025-05-29T21:51:45Z",
          "updatedAt": "2025-05-29T21:51:45Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOMmhxws6401jO",
      "title": "Instantiation of KitchenSink / HashEverything with a nominal group instead of a KEM",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/23",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "",
      "createdAt": "2025-05-29T16:31:47Z",
      "updatedAt": "2025-05-29T22:08:32Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It is technically possible to instantiate the KitchenSink / HashEverything scheme with a nominal group (e.g., ECDH) in place of the IND-CCA KEM called for in the current text.  You just define a pseudo-KEM where the CT is a group element and Encap/Decap are DH operations.\n\nOn the one hand, it seems like this should be secure.  In the case where the PQ KEM is broken, it is effecitively DH-KEM, which is IND-CCA.\n\nOn the other hand, it's not clear that this is a construction that has been analyzed in the literature.  The GHP paper that underlies KitchenSink / HashEverything requires that the inputs be IND-CCA KEMs.\n\nIf we are going to specify this, then we have two choices as to how to define it:\n\n1. Define the \"pseudo-KEM\" sketched above.  This option is notationally compact, but risks people implementing ECDH as a KEM even though it's not secure.\n2. Write out the full instantiation using the Group API.  This option is verbose, but doesn't define a KEM that is not IND-CCA.",
          "createdAt": "2025-05-29T22:08:26Z",
          "updatedAt": "2025-05-29T22:08:26Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOMmhxws641cOD",
      "title": "Refactor security properties subsection of Security Considerations section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/24",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "TODO"
      ],
      "body": "We have some language on IND-CCA and C2PRI but need more on the rest:\n\n## Security Properties\n\n### INDistinguishability against Chosen-Ciphertext Attacks (IND-CCA)\n\n### Ciphertext Second Preimage Resistance (C2PR)\n\n### Binding Properties (X-BIND-P-Q)\n\n### Survival if One KEM Fails\n\n## Security of the Combiners\n\n### Everything {#everything-sec}\n\n### OnlyTraditional {#only-traditional-sec}\n\n### OnlySharedSecrets {#only-shared-secrets-sec}",
      "createdAt": "2025-05-29T17:36:01Z",
      "updatedAt": "2025-06-11T17:39:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "~~Can you point me towards the existing language in the draft on IND-CCA and C2PRI?~~\n\nnever mind, found it",
          "createdAt": "2025-06-11T17:18:31Z",
          "updatedAt": "2025-06-11T17:39:37Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOMmhxws643qD-",
      "title": "Specify the security requirements for constituent elements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/25",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "pag-crypto"
      ],
      "labels": [
        "discuss"
      ],
      "body": "We have three types of constituents that go into our hybrid schemes:\n\n1. KEMs\n2. Nominal groups\n3. Hash functions\n\nThe security requirements for the former two are pretty clear: A KEM needs to be IND-CCA, and if it is going to be used with QSF / HashTraditionalOnly, it needs to have some additional binding properties.  A nominal group needs to be secure in the sense of [ABH+20].\n\nFor the \"hash functions\", we should define a requirement that aligns well with the constructions in the literature, some combination of notions of XOF, KDF, and RO.",
      "createdAt": "2025-05-29T22:12:54Z",
      "updatedAt": "2025-06-24T21:37:28Z",
      "closedAt": null,
      "comments": [
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "The current draft has some language on this. Did you want me to review it or add something specific to it?",
          "createdAt": "2025-06-24T18:32:45Z",
          "updatedAt": "2025-06-24T18:32:45Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I would treat the current text as a baseline and feel free to review / revise / reorient as makes sense to tell the overall story.",
          "createdAt": "2025-06-24T21:37:27Z",
          "updatedAt": "2025-06-24T21:37:27Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOMmhxws643qoZ",
      "title": "Define the desired security properties for the hybrid KEMs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/26",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "pag-crypto"
      ],
      "labels": [
        "TODO"
      ],
      "body": "Normal KEM security notions apply, particularly IND-CCA and X-BIND-P-Q.\n\nThe interesting thing will be how to discuss the \"hybrid\" security notion, i.e., the survival of at least IND-CCA when at least one KEM fails -- for some definition of \"fails\".",
      "createdAt": "2025-05-29T22:14:34Z",
      "updatedAt": "2025-06-25T10:50:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "Do we want some kind of \"hybrid\" security notion for all the KEM security properties we care about? E.g., do we care about the X-BIND-P-Q security of the hybrid if the X-BIND-P-Q security of one of the components fails?",
          "createdAt": "2025-06-24T17:46:17Z",
          "updatedAt": "2025-06-24T17:46:17Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "My impression is that (a) binding properties are generally less important\r\nthan confidentiality properties (IND-CCA), but also (b) binding properties\r\ntend to hold up better than confidentiality properties.  So on the one\r\nhand, if this is a hard thing to show, I might not be sad to lose it.  But\r\non the other hand, I kind of expect we will get some binding properties\r\ntotally irrespective of the security properties of the constituents, e.g.,\r\nX-BIND-SS-Q just by virtue of hashing stuff.\r\n\r\nOn Tue, Jun 24, 2025 at 1:46\u202fPM Paul Grubbs ***@***.***>\r\nwrote:\r\n\r\n> *pag-crypto* left a comment (cfrg/draft-irtf-cfrg-hybrid-kems#26)\r\n> <https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/26#issuecomment-3001363390>\r\n>\r\n> Do we want some kind of \"hybrid\" security notion for all the KEM security\r\n> properties we care about? E.g., do we care about the X-BIND-P-Q security of\r\n> the hybrid if the X-BIND-P-Q security of one of the components fails?\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/26#issuecomment-3001363390>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAASOTJVCI7HA34TXDV43UT3FGFH5AVCNFSM6AAAAAB6GTH3UGVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZTAMBRGM3DGMZZGA>\r\n> .\r\n> You are receiving this because you authored the thread.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2025-06-24T21:30:01Z",
          "updatedAt": "2025-06-24T21:30:01Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "I have not seen even a somewhat realistic scenario where MAL-BIND-P-Q is relevant. But LEAK-BIND-K-PK certainly [has come up](https://iacr.org/submit/files/slides/2025/pkc/pkc2025/19/19_slides.pdf). Abstractions are a bit annoying here: assuming hashes are secure, a concrete hybrid of ML-KEM that hashes in the traditional public key is LEAK-BIND-K-PK, but you can not prove this if you take the components opaquely.",
          "createdAt": "2025-06-25T10:50:59Z",
          "updatedAt": "2025-06-25T10:50:59Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOMmhxws643rU2",
      "title": "Describe how the hybrid schemes meet the security goals",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/27",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "pag-crypto"
      ],
      "labels": [
        "TODO"
      ],
      "body": "We should provide citations to proofs in the literature that the schemes we describe are secure given our requirements on the inputs.\n\n* HashEverything should map to one of the schemes in GHP20\n* PreHashKeys - not clear what the right citation is here?\n* HashTraditionalOnly maps to the QSF construction in BCD+24",
      "createdAt": "2025-05-29T22:16:33Z",
      "updatedAt": "2025-06-24T18:11:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "I just read over GHP again; none of their constructions actually match what we now call \"GHP\" in the draft. The issue is that their \"parallel KEM combiner\" construction doesn't hash the public keys, but our \"GHP\" does. Briefly skimming their Theorem 1 (page 10), though, it seems their result would go through basically unmodified if the public keys were added. (The relevant step is claim 3 in that proof. The observation is just that adding the public keys to their \"core\" function W would not change the way the split-key pseudorandomness reduction works except for the concrete Eval oracle inputs.)",
          "createdAt": "2025-06-24T18:09:21Z",
          "updatedAt": "2025-06-24T18:09:21Z"
        },
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "For PRE, as I alluded to in a comment on a different issue - if the gesture I made above at an extension of the GHP analysis is satisfying, then the same analysis should also imply the CCA2 security of PRE as long as you add a step that \"gets rid of\" collisions in the key hash.",
          "createdAt": "2025-06-24T18:11:31Z",
          "updatedAt": "2025-06-24T18:11:31Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOMmhxws643s8r",
      "title": "Serialization of compound values",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/28",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "The values that a hybrid KEM deals with are compound:\n\n* `dk_H = (dk_T, dk_PQ)`\n* `ek_H = (ek_T, ek_PQ)`\n* `ct_H = (ct_T, ct_PQ)`\n\nThe constituent values are fixed-length byte strings, which is needed because we want to feed them into hash functions without ambiguity and without length prefixes.\n\nThe current text specifies that the hybrid values are just the concatenation of the constituent values, and does `concat()` and `split()` as appropriate.  On the one hand, this is a simple construction (avoiding encoding ambiguities one sees, e.g., with ECDSA signatures), and means that the hybrid KEM meets the same KEM API as the constituents.  On the other hand, there's no real need to specify an encoding for these values, so we could punt on the question.",
      "createdAt": "2025-05-29T22:21:23Z",
      "updatedAt": "2025-05-29T23:03:24Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 29,
      "id": "I_kwDOMmhxws6437i1",
      "title": "Should DeriveKeyPair be optional?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/29",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "In the KEM interface, we currently require a DeriveKeyPair algorithm.  We could make this optional, in the same way that `EncapsDerand` is optional.\n\nOn the one hand, this algorithm is not typically included in descriptions of KEMs in the literature.  On the other hand, it is important for integration with things like HPKE and MLS, and most KEMs provide such an algorithm in practice (even if just by making the randomness used by GenerateKeyPair explicit).",
      "createdAt": "2025-05-29T23:05:53Z",
      "updatedAt": "2025-06-25T11:10:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Another application is FIDO2, where key pairs are derived determinisitcally. I see no downside to making this required.",
          "createdAt": "2025-06-25T11:10:01Z",
          "updatedAt": "2025-06-25T11:10:01Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOMmhxws6438FT",
      "title": "EncapsDerand: Use it or lose it.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/30",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, we define `EncapsDerand` as an optional method on the KEM interface.  But we don't use it anywhere, and we don't define it for the hybrid KEMs.  We should either define this method for the hybrid KEMs when the constituents support it (and thus use it), or delete it.\n\nIf we want it just for purposes of test vectors, we could move it to an appendix.",
      "createdAt": "2025-05-29T23:07:52Z",
      "updatedAt": "2025-06-24T17:14:40Z",
      "closedAt": "2025-06-24T17:14:40Z",
      "comments": []
    },
    {
      "number": 35,
      "id": "I_kwDOMmhxws67anGj",
      "title": "Group_T.ElementToSharedSecret - what does this mean?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/35",
      "state": "OPEN",
      "author": "pag-crypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft does not specify this procedure, but suggests the possibility of doing x-truncation of an elliptic curve point. The details here seem important for security - for example, x-truncation actually does not bind the entire shared secret into the context - the sign bit is omitted, so there are two possible points even in the case of an honest Encaps.",
      "createdAt": "2025-06-13T17:55:50Z",
      "updatedAt": "2025-06-25T10:57:47Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "The intent here is to capture standard practices w.r.t. elliptic curves.  Despite the fact that there are two points on a curve with the same X coordinate, truncation to the X coordinate is the standard way to get a shared secret from an elliptic curve point.  [NIST SP 800-56A](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar3.pdf) (Section 5.7.1.2) lays this out for the Weierstrass curves that NIST uses.  [RFC 7748](https://datatracker.ietf.org/doc/html/rfc7748#section-5) defines X25519 and X448 purely in terms of U coordinates, ignoring the V coordinate entirely.",
          "createdAt": "2025-06-20T15:41:47Z",
          "updatedAt": "2025-06-20T15:41:47Z"
        },
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "I see, thanks for explaining that. I have a slight suspicion that this could cause problems for beyond-CCA2 properties like binding, because for any DH shared secret the values aG and (-a)G are both valid KEM ciphertexts for a given public key. (It's possible I did the math wrong here, but some kind of negative-sign-swap has to be possible since information is lost in the truncation...) In short, the \"full\" context isn't really bound into the derived key if only the x-coordinate is hashed. ",
          "createdAt": "2025-06-24T17:14:56Z",
          "updatedAt": "2025-06-24T17:14:56Z"
        },
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, I'm thinking about this more and I'm not sure DH-KEM in general is even CCA2 secure if you get rid of the y-coordinate? In the CCA game the adversary, given its challenge DH-KEM ciphertext C, can just negate C and submit -C to the decaps oracle. If in decaps you ignore the y-coordinate, C and -C derive the same key and the adversary wins w.p. 1. Maybe I'm missing something and this attack doesn't work, though.",
          "createdAt": "2025-06-24T18:20:03Z",
          "updatedAt": "2025-06-24T18:20:03Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that the terminology here is a bit twitchy -- there's the obvious\r\n\"KEM\" induced by DH, and there's also DHKEM in the sense of HPKE / RFC9180.\r\n\r\nDHKEM in the sense of HPKE / RFC 9180 is IND-CCA, as I think is shown in\r\nABH+21.  (The -Y issue is addressed by hashing in the full public key (X,\r\nY).)\r\n\r\nDHKEM in the sense of the obvious \"KEM\" induced by DH -- I think this is\r\ngenerally known to be not IND-CCA.  That's why there's a separate nominal\r\ngroup treatment instead of just specifying the obvious KEM.\r\n\r\nOn Tue, Jun 24, 2025 at 2:20\u202fPM Paul Grubbs ***@***.***>\r\nwrote:\r\n\r\n> *pag-crypto* left a comment (cfrg/draft-irtf-cfrg-hybrid-kems#35)\r\n> <https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/35#issuecomment-3001459178>\r\n>\r\n> Actually, I'm thinking about this more and I'm not sure DH-KEM in general\r\n> is even CCA2 secure if you get rid of the y-coordinate? In the CCA game the\r\n> adversary, given its challenge DH-KEM ciphertext C, can just negate C and\r\n> submit -C to the decaps oracle. If in decaps you ignore the y-coordinate, C\r\n> and -C derive the same key and the adversary wins w.p. 1. Maybe I'm missing\r\n> something and this attack doesn't work, though.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/35#issuecomment-3001459178>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAASOTJ4T5FUQ2YCSMP3CET3FGJGRAVCNFSM6AAAAAB7IXJUYSVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZTAMBRGQ2TSMJXHA>\r\n> .\r\n> You are receiving this because you commented.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2025-06-24T21:45:28Z",
          "updatedAt": "2025-06-24T21:45:28Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> Actually, I'm thinking about this more and I'm not sure DH-KEM in general is even CCA2 secure if you get rid of the y-coordinate? In the CCA game the adversary, given its challenge DH-KEM ciphertext C, can just negate C and submit -C to the decaps oracle.\n\nYou'd need to get rid of the y-coordinate everywhere (so also the decaps oracle only takes x coordinate.)\n\n",
          "createdAt": "2025-06-25T10:57:46Z",
          "updatedAt": "2025-06-25T10:57:46Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "I_kwDOMmhxws68ku2x",
      "title": "Determine the security requirements for PRE/KeyHash",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/36",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "The PRE scheme requires a KeyHash function for pre-hashing the encapsulation keys.  We should specify what security definitions this function needs to meet.\n\nThe only example we have right now is the use of SHA3-256 in the Chempat specification, which does not include a general security definition or any proofs of security from which we could back out a definition.",
      "createdAt": "2025-06-20T15:45:47Z",
      "updatedAt": "2025-06-24T21:26:17Z",
      "closedAt": null,
      "comments": [
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't really see why plain collision-resistance can't work here? As far as the analysis goes, as long as you \"get rid of\" KeyHash collisions using a CRH game hop, in the rest of the analysis you can treat the hash as being basically the same as the keys themselves. Put slightly differently I suspect you could take an analysis of pretty much any property for GHP and mechanically transform the analysis into one for PRE, by just adding one step that gets rid of collisions at the beginning. (Usual caveats apply, since I made up this claim on the spot just now.)",
          "createdAt": "2025-06-24T17:42:55Z",
          "updatedAt": "2025-06-24T17:42:55Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems plausible to me that collision-resistance is sufficient.  But we would want to either cite something to that effect or lay out the analysis in the document.",
          "createdAt": "2025-06-24T21:26:17Z",
          "updatedAt": "2025-06-24T21:26:17Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "I_kwDOMmhxws68kvgh",
      "title": "Add citations to proofs that NIST curves are nominal groups",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/37",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "TODO"
      ],
      "body": "",
      "createdAt": "2025-06-20T15:46:53Z",
      "updatedAt": "2025-06-25T03:44:39Z",
      "closedAt": "2025-06-25T03:44:39Z",
      "comments": [
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "The HPKE analysis paper discusses how to view NIST P-curves, Curve25519, and Curve448 as nominal groups: https://eprint.iacr.org/2020/1499.pdf \n\nis this what you mean? I'm not sure what a more precise \"proof\" would look like - the nominal groups notion seems more syntactic than like a hardness assumption or something like that.",
          "createdAt": "2025-06-24T17:37:47Z",
          "updatedAt": "2025-06-24T17:37:47Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I think that's probably the right citation.  We just need to cite it!\n\nTo your point about hardness: Seems like the right phrasing is probably something like \"A nominal group in which the [some Diffie-Hellman] problem is hard\", right?  Where the DH notion would be whatever the relevant hybrid KEM proofs rely on.",
          "createdAt": "2025-06-24T21:22:54Z",
          "updatedAt": "2025-06-24T21:24:46Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "I_kwDOMmhxws68kxoa",
      "title": "Define a registry of combination labels?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/38",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "The hybrid schemes include a \"label\" input that provides domain separation between specific instantiations.  It could help interoperability if there were a central list of these labels, with references to the instantiations they go with.  This could be a very simple IANA registry, just a \"label\" column and a \"reference\" column.  It might even be fine to make the registration policy First Come First Served.",
      "createdAt": "2025-06-20T15:50:21Z",
      "updatedAt": "2025-06-20T22:43:47Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "not sure about labels per se, also this sounds closer to an IANA registry for KEMs period, which i don't think cfrg has done for any primitive; also labels may be the same across different kdfs, inputs, lengths, and achieve oracle cloning, so",
          "createdAt": "2025-06-20T22:43:47Z",
          "updatedAt": "2025-06-20T22:43:47Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "I_kwDOMmhxws69Gt1V",
      "title": "Explicit vs. implicit rejection KEMs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/44",
      "state": "OPEN",
      "author": "pag-crypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the current draft, none of the constructions seem to handle the case where a KEM can \"explicitly\" fail during decapsulation - that is, output some failure indicator instead of a syntactically-valid shared secret. If the constructions only work for implicit-rejection KEMs, we should probably make this clear in the draft to remove a potential future footgun. (Apologies if this was covered somewhere and I missed it..)",
      "createdAt": "2025-06-24T16:51:38Z",
      "updatedAt": "2025-06-25T10:22:26Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> In the current draft, none of the constructions seem to handle the case where a KEM can \"explicitly\" fail during decapsulation - that is, output some failure indicator instead of a syntactically-valid shared secret. If the constructions only work for implicit-rejection KEMs, we should probably make this clear in the draft to remove a potential future footgun. (Apologies if this was covered somewhere and I missed it..)\n\nThe QSF construction 'passes through' whatever its PQ KEM does; GHP seems underspecified; PRE would basically do whatever GHP does, but [GHP18](https://eprint.iacr.org/2018/024.pdf) doesn't even consider implicit/explicit rejection; I've seen sketches of constructions that basically say 'if any component returns \u23da, return \u23da'",
          "createdAt": "2025-06-25T03:48:05Z",
          "updatedAt": "2025-06-25T03:48:05Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Most contact with reality makes an implicitly rejecting KEM explicitly rejecting: for instance, in TLS if both sides do not agree on the same shared secret, the AEAD will error out, and the failed connection is rather explicit. Thus, for security analysis we should assume KEMs are explicitly rejecting (but luckily that [doesn't seem to matter much](https://link.springer.com/chapter/10.1007/978-3-031-86602-9_12).) On the other hand, from an API usability perspective it's better to have an implicitly KEM, as it's one less corner case to deal with. ",
          "createdAt": "2025-06-25T10:22:26Z",
          "updatedAt": "2025-06-25T10:22:26Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "I_kwDOMmhxws69Sro7",
      "title": "Sketch proofs for leak-bind-k-[pk, ct] for generics in appendix",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/47",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bwesterb",
        "dconnolly",
        "pag-crypto"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-25T14:04:59Z",
      "updatedAt": "2025-06-25T14:04:59Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 48,
      "id": "I_kwDOMmhxws69S5qS",
      "title": "Expand on generic framework choices in subsection ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/48",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "GHP: works for generic IND-CCA components, IND-CCA proofs from GHP18, including PKs fits in 'additional data' parts of the split key PRF proof there, and binds to PKs which is nice for protocols, and whole thing matches pubs like NIST SP 800-227 IPD, and gives good binding properties / is generally safe / no caveats on use for broad array of components with current IND-CCA analysis etc\n\nQSF: works for most common elliptic curve groups and C2PRI pq KEMs, optimization that leaves out large ciphertexts and PKs from hashing if the PQ KEM meets requirements, more KEMs can be proven to have C2PRI \n\nPRE: same benefits as GHP while allowing an optimization to pre-hash static PKs, which if large can be a performance improvement",
      "createdAt": "2025-06-25T14:18:55Z",
      "updatedAt": "2025-06-25T14:18:55Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 49,
      "id": "I_kwDOMmhxws69TQER",
      "title": "sketch how PRE is still IND-CCA in appendix",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/49",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "pag-crypto"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-25T14:45:25Z",
      "updatedAt": "2025-06-25T14:45:25Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 52,
      "id": "I_kwDOMmhxws69YbHJ",
      "title": "Sketch BIND proofs for QSF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/52",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-26T00:21:04Z",
      "updatedAt": "2025-06-26T00:21:04Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 53,
      "id": "I_kwDOMmhxws69YbJS",
      "title": "Sketch GHP BIND proofs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/53",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-26T00:21:13Z",
      "updatedAt": "2025-06-26T00:21:13Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 54,
      "id": "I_kwDOMmhxws69YbON",
      "title": "Sketch PRE BIND proofs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/54",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "pag-crypto"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-26T00:21:29Z",
      "updatedAt": "2025-06-26T00:21:29Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 55,
      "id": "I_kwDOMmhxws69wzkg",
      "title": "Ciphertext second-preimage resistance for hybrid KEMs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/55",
      "state": "OPEN",
      "author": "pag-crypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the current draft, ciphertext second pre-image resistance (C2PRI) is listed as a desired property of our hybrid KEMs. What is the justification for this? It is clear that QSF requires the PQ KEM to have ciphertext preimage resistance in order for the composition to be IND-CCA2, but does this mean C2PRI is necessarily a design goal for the whole composition? If so, what is the justification?",
      "createdAt": "2025-06-27T18:08:34Z",
      "updatedAt": "2025-06-27T18:09:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "In my rewrite of the \"security properties\" subsection I'm going to remove it for now, but it'd be pretty easy to add back.",
          "createdAt": "2025-06-27T18:09:50Z",
          "updatedAt": "2025-06-27T18:09:50Z"
        }
      ]
    },
    {
      "number": 56,
      "id": "I_kwDOMmhxws69xXZY",
      "title": "KDF security properties",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/56",
      "state": "OPEN",
      "author": "pag-crypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current writeup is unclear about the security requirements for the KDF: it says both that they must be PRFs and random oracles. I think I know why this ambiguity exists - the X-Wing paper's analyses of QSF have different requirements on the KDF depending on whether security is proved from the strong DH problem or the CCA2 security of the KEM. (The SDH proof requires the ROM - in a nontrivial way - and the CCA2 proof only requires PRF.) \n\nSince (modulo some details) having the KDF modelled as a RO is stronger than treating it as a PRF, i think it would be conservative as a starting point to just require the KDF to be indifferentiable from a RO. However, I think we'll probably get some pushback on this from the CFRG.",
      "createdAt": "2025-06-27T19:07:29Z",
      "updatedAt": "2025-06-27T19:07:29Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 58,
      "id": "I_kwDOMmhxws6-GnVJ",
      "title": "restore rederivation from seed via DeriveKeyPair(seed) inside Decaps()",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/58",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dconnolly"
      ],
      "labels": [],
      "body": "This got mangled in the major refactor",
      "createdAt": "2025-06-30T18:04:24Z",
      "updatedAt": "2025-06-30T18:04:24Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOMmhxws6G-GIs",
      "title": "Fix build and references",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/1",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-01-07T18:01:15Z",
      "updatedAt": "2025-01-08T04:15:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "8f18831dc6e7d2b4cbe13e809c0481aa350625e6",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/fix-refs",
      "headRefOid": "f795b47e09e04f14fc9afae5b8591ec55dd4fd58",
      "closedAt": "2025-01-08T04:15:08Z",
      "mergedAt": "2025-01-08T04:15:08Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "503214de9161bbabeb9ffeb76d24596d8af66752"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6XJ7HM",
          "commit": {
            "abbreviatedOid": "f795b47"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-01-08T04:14:54Z",
          "updatedAt": "2025-01-08T04:14:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 2,
      "id": "PR_kwDOMmhxws6HIQRB",
      "title": "Refactor, cleanup, reorganize",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/2",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This change refactors some stuff and cleans up the in-lined KEM implementation details.",
      "createdAt": "2025-01-08T21:24:34Z",
      "updatedAt": "2025-01-23T18:47:30Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ea0a9337871b8f52777783e10780d40f21b6ca14",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/reorg",
      "headRefOid": "75a1f6564a51ae64ddb2ae86cb25355a8997b705",
      "closedAt": "2025-01-23T18:47:30Z",
      "mergedAt": "2025-01-23T18:47:30Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "5557ce637cb791f95f09cf3271ec5623825047b1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6XcYyA",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-09T19:48:22Z",
          "updatedAt": "2025-01-09T19:48:23Z",
          "comments": [
            {
              "originalPosition": 477,
              "body": "\ud83d\udc4d",
              "createdAt": "2025-01-09T19:48:22Z",
              "updatedAt": "2025-01-09T19:48:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOLdI",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:01:46Z",
          "updatedAt": "2025-01-23T18:01:47Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "```suggestion\r\n- `EncapsDerand(pk, randomness) -> (ct, shared_secret)`: A deterministic encapsulation\r\n   algorithm, which takes as input a public encapsulation key `pk` and randomness\r\n   `randomness`, and outputs a ciphertext `ct` and shared secret `shared_secret`.\r\n```",
              "createdAt": "2025-01-23T18:01:46Z",
              "updatedAt": "2025-01-23T18:01:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOMAE",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:02:53Z",
          "updatedAt": "2025-01-23T18:02:53Z",
          "comments": [
            {
              "originalPosition": 610,
              "body": "```suggestion\r\ndef EncapsDerand(pk, randomness):\r\n  pq_PK = pk[0:1184]\r\n  trad_PK = pk[1184:1217]\r\n  (pq_SS, pq_CT) = ML-KEM-768.EncapsDerand(pq_PK, randomness[0:32])\r\n  ek = randomness[32:65]\r\n  trad_CT = P-256.ScalarMultBase(ek)\r\n  trad_SS = P-256.ScalarMult(ek, trad_PK)\r\n  ss = SHA3-256(pq_SS, trad_SS, trad_CT, trad_PK, label)\r\n  ct = concat(pq_CT, trad_CT)\r\n```",
              "createdAt": "2025-01-23T18:02:53Z",
              "updatedAt": "2025-01-23T18:02:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOMGw",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:03:05Z",
          "updatedAt": "2025-01-23T18:03:06Z",
          "comments": [
            {
              "originalPosition": 619,
              "body": "```suggestion\r\nNote that `randomness` MUST be 65 bytes.\r\n```",
              "createdAt": "2025-01-23T18:03:05Z",
              "updatedAt": "2025-01-23T18:03:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOMoP",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:04:11Z",
          "updatedAt": "2025-01-23T18:04:12Z",
          "comments": [
            {
              "originalPosition": 864,
              "body": "```suggestion\r\ndef EncapsDerand(pk, randomness):\r\n  pq_PK = pk[0:1184]\r\n  trad_PK = pk[1184:1216]\r\n  (pq_SS, pq_CT) = PQ-KEM.EncapsDerand(pq_PK, randomness[0:32])\r\n  ek = randomness[32:64]\r\n```",
              "createdAt": "2025-01-23T18:04:11Z",
              "updatedAt": "2025-01-23T18:04:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZONxs",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:06:33Z",
          "updatedAt": "2025-01-23T18:06:34Z",
          "comments": [
            {
              "originalPosition": 877,
              "body": "```suggestion\r\nNote that `randomness` MUST be 64 bytes.\r\n```",
              "createdAt": "2025-01-23T18:06:33Z",
              "updatedAt": "2025-01-23T18:06:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOPiO",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:10:14Z",
          "updatedAt": "2025-01-23T18:10:14Z",
          "comments": [
            {
              "originalPosition": 1161,
              "body": "```suggestion\r\ndef EncapsDerand(pk, randomness):\r\n  pq_PK = pk[0:1568]\r\n  trad_PK = pk[1568:1629]\r\n  (pq_SS, pq_CT) = ML-KEM-1024.EncapsDerand(pq_PK, randomness[0:32])\r\n  ek = randomness[32:80]\r\n  trad_CT = P-384.ScalarMultBase(ek)\r\n  trad_SS = P-384.ScalarMult(ek, trad_PK)\r\n  ss = SHA3-256(pq_SS, trad_SS, trad_CT, trad_PK, label)\r\n  ct = concat(pq_CT, trad_CT)\r\n```",
              "createdAt": "2025-01-23T18:10:14Z",
              "updatedAt": "2025-01-23T18:10:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOPoo",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:10:28Z",
          "updatedAt": "2025-01-23T18:10:28Z",
          "comments": [
            {
              "originalPosition": 1170,
              "body": "```suggestion\r\nNote that `randomness` MUST be 80 bytes.\r\n```",
              "createdAt": "2025-01-23T18:10:28Z",
              "updatedAt": "2025-01-23T18:10:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOk4A",
          "commit": {
            "abbreviatedOid": "75a1f65"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-01-23T18:46:24Z",
          "updatedAt": "2025-01-23T18:46:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 3,
      "id": "PR_kwDOMmhxws6I0Zg9",
      "title": "Preliminary reference implementations and test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/3",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This mirrors the spec implementation for X-Wing, but it uses Sage for the NIST curve implementation. (Primarily because I had that laying around from other specs. We can replace with a Python implementation in the future if desired.) It fixes some things in the primary spec around key generation (formatting keys as byte strings), fully specifying the DH operations, etc. It also includes preliminary HPKE KEM codepoint registration requests. And, importantly, adds the test vectors produced from the reference implementation.",
      "createdAt": "2025-01-23T21:30:19Z",
      "updatedAt": "2025-02-03T18:44:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "5557ce637cb791f95f09cf3271ec5623825047b1",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/vectors",
      "headRefOid": "9771afd2307ec7032d8d6e8298849e06017c0264",
      "closedAt": "2025-02-03T18:44:49Z",
      "mergedAt": "2025-02-03T18:44:49Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "2f0ea74c9e3e93b7dd4fbd3f0c33fb76256e6fef"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@dconnolly I added a `ScalarFromBytes` function, distinct from `DeserializeScalar`, as an infallible constructor that takes bytes and produces `Scalar` values, with an implementation that matches the reference code under the hood. Please take another look!",
          "createdAt": "2025-02-03T17:35:02Z",
          "updatedAt": "2025-02-03T17:35:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6aOQeU",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\ud83d\ude4f",
          "createdAt": "2025-01-31T17:50:01Z",
          "updatedAt": "2025-01-31T17:50:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6aOT4_",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-31T17:52:25Z",
          "updatedAt": "2025-01-31T17:52:25Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "`%` needs defining above",
              "createdAt": "2025-01-31T17:52:25Z",
              "updatedAt": "2025-01-31T17:52:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6aOXz0",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-31T17:55:37Z",
          "updatedAt": "2025-01-31T17:55:37Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "We could leverage the text above about `Scalar`s and `Element`s to enforce that all instances of `Scalar`s MUST be modulo their order, otherwise they aren't real `Scalar`s ",
              "createdAt": "2025-01-31T17:55:37Z",
              "updatedAt": "2025-01-31T17:55:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6aOYml",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Do we want to enforce the `Scalar` being always modulo its `Order()` via its instantiation? Otherwise we need to define `%` as used in `expandDecapsulationKey` etc",
          "createdAt": "2025-01-31T17:57:13Z",
          "updatedAt": "2025-01-31T17:57:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6aaI9p",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-03T17:11:55Z",
          "updatedAt": "2025-02-03T17:11:55Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "That's a cleaner way to handle this. I'll update the textual description of Scalar to include something about mapping from bytes, and say that the bytes are reduced modulo the order, or something.",
              "createdAt": "2025-02-03T17:11:55Z",
              "updatedAt": "2025-02-03T17:11:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6aa29j",
          "commit": {
            "abbreviatedOid": "9771afd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-03T18:44:32Z",
          "updatedAt": "2025-02-03T18:44:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOMmhxws6MFI2K",
      "title": "Update labels to include XOF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/5",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hopefully these labels are not too terrible on the eyes \ud83e\udd37 \r\n\r\nCloses #4.",
      "createdAt": "2025-02-21T17:19:15Z",
      "updatedAt": "2025-02-25T17:22:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "a1093192626f720d448880692a5d8b258fbf783c",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/update-labels",
      "headRefOid": "9abc6fcfb262e42878b0b67cece04cec09bba491",
      "closedAt": "2025-02-25T17:22:49Z",
      "mergedAt": "2025-02-25T17:22:49Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "10867607a87847ff4d9e03029dcfcd4117b83620"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6dAy3d",
          "commit": {
            "abbreviatedOid": "a7175ff"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T21:14:24Z",
          "updatedAt": "2025-02-21T21:14:24Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\n2. `KitchenSink-KEM(ML-KEM-768,X25519)-XOF(SHAKE256)-KDF(HKDF-SHA-256)` {{ks-x25519}}:\r\n```\r\n\r\nHm I worry about a comma in a label like this, have we done this in other i*tf crypto protocols? Is it fine in practice?",
              "createdAt": "2025-02-21T21:14:24Z",
              "updatedAt": "2025-02-21T21:14:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6deCz8",
          "commit": {
            "abbreviatedOid": "a7175ff"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-25T17:21:26Z",
          "updatedAt": "2025-02-25T17:21:27Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "merging for now, but may want to keep an eye on it",
              "createdAt": "2025-02-25T17:21:27Z",
              "updatedAt": "2025-02-25T17:21:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOMmhxws6MGGlY",
      "title": "Add generic keygen and derivation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/6",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@chris-wood wdyt of the attempt at including slicing of the XOF output into the bytes that go into each component algorithm? \ud83d\ude05",
      "createdAt": "2025-02-21T19:50:44Z",
      "updatedAt": "2025-02-25T17:20:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "f50c9557531cb1237d8be28871842f6fa8675134",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "generic-keygen",
      "headRefOid": "9fcef57ff286640cf383b48579c201ecec104507",
      "closedAt": "2025-02-25T17:20:28Z",
      "mergedAt": "2025-02-25T17:20:28Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "a1093192626f720d448880692a5d8b258fbf783c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6dASs8",
          "commit": {
            "abbreviatedOid": "d76eae8"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T19:57:03Z",
          "updatedAt": "2025-02-21T19:57:11Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Maybe we replace `Nxofout` with `Npqseed + Ntradseed`? I think the `expanded[..Npqseed]` is fairly clear, but we should probably add some text to the terminology section that describes how it works. Something like:\r\n\r\n```\r\nWhen `x` is a byte string, we use the notation `x[..i]` and `x[i..]` to denote the slice of bytes in `x` starting from the beginning of `x` and leading up to index `i`, including the `i`-th byte, and the slice the bytes in `x` starting from index `i` to the end of `x`, respectively. For example, if `x = [0, 1, 2, 3]`, then `x[..2] = [0, 1]` and `x[2..] = [2, 3]`.\r\n```",
              "createdAt": "2025-02-21T19:57:03Z",
              "updatedAt": "2025-02-21T19:57:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6dAzLR",
          "commit": {
            "abbreviatedOid": "d76eae8"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T21:15:08Z",
          "updatedAt": "2025-02-21T21:15:08Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done; can you cross check the numbers for Ntradseed for the p256 and p384 instances?",
              "createdAt": "2025-02-21T21:15:08Z",
              "updatedAt": "2025-02-21T21:15:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6deB_p",
          "commit": {
            "abbreviatedOid": "9fcef57"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-25T17:20:13Z",
          "updatedAt": "2025-02-25T17:20:13Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "confirmed out of bad - they are larger than expected  to make sure the Scalar isn't biased (not a power of 2), these match HashToCurve",
              "createdAt": "2025-02-25T17:20:13Z",
              "updatedAt": "2025-02-25T17:20:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 9,
      "id": "PR_kwDOMmhxws6N0rBY",
      "title": "Clarify concatenation operations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/9",
      "state": "CLOSED",
      "author": "bluegate010",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Clarify that SHA3-256 takes one input which is a concatenation of multiple values.",
      "createdAt": "2025-03-07T20:30:38Z",
      "updatedAt": "2025-05-29T22:03:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ca4807c8b1249830e36a18dbc8b218087eb7bcb8",
      "headRepository": "bluegate010/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "patch-1",
      "headRefOid": "ec575c84b83fe47edd02460667e9e1eda3cc561b",
      "closedAt": "2025-05-29T22:03:37Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "We can clarify this concatenation to match the generic QSF construction more closely using the explicit `concat()` routine described earlier ",
          "createdAt": "2025-03-07T20:33:31Z",
          "updatedAt": "2025-03-07T20:33:31Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "Opened https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/10 for this ",
          "createdAt": "2025-03-07T20:35:50Z",
          "updatedAt": "2025-03-07T20:35:50Z"
        },
        {
          "author": "bluegate010",
          "authorAssociation": "NONE",
          "body": "> We can clarify this concatenation to match the generic QSF construction more closely using the explicit `concat()` routine described earlier\r\n\r\nGot it, have made this adjustment.",
          "createdAt": "2025-03-07T21:01:07Z",
          "updatedAt": "2025-03-07T21:01:07Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by events",
          "createdAt": "2025-05-29T22:03:37Z",
          "updatedAt": "2025-05-29T22:03:37Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOMmhxws6N01c3",
      "title": "Make trad_PK consistently a serialized byte array.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/12",
      "state": "CLOSED",
      "author": "bluegate010",
      "authorAssociation": "NONE",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Resolves https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/11",
      "createdAt": "2025-03-07T20:55:55Z",
      "updatedAt": "2025-05-29T22:03:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ca4807c8b1249830e36a18dbc8b218087eb7bcb8",
      "headRepository": "bluegate010/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "trad_PK",
      "headRefOid": "96dac879d6c53b62e542a06d902b46db8666e6ab",
      "closedAt": "2025-05-29T22:03:18Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by events.",
          "createdAt": "2025-05-29T22:03:18Z",
          "updatedAt": "2025-05-29T22:03:18Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 15,
      "id": "PR_kwDOMmhxws6UNmZE",
      "title": "Remove concrete instantiations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/15",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR removes the following content from this document:\r\n\r\n* The sections defining concrete combiners\r\n* The test vectors section\r\n* The IANA considerations section\r\n* Mentions of specific combinations in the prose\r\n\r\nMost of this text should be moved to the concrete document (https://github.com/cfrg/draft-irtf-cfrg-concrete-hybrid-kems/pull/1).  The only exception is the IANA considerations section, which should be handled by the HPKE WG.",
      "createdAt": "2025-04-28T18:26:12Z",
      "updatedAt": "2025-05-01T14:47:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ca4807c8b1249830e36a18dbc8b218087eb7bcb8",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "no-concrete",
      "headRefOid": "b7fbef939decc1ce486dabe8a60147f4a846fefd",
      "closedAt": "2025-05-01T14:47:40Z",
      "mergedAt": "2025-05-01T14:47:39Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "55400d76088569aad2bffda3dc1aca2ad5095cde"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6nfIH5",
          "commit": {
            "abbreviatedOid": "b7fbef9"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-01T14:47:33Z",
          "updatedAt": "2025-05-01T14:47:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOMmhxws6VGG6-",
      "title": "Refactor KEM Constructions section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/17",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The basic proposal here is to refactor the Hybrid KEM Constructions section so that:\r\n\r\n* It more clearly addresses the whole definition of the hybrid KEM (including all the specified methods)\r\n* It includes a slightly broader range of options (Chempat-like, TLS-like)\r\n\r\nThe current text is just a sketch; it needs to be turned into actual prose.  But it should give a pretty clear idea of the intended direction.",
      "createdAt": "2025-05-06T12:03:54Z",
      "updatedAt": "2025-05-22T14:03:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "55400d76088569aad2bffda3dc1aca2ad5095cde",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "draft-text",
      "headRefOid": "b774ed6c28b8d6a8d7a23a9ae36aaaae5b5efb25",
      "closedAt": "2025-05-22T14:03:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Replaced by #19 ",
          "createdAt": "2025-05-22T14:03:27Z",
          "updatedAt": "2025-05-22T14:03:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6oNUv0",
          "commit": {
            "abbreviatedOid": "b774ed6"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-07T14:46:08Z",
          "updatedAt": "2025-05-07T17:28:00Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "* Treat Generate-only as an exception case; default assumption is DeriveKeyPair\r\n* RSA for example is missing DKP, though in principle it could be defined",
              "createdAt": "2025-05-07T14:46:08Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 50,
              "body": "TODO: Make sure that we have all the security properties we need for this.\r\n\r\n* SHAKE calls it the \"flat sponge property\" -- capacity is 2x security level.\r\n* Might need to be a dual PRF for some definition?\r\n* Might not be if we use a different tool (KDF) for the combiners.\r\n\r\nTODO: Re-add / maintain that distinction (XOF + KDF)",
              "createdAt": "2025-05-07T14:52:16Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 83,
              "body": "* Having seed expansion makes it hard to manipulate seeds\r\n* Should be `Nseed = max(KEM_T.Nseed, KEM_PQ.Nseed)` ?\r\n* In concept, 2x security level (would need to state the security level)\r\n    * Might have a birthday collision issue?\r\n    * Could lead to generating shorter secrets from longer secrets at the higher security level",
              "createdAt": "2025-05-07T15:03:45Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 86,
              "body": "* Might not be natural for CT to be fixed size in some case\r\n* Only implication to variable length would be length prefixes in combiners\r\n* Assume fixed size for now, let people push back on it\r\n* Fall-back: Document how you could fit a variable-size values",
              "createdAt": "2025-05-07T15:12:13Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 77,
              "body": "* Could start with one label field, then build a structured label that has (construction + app)\r\n* Having a single label field can get the discussion started in the WG about why people want labels\r\n* Might call it a \"context\" if provided by the app\r\n* Some KEMs (e.g., ML-KEM) have a context input, could reflect in KEM API, probably not worthwhile",
              "createdAt": "2025-05-07T15:21:31Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 180,
              "body": "* Might need some additional assumptions on the KEMs to get here.\r\n* Why does it work with X25519 and ML-KEM?\r\n",
              "createdAt": "2025-05-07T15:36:04Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 180,
              "body": "cc @bwesterb ",
              "createdAt": "2025-05-07T15:36:21Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 18,
      "id": "PR_kwDOMmhxws6VpV7t",
      "title": "Several editorial changes and rewrites",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/18",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR makes several primarily editorial changes, in preparation for the more significant edits to the combiners and security properties sections.\r\n\r\n* (pk, sk) -> (ek, dk)\r\n* New text in the abstract and introduction\r\n* Removes a couple of unnecessary function definitions\r\n* Clean up in the definition of the KEM interface\r\n* Rewrote the DH section as a KEM-to-DH construction\r\n\r\nThe last change is the most substantial one.  The current combiner constructions make explicit reference to the DH functions of the T algorithm.  The idea of this rewrite is to handle both the PQ and T algorithms through the KEM interface.  \r\n\r\nHandling both algorithms through the same interface is aesthetically nicer, since things will be more parallel, but could also allow for non-DH options like RSA.  At least in principle; I would object to actually spending words on such a possibility in this document.  In fact, I'm not totally sure we need to have the DH KEM construction in the main text, as opposed to having it in an appendix that is referred to as necessary.  (I also thought about moving it to the concrete combiners document, but it seems generic enough and useful enough as a motivator to be included here.)\r\n\r\nI'm not sure why `includes.mk` got deleted.  I presume it was was something in the tooling; I didn't do it deliberately.",
      "createdAt": "2025-05-09T22:09:06Z",
      "updatedAt": "2025-05-27T21:26:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "55400d76088569aad2bffda3dc1aca2ad5095cde",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "edit-pass",
      "headRefOid": "37bda778108e222e735cd5f1f630da10a421c730",
      "closedAt": "2025-05-22T14:56:21Z",
      "mergedAt": "2025-05-22T14:56:21Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "9e85013a9da7226a2e54c098de0ab5043034a158"
      },
      "comments": [
        {
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for this revision. I think it looks largely good (a few comments added). I similarly would recommend punting description of RSA. For DH, I think it depends on whether the concrete options will be DH-based or DHKEM-based. The latter can be generalized for KEM, but we talked about efficiencies of the former. It would see odd to have a concrete document that uses DH instead of DHKEM, if the generalism is all KEM-based or DH doesn't feature heavily. So I am somewhat inclined to have the DH discussion fairly prominent.",
          "createdAt": "2025-05-10T20:22:47Z",
          "updatedAt": "2025-05-10T20:22:47Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed on authors call, will revert the IND-CPA DH section back to an explicit group section.\r\n\r\nAlso @dconnolly sorry I missed your comments here, will address them in the next round.",
          "createdAt": "2025-05-22T14:57:44Z",
          "updatedAt": "2025-05-22T14:57:44Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6ovoVv",
          "commit": {
            "abbreviatedOid": "e20cca7"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-10T20:14:33Z",
          "updatedAt": "2025-05-10T20:14:34Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I recommend that we avoid \"timed\" statements in the draft that might not age well. This can be changed to:\r\n\r\nPost-quantum (PQ) algorithms offer a redesign of traditional algorithms tailored towards resisting attack from a quantum computer. Key Encapsulation Mechanisms (KEMs), are a standardized algorithm type that can be used to build protocols in lieu of traditional, quantum-vulnerable variants such as Diffie-Hellman (DH) based protocols. Given the novelty of PQ algorithms, however....",
              "createdAt": "2025-05-10T20:14:33Z",
              "updatedAt": "2025-05-10T20:14:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQnn8",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T10:49:19Z",
          "updatedAt": "2025-05-14T10:49:20Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Feel free to ignore this stylistic blabbering: personally I like to write \"post-quantum algorithms are designed to resist attack of quantum computers\". Then we don't need any qualifications like \"promise\" or \"believe to\" etc. Of course it's not completely true: several schemes were first designed before quantum computers were known about.",
              "createdAt": "2025-05-14T10:49:19Z",
              "updatedAt": "2025-05-14T10:49:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQqh5",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T10:53:16Z",
          "updatedAt": "2025-05-14T10:53:17Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "There are two more affordances of hybrids\u2014not sure we should go into that now.\r\n\r\n1. You can satisfy an old policy (or expectation) while already adopting PQ.\r\n2. You protect against implementation mistakes. (Say, using a hybrid we protect against a say timing-based active attack in either component.\r\n",
              "createdAt": "2025-05-14T10:53:16Z",
              "updatedAt": "2025-05-14T10:53:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQrRn",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T10:54:20Z",
          "updatedAt": "2025-05-14T10:54:21Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "`brken` typo",
              "createdAt": "2025-05-14T10:54:21Z",
              "updatedAt": "2025-05-14T10:54:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQwCU",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T11:00:44Z",
          "updatedAt": "2025-05-14T11:00:45Z",
          "comments": [
            {
              "originalPosition": 277,
              "body": "IND-CCA and IND-CPA might be meaningless to the reader at this point. What about the following\r\n\r\n> This KEM is not secure against active attack (not IND-CCA).",
              "createdAt": "2025-05-14T11:00:44Z",
              "updatedAt": "2025-05-14T11:00:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQ6Zp",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T11:14:42Z",
          "updatedAt": "2025-05-14T11:14:43Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "I know it makes sense to define the IND-CPA KEM like this, but I'm worried that once it's defined, it's very tempting for implementors to put it in the KEM slot and have it available to users, which do not understand warnings such as \"this is only IND-CPA\".\r\n\r\nNot assigning a code points helps, but maybe we can do more.\r\n\r\nIdeally we'd make the interface of a component incompatible with a proper KEM, but I don't see any non-artificial way to do that.\r\n\r\nDifferent naming only goes so far: I think *Component* or say *PreKEM* would be better.\r\n",
              "createdAt": "2025-05-14T11:14:42Z",
              "updatedAt": "2025-05-14T11:14:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQ7DH",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T11:15:46Z",
          "updatedAt": "2025-05-14T11:15:47Z",
          "comments": [
            {
              "originalPosition": 392,
              "body": "This is breaking abstraction.",
              "createdAt": "2025-05-14T11:15:46Z",
              "updatedAt": "2025-05-14T11:15:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQ8Pv",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-14T11:17:42Z",
          "updatedAt": "2025-05-14T11:17:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6pQ8r8",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T11:18:28Z",
          "updatedAt": "2025-05-14T11:18:28Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Typo",
              "createdAt": "2025-05-14T11:18:28Z",
              "updatedAt": "2025-05-14T11:18:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6psmmU",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-16T15:55:48Z",
          "updatedAt": "2025-05-16T15:55:48Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Added a couple of sentences to this effect in the Introduction.",
              "createdAt": "2025-05-16T15:55:48Z",
              "updatedAt": "2025-05-16T15:55:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6psr9D",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-16T16:05:45Z",
          "updatedAt": "2025-05-16T16:05:45Z",
          "comments": [
            {
              "originalPosition": 277,
              "body": "Reworded this to be more reader-friendly, and provide a forward pointer to the security considerations.",
              "createdAt": "2025-05-16T16:05:45Z",
              "updatedAt": "2025-05-16T16:05:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pss52",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-16T16:07:31Z",
          "updatedAt": "2025-05-16T16:07:31Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "I added some text that explicitly says \"This KEM should not be used on its own.\"  Unfortunately the \ud83d\udea8 emoji isn't allowed in RFCs.",
              "createdAt": "2025-05-16T16:07:31Z",
              "updatedAt": "2025-05-16T16:07:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pstwr",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-16T16:09:15Z",
          "updatedAt": "2025-05-16T16:09:24Z",
          "comments": [
            {
              "originalPosition": 392,
              "body": "Yep, this will get fixed in the next PR.  The only reason this part is getting touched is the global `(sk, pk) -> (dk, ek)` terminology change.",
              "createdAt": "2025-05-16T16:09:15Z",
              "updatedAt": "2025-05-16T16:09:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdlcX",
          "commit": {
            "abbreviatedOid": "6791b79"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:00:09Z",
          "updatedAt": "2025-05-22T06:00:10Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nsecurity against quantum attack. In this document, we define constructions for\r\nhybrid Key Encapsulation Mechanisms (KEMs) based on combining a traditional KEM\r\nand a PQ KEM. Hybrid KEMs using these constructions provide strong security\r\nproperties as long as the undelying algorithms are secure.\r\n```",
              "createdAt": "2025-05-22T06:00:09Z",
              "updatedAt": "2025-05-22T06:00:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdlzu",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:01:02Z",
          "updatedAt": "2025-05-22T06:01:03Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "```suggestion\r\nPost-quantum (PQ) algorithms offer new constructions based on problems tailored\r\ntowards resisting attack from a quantum computer. Key Encapsulation Mechanisms\r\n(KEMs), are a standardized algorithm type that can be used to build protocols in\r\n```",
              "createdAt": "2025-05-22T06:01:02Z",
              "updatedAt": "2025-05-22T06:01:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdmNf",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:02:03Z",
          "updatedAt": "2025-05-22T06:02:03Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "```suggestion\r\nlieu of traditional, quantum-vulnerable variants such as finite field\r\nor elliptic curve Diffie-Hellman (DH) based protocols. Upgrading protocols\r\nto use PQ KEMs is a priority for the\r\n```",
              "createdAt": "2025-05-22T06:02:03Z",
              "updatedAt": "2025-05-22T06:02:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdmvn",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:03:17Z",
          "updatedAt": "2025-05-22T06:03:18Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nbased protocols.  Upgrading key establishment protocols to use PQ KEMs is a\r\npriority for the protocol design community, due to the possibility of\r\n\"harvest now, decrypt later\" attacks.\r\n```",
              "createdAt": "2025-05-22T06:03:18Z",
              "updatedAt": "2025-05-22T06:03:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdnAf",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:03:55Z",
          "updatedAt": "2025-05-22T06:03:55Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "'retains the properties' needs clarity",
              "createdAt": "2025-05-22T06:03:55Z",
              "updatedAt": "2025-05-22T06:03:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdnbg",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:04:28Z",
          "updatedAt": "2025-05-22T06:04:28Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "```suggestion\r\neven if the other KEM is compromised.  If the PQ KEM is broken, then the hybrid\r\nKEM should continue to provide security against\r\n```",
              "createdAt": "2025-05-22T06:04:28Z",
              "updatedAt": "2025-05-22T06:04:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdoAZ",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:05:05Z",
          "updatedAt": "2025-05-22T06:05:06Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "```suggestion\r\nIn addition to guarding against algorithm weakness, this property also guards\r\nagainst flaws in implementations, such as timing attacks.  Hybrid KEMs can also\r\nfacilitate faster deployment of PQ security by allowing applications to\r\n```",
              "createdAt": "2025-05-22T06:05:05Z",
              "updatedAt": "2025-05-22T06:05:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdocC",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:05:58Z",
          "updatedAt": "2025-05-22T06:05:59Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "But not only KEMs as components, as in QSF - we combine traditional components and PQ KEMs",
              "createdAt": "2025-05-22T06:05:59Z",
              "updatedAt": "2025-05-22T06:05:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdoi5",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:06:13Z",
          "updatedAt": "2025-05-22T06:06:14Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "```suggestion\r\nof techniques for constructing hybrid KEMs designed to achieve specific security\r\nproperties given conforming component algorithms, that should be suitable for\r\nthe majority of use cases.\r\n```",
              "createdAt": "2025-05-22T06:06:14Z",
              "updatedAt": "2025-05-22T06:06:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdo3B",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:06:58Z",
          "updatedAt": "2025-05-22T06:06:58Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "nice ",
              "createdAt": "2025-05-22T06:06:58Z",
              "updatedAt": "2025-05-22T06:06:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdpZM",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:08:16Z",
          "updatedAt": "2025-05-22T06:08:17Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "'Yes but', in the literature there is just keygen, so idk if we want to add a word or two to like, make this more 'applied', or applicable just in this document, or something",
              "createdAt": "2025-05-22T06:08:16Z",
              "updatedAt": "2025-05-22T06:08:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdpsH",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:08:58Z",
          "updatedAt": "2025-05-22T06:08:58Z",
          "comments": [
            {
              "originalPosition": 190,
              "body": "```suggestion\r\nWe assume that the values produced and consumed by the above functions are all\r\nbyte strings, with fixed lengths per parameter set:\r\n```",
              "createdAt": "2025-05-22T06:08:58Z",
              "updatedAt": "2025-05-22T06:08:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdqB2",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:09:44Z",
          "updatedAt": "2025-05-22T06:09:44Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "True, but why mention it?",
              "createdAt": "2025-05-22T06:09:44Z",
              "updatedAt": "2025-05-22T06:09:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdqSP",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:10:17Z",
          "updatedAt": "2025-05-22T06:10:17Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "I really don't think we should do this, this is not a secure IND-CCA KEM (it doesn't match DH-KEM in HPKE, for example)",
              "createdAt": "2025-05-22T06:10:17Z",
              "updatedAt": "2025-05-22T06:10:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qkDOU",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "assuming future changes",
          "createdAt": "2025-05-22T14:56:01Z",
          "updatedAt": "2025-05-22T14:56:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6rOlnI",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-27T21:25:29Z",
          "updatedAt": "2025-05-27T21:25:29Z",
          "comments": [
            {
              "originalPosition": 190,
              "body": "I'm putting in a note for now, but I suspect we should make this optional and parallel to `EncapsDerand`.",
              "createdAt": "2025-05-27T21:25:29Z",
              "updatedAt": "2025-05-27T21:25:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rOmja",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-27T21:26:52Z",
          "updatedAt": "2025-05-27T21:26:53Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "In case people have already read HPKE and are looking at this.  I have added markup to make it an inset note / aside.  I'm not that committed to it; happy to delete it if people feel strongly.",
              "createdAt": "2025-05-27T21:26:52Z",
              "updatedAt": "2025-05-27T21:26:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 19,
      "id": "PR_kwDOMmhxws6Wgb0y",
      "title": "Hybrid constructions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/19",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR builds on #18 by actually defining the hybrid KEM constructions.  First we define the overall KEM structure, being generic over combiner functions, and then we define the combiners.\r\n\r\nI have focused on functional definitions here, with security notions and arguments punted to the Security Considerations.  I added an outline of what I think we need the Security Considerations to look like at the end, mainly so that I could have targets for the cross-references above.",
      "createdAt": "2025-05-16T18:17:04Z",
      "updatedAt": "2025-05-29T22:02:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "9e85013a9da7226a2e54c098de0ab5043034a158",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "hybrid-constructions",
      "headRefOid": "dcced8928ede11206cddb706f87e15b95b947005",
      "closedAt": "2025-05-29T22:02:53Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed on authors call, will remove the \"OnlySharedSecrets\" option (nobody's asking for it; arguably not sound) and reframe the OnlyTraditional option in terms of a T group.",
          "createdAt": "2025-05-22T14:58:43Z",
          "updatedAt": "2025-05-22T14:58:43Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Subsumed in #22 ",
          "createdAt": "2025-05-29T22:02:50Z",
          "updatedAt": "2025-05-29T22:02:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6qkD1h",
          "commit": {
            "abbreviatedOid": "86bea7e"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "assuming future changes",
          "createdAt": "2025-05-22T14:56:43Z",
          "updatedAt": "2025-05-22T14:56:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOMmhxws6X2tuT",
      "title": "Post #18 edits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/21",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* Addresses a bunch of editorial comments from @dconnolly.  \r\n* Removes the OnlySharedSecrets combiner, as discussed on the authors call",
      "createdAt": "2025-05-27T21:30:37Z",
      "updatedAt": "2025-05-29T22:03:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "9e85013a9da7226a2e54c098de0ab5043034a158",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "post-18",
      "headRefOid": "1138e27278bb141638319d458ea782badc538f59",
      "closedAt": "2025-05-29T22:03:04Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Subsumed in #22 ",
          "createdAt": "2025-05-29T22:03:04Z",
          "updatedAt": "2025-05-29T22:03:04Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 22,
      "id": "PR_kwDOMmhxws6YCzWa",
      "title": "Reframe in terms of groups ++",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/22",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR rewrites the hybrid KEMs in terms of nominal groups as appropriate.\r\n\r\n* Adds a \"nominal group\" API much like the KEM API.\r\n* The HashEverything hybrid is defined in terms of KEM+KEM\r\n    * The PreHashKeys hybrid is defined as an optimization of HashEverything\r\n    * We define a way of instantiating the above with a group instead of a KEM\r\n* The HashTraditionalOnly hybrid is define in terms of Group+KEM (as in [BCD+24])\r\n",
      "createdAt": "2025-05-29T00:34:54Z",
      "updatedAt": "2025-06-06T15:44:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "9e85013a9da7226a2e54c098de0ab5043034a158",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "kem-vs-curve",
      "headRefOid": "85abd303cacb9d72fc4b6204a080efb43f353c81",
      "closedAt": "2025-06-06T15:44:08Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation is this branch all the commits from PR #18 and #21? ",
          "createdAt": "2025-05-29T15:23:53Z",
          "updatedAt": "2025-05-29T15:23:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@dconnolly - Yes, i've just been building ahead linearly.",
          "createdAt": "2025-05-29T15:24:54Z",
          "updatedAt": "2025-05-29T15:24:54Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "All these changes have been included in #31, closing",
          "createdAt": "2025-06-06T15:44:08Z",
          "updatedAt": "2025-06-06T15:44:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6rkRSP",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T13:55:19Z",
          "updatedAt": "2025-05-29T13:55:19Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Recommend removal of HNDL attacks. Motivation for PQC is not specific to that, but due to quantum threats.",
              "createdAt": "2025-05-29T13:55:19Z",
              "updatedAt": "2025-05-29T13:55:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rkaq8",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T14:07:54Z",
          "updatedAt": "2025-05-29T14:07:54Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "The idea of mentioning HNDL is just to explain why the focus on KEMs vs. Authentication.  But I don't feel super strongly.",
              "createdAt": "2025-05-29T14:07:54Z",
              "updatedAt": "2025-05-29T14:07:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rkmIx",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T14:23:43Z",
          "updatedAt": "2025-05-29T14:23:44Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Well, the whole draft is about KEMs only, so...",
              "createdAt": "2025-05-29T14:23:43Z",
              "updatedAt": "2025-05-29T14:23:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rlSL4",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T15:21:58Z",
          "updatedAt": "2025-05-29T15:21:58Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "And KEMs are not only used for key establishment, sometimes they are used for auth too",
              "createdAt": "2025-05-29T15:21:58Z",
              "updatedAt": "2025-05-29T15:21:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rlTZ0",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T15:23:42Z",
          "updatedAt": "2025-05-29T15:23:43Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Fine, fine, we can delete it :)",
              "createdAt": "2025-05-29T15:23:43Z",
              "updatedAt": "2025-05-29T15:23:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rl8nU",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T16:14:03Z",
          "updatedAt": "2025-05-29T16:14:03Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "```suggestion\r\n# Hybrid KEM Generic Constructions {#generic-constructions}\r\n```",
              "createdAt": "2025-05-29T16:14:03Z",
              "updatedAt": "2025-05-29T16:14:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rl886",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T16:14:37Z",
          "updatedAt": "2025-05-29T16:14:37Z",
          "comments": [
            {
              "originalPosition": 265,
              "body": "```suggestion\r\nIn this section, we define three generic constructions for hybrid KEMs:\r\n```",
              "createdAt": "2025-05-29T16:14:37Z",
              "updatedAt": "2025-05-29T16:14:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rl9km",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T16:15:39Z",
          "updatedAt": "2025-05-29T16:15:39Z",
          "comments": [
            {
              "originalPosition": 279,
              "body": "```suggestion\r\n* HashEverything - A generic construction that is suitable for use with any choice\r\n  of traditional and PQ KEMs, with minimal security assumptions on the\r\n  constituent KEMs\r\n* PreHashedKeys - A performance optimization of HashEverything for the case\r\n  where encapsulation keys are large and frequently reused\r\n* HashTraditionalOnly - An optimized generic construction for the case where the traditional\r\n  component is a nominal group and the PQ component has strong binding\r\n  properties\r\n```",
              "createdAt": "2025-05-29T16:15:39Z",
              "updatedAt": "2025-05-29T16:15:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmAVm",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T16:20:17Z",
          "updatedAt": "2025-05-29T16:20:17Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "Let's duplicate Encaps and Decaps from HashEverything here and just change/add these lines",
              "createdAt": "2025-05-29T16:20:17Z",
              "updatedAt": "2025-05-29T17:57:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmLUB",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T16:33:23Z",
          "updatedAt": "2025-05-29T16:33:23Z",
          "comments": [
            {
              "originalPosition": 496,
              "body": "Let's remove this for now, tracked with #23 ",
              "createdAt": "2025-05-29T16:33:23Z",
              "updatedAt": "2025-05-29T16:33:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmpfv",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:17:09Z",
          "updatedAt": "2025-05-29T17:17:09Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "```suggestion\r\nPost-quantum (PQ) cryptographic schemes offer new constructions based on problems conjectured as resistant to attacks possible on a quantum computer. Key Encapsulation Mechanisms\r\n```",
              "createdAt": "2025-05-29T17:17:09Z",
              "updatedAt": "2025-05-29T17:17:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmp0U",
          "commit": {
            "abbreviatedOid": "c8874d0"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:17:43Z",
          "updatedAt": "2025-05-29T17:17:44Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "```suggestion\r\nlieu of traditional, quantum-vulnerable variants such as finite field or\r\nelliptic curve Diffie-Hellman (DH) based protocols.\r\n```",
              "createdAt": "2025-05-29T17:17:43Z",
              "updatedAt": "2025-05-29T17:17:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmrwH",
          "commit": {
            "abbreviatedOid": "d64370f"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:20:11Z",
          "updatedAt": "2025-05-29T17:20:11Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\nPost-quantum (PQ) cryptographic schemes offer new constructions based on problems\r\nconjectured as resistant to attacks possible on a quantum computer. Key Encapsulation\r\nMechanisms (KEMs), are a standardized class of cryptographic scheme that can be used\r\nto build protocols in\r\n```",
              "createdAt": "2025-05-29T17:20:11Z",
              "updatedAt": "2025-05-29T17:20:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmsgF",
          "commit": {
            "abbreviatedOid": "a6ee732"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:21:02Z",
          "updatedAt": "2025-05-29T17:21:03Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nPost-quantum (PQ) cryptographic schemes offer new constructions based on problems\r\nconjectured as resistant to attacks possible on a quantum computer. Key \r\nEncapsulation Mechanisms (KEMs), are a standardized class of cryptographic scheme\r\nthat can be used to build protocols in lieu of traditional, quantum-vulnerable\r\nvariants such as finite field or elliptic curve Diffie-Hellman (DH) based protocols.\r\n```",
              "createdAt": "2025-05-29T17:21:02Z",
              "updatedAt": "2025-05-29T17:21:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmtSu",
          "commit": {
            "abbreviatedOid": "c80503e"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:22:06Z",
          "updatedAt": "2025-05-29T17:22:06Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "```suggestion\r\nIn this document, we define generic constructions for hybrid KEMs based on combining a\r\n```",
              "createdAt": "2025-05-29T17:22:06Z",
              "updatedAt": "2025-05-29T17:22:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmulX",
          "commit": {
            "abbreviatedOid": "7eca073"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:23:25Z",
          "updatedAt": "2025-05-29T17:23:25Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "So this is tricky, it's being used to split secret key material and public key material, and being leaky on one is acceptable and being leaky on the other is not...",
              "createdAt": "2025-05-29T17:23:25Z",
              "updatedAt": "2025-05-29T17:23:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmvel",
          "commit": {
            "abbreviatedOid": "407a07b"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:24:30Z",
          "updatedAt": "2025-05-29T17:24:30Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "```suggestion\r\n  input a seed `seed` and generates a public encapsulation key `ek` and a secret\r\n```",
              "createdAt": "2025-05-29T17:24:30Z",
              "updatedAt": "2025-05-29T17:24:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmxKK",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:26:43Z",
          "updatedAt": "2025-05-29T17:26:43Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "All mention of 'KDF' and 'XOF' has been removed and 'hash functions' has been added, these things are not the same",
              "createdAt": "2025-05-29T17:26:43Z",
              "updatedAt": "2025-05-29T17:26:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmxhB",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "blocked on KDF, XOF ",
          "createdAt": "2025-05-29T17:27:08Z",
          "updatedAt": "2025-05-29T17:27:08Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6rm0Wf",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:31:01Z",
          "updatedAt": "2025-05-29T17:31:01Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "These things are not isomorphic and I don't think we should talk about them this way, I think we should bring back the language about KDFs and XOFs @pag-crypto @br-hale @bwesterb \r\n",
              "createdAt": "2025-05-29T17:31:01Z",
              "updatedAt": "2025-05-29T17:37:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rm2Sl",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:33:47Z",
          "updatedAt": "2025-05-29T17:33:48Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "```suggestion\r\n- `split(N1, N2, x)`: Split a byte string `x` of length `N1 + N2` into its first\r\n  `N1` bytes and its last `N2` bytes.  This function is the inverse of\r\n  `concat(x1, x2)` when `x1` is `N1` bytes long and `x2` is `N2` bytes long. It\r\n  is an error to call this function with a byte string that does not have length\r\n  `N1 + N2`. Since this function operates over secret data it MUST be constant-time.\r\n```",
              "createdAt": "2025-05-29T17:33:47Z",
              "updatedAt": "2025-05-29T17:33:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rm3-k",
          "commit": {
            "abbreviatedOid": "ac43444"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:36:40Z",
          "updatedAt": "2025-05-29T17:36:41Z",
          "comments": [
            {
              "originalPosition": 681,
              "body": "Removed for now but tracked in https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/24\r\n\r\n```suggestion\r\n```",
              "createdAt": "2025-05-29T17:36:40Z",
              "updatedAt": "2025-05-29T17:36:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rm62L",
          "commit": {
            "abbreviatedOid": "43f5e03"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:41:35Z",
          "updatedAt": "2025-05-29T17:41:35Z",
          "comments": [
            {
              "originalPosition": 375,
              "body": "I might not even define 'split()` in this document, it may be generic enough to decompose into component dk's with an explicit `Decompose()` or something, leave the byte-wise notions to -concrete",
              "createdAt": "2025-05-29T17:41:35Z",
              "updatedAt": "2025-05-29T18:18:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rm9Wb",
          "commit": {
            "abbreviatedOid": "43f5e03"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:45:49Z",
          "updatedAt": "2025-05-29T17:45:49Z",
          "comments": [
            {
              "originalPosition": 283,
              "body": "Found it; this is not just a hash function, it has to be a secure KDF (it can't be SHA1 or SHA-256, it should be something like SHA3 or HKDF-SHA256)",
              "createdAt": "2025-05-29T17:45:49Z",
              "updatedAt": "2025-05-29T17:45:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnHxg",
          "commit": {
            "abbreviatedOid": "43f5e03"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:01:02Z",
          "updatedAt": "2025-05-29T18:01:02Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "```suggestion\r\noracle.\r\n\r\nFor QSF, the KDF function must be a secure random oracle in the random oracle\r\nmodel and quantum random oracle model and as a secure pseudorandom\r\nfunction (PRF) in the standard model.\r\n```",
              "createdAt": "2025-05-29T18:01:02Z",
              "updatedAt": "2025-05-29T18:01:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnPN3",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:12:30Z",
          "updatedAt": "2025-05-29T18:12:30Z",
          "comments": [
            {
              "originalPosition": 554,
              "body": "I don't love this name (I don't quite understand what it's trying to say) and think `QSF` is as good a name as any, short, and unless you already know it's associated with X-Wing, non-controversial?",
              "createdAt": "2025-05-29T18:12:30Z",
              "updatedAt": "2025-05-29T18:12:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnPnN",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:13:14Z",
          "updatedAt": "2025-05-29T18:13:14Z",
          "comments": [
            {
              "originalPosition": 498,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-05-29T18:13:14Z",
              "updatedAt": "2025-05-29T18:13:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnPuw",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:13:28Z",
          "updatedAt": "2025-05-29T18:13:28Z",
          "comments": [
            {
              "originalPosition": 504,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-05-29T18:13:28Z",
              "updatedAt": "2025-05-29T18:13:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnP04",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:13:38Z",
          "updatedAt": "2025-05-29T18:13:39Z",
          "comments": [
            {
              "originalPosition": 510,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-05-29T18:13:39Z",
              "updatedAt": "2025-05-29T18:13:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnP_9",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:13:57Z",
          "updatedAt": "2025-05-29T18:13:58Z",
          "comments": [
            {
              "originalPosition": 542,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-05-29T18:13:57Z",
              "updatedAt": "2025-05-29T18:13:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnQKi",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:14:16Z",
          "updatedAt": "2025-05-29T18:14:16Z",
          "comments": [
            {
              "originalPosition": 543,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-05-29T18:14:16Z",
              "updatedAt": "2025-05-29T18:14:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnQWW",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:14:37Z",
          "updatedAt": "2025-05-29T18:14:37Z",
          "comments": [
            {
              "originalPosition": 548,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-05-29T18:14:37Z",
              "updatedAt": "2025-05-29T18:14:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnTkz",
          "commit": {
            "abbreviatedOid": "89fd845"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:20:12Z",
          "updatedAt": "2025-05-29T18:20:12Z",
          "comments": [
            {
              "originalPosition": 292,
              "body": "I really think we should explicitly call these what they are, XOF's and KDF's, 'hash function' blends them together in a way that is not correct and can lead to security issues",
              "createdAt": "2025-05-29T18:20:12Z",
              "updatedAt": "2025-05-29T18:20:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnXG5",
          "commit": {
            "abbreviatedOid": "89fd845"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:26:09Z",
          "updatedAt": "2025-05-29T18:26:09Z",
          "comments": [
            {
              "originalPosition": 453,
              "body": "```suggestion\r\n## PreHash {#prehash}\r\n```",
              "createdAt": "2025-05-29T18:26:09Z",
              "updatedAt": "2025-05-29T18:26:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnX1E",
          "commit": {
            "abbreviatedOid": "09a30e9"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:27:06Z",
          "updatedAt": "2025-05-29T18:27:07Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "```suggestion\r\nGiven the novelty of these PQ schemes however, there is some concern that PQ\r\nalgorithms currently believed to be secure will be broken.  Hybrid\r\nconstructions that combine both PQ and traditional algorithms can help moderate\r\nthis risk while still providing security against quantum attack.  If construted\r\n```",
              "createdAt": "2025-05-29T18:27:07Z",
              "updatedAt": "2025-05-29T18:27:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnZZk",
          "commit": {
            "abbreviatedOid": "487c1fc"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:29:15Z",
          "updatedAt": "2025-05-29T18:29:16Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "```suggestion\r\n- Key Encapsulation Mechanisms {{kems}}\r\n- Nominal Groups {{group}}\r\n- Key-derivation Functions {{kdfs}}\r\n- Extendable-output Functions {{xofs}}\r\n- Hash Functions {{hash}}\r\n```",
              "createdAt": "2025-05-29T18:29:15Z",
              "updatedAt": "2025-05-29T18:29:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rng1R",
          "commit": {
            "abbreviatedOid": "487c1fc"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:39:41Z",
          "updatedAt": "2025-05-29T18:39:41Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "```suggestion\r\n> \"decapsulation\" as opposed to \"public\" and \"secret\".\r\n\r\n## Key Derivation Function `KDF` {#kdf}\r\n\r\nA secure key derivation function (KDF) that is modeled as a secure\r\npseudorandom function (PRF) in the standard model {{GHP2018}} and\r\nindependent random oracle in the random oracle model (ROM) and quantum\r\nrandom oracle model. Generally a strong KDF will have a proof of\r\nindifferentiability from a random oracle.\r\n\r\nExamples of secure KDFs in practice include HKDF-SHA256 and SHA3.\r\nSHA-256 is not generally considered a strong KDF except under\r\nconstrained circumstances {{CDMP2005}}.\r\n\r\n## Extendable-output function `XOF` {#xof}\r\n\r\nExtendable-output function (XOF). A function on bit strings in which the\r\noutput can be extended to any desired length. Ought to satisfy the following\r\nproperties as long as the specified output length is sufficiently long to\r\nprevent trivial attacks:\r\n\r\n1. (One-way) It is computationally infeasible to find any input that maps to\r\n   any new pre-specified output.\r\n\r\n2. (Collision-resistant) It is computationally infeasible to find any two\r\n   distinct inputs that map to the same output.\r\n\r\nMUST provide the bit-security required to source input randomness for PQ/T\r\ncomponents from a seed that is expanded to a output length, of which a subset\r\nis passed to the component key generation algorithms.\r\n\r\n## Hash functions {#hash}\r\n```",
              "createdAt": "2025-05-29T18:39:41Z",
              "updatedAt": "2025-05-29T18:39:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnhBx",
          "commit": {
            "abbreviatedOid": "487c1fc"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:40:02Z",
          "updatedAt": "2025-05-29T18:40:02Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "@br-hale @bwesterb thoughts?",
              "createdAt": "2025-05-29T18:40:02Z",
              "updatedAt": "2025-05-29T18:40:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnknM",
          "commit": {
            "abbreviatedOid": "487c1fc"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:45:33Z",
          "updatedAt": "2025-05-29T18:45:33Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "I would concure that this is 'encapulation' and 'decapsulation' (vs enc / dec). Those are the functions. For the key, a \"secret encapsulation key\" and \"public decapsultation key\" seem appropriate.",
              "createdAt": "2025-05-29T18:45:33Z",
              "updatedAt": "2025-05-29T18:45:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnm1y",
          "commit": {
            "abbreviatedOid": "89fd845"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:48:58Z",
          "updatedAt": "2025-05-29T18:48:59Z",
          "comments": [
            {
              "originalPosition": 292,
              "body": "Concur",
              "createdAt": "2025-05-29T18:48:58Z",
              "updatedAt": "2025-05-29T18:48:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnpJT",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:52:37Z",
          "updatedAt": "2025-05-29T18:52:38Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "Concur",
              "createdAt": "2025-05-29T18:52:38Z",
              "updatedAt": "2025-05-29T18:52:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnr1Q",
          "commit": {
            "abbreviatedOid": "89fd845"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:57:14Z",
          "updatedAt": "2025-05-29T18:57:14Z",
          "comments": [
            {
              "originalPosition": 292,
              "body": "I've added some short sections on what they are and will take a stab at utilizing the them in the generic schemes' pseudocode next",
              "createdAt": "2025-05-29T18:57:14Z",
              "updatedAt": "2025-05-29T18:57:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnsLg",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:57:53Z",
          "updatedAt": "2025-05-29T18:57:54Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Yes, there is a very significant difference for security. The descriptions (generic and concrete) need to match the generic building blocks used in the analyses. \r\n\r\nALSO, we need to look at and discuss if the write concrete choices are used for the end goal (e.g., if something is using SHA256, SHA384, or SHA3). This may or may not be the same as used in the analysis - which means that if we change a building block from what is used in the analysis we need to take a closer look that the right properties are statisfied. \r\n\r\nI am also concerned the properties stated (e.g., collision resistance and second preimage resis) may not align to the properties needed for security, i.e., per what analysis has shown. We need to cite the write attributes.  ",
              "createdAt": "2025-05-29T18:57:54Z",
              "updatedAt": "2025-05-29T18:57:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rn0YG",
          "commit": {
            "abbreviatedOid": "869f45b"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T19:12:42Z",
          "updatedAt": "2025-05-29T19:12:42Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Agreed; 'KitchenSink'/'HashEverything' seems closest to GHP2018, QSF to QSF ofc, which both require the KDF to be a 'good' random oracle (and QSF in the standard model requires a 'secure' PRF) which seems to basically mean 'indiff. from an RO' now, even if it's assumed/understated? Chempat doesn't have a proof but maybe we can deduce requirements from GHP2018?",
              "createdAt": "2025-05-29T19:12:42Z",
              "updatedAt": "2025-05-29T19:12:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ro5H_",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T21:11:00Z",
          "updatedAt": "2025-05-29T21:11:01Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "I think the proposed change is an improvement. QROM is clearly the strongest requirement on a hash function, and for the PQ KEMs I checked, they all require one anyway.\r\n\r\nLet me entertain a brief tangent. If I could go back a decade or so, I'd propose the CFRG to write a document with the title \"What is a good hash?\". It'd explain ROM, PRF, and all subtle academic differences in security properties. But in the end it'd simply say: length-prefixed-SHA2 & SHA-3 good; MD5, SHA-1 bad.",
              "createdAt": "2025-05-29T21:11:01Z",
              "updatedAt": "2025-05-29T21:11:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rpAiY",
          "commit": {
            "abbreviatedOid": "869f45b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T21:26:41Z",
          "updatedAt": "2025-05-29T21:26:42Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "I think it will actually be cleanest just to delete this text for now, and punt on it like we have for all of the other security descriptions.  I will also add some text at the top of this section clarifying that we're just defining functional definitions here, and the security requirements are below.",
              "createdAt": "2025-05-29T21:26:41Z",
              "updatedAt": "2025-05-29T21:26:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rpB1q",
          "commit": {
            "abbreviatedOid": "869f45b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T21:29:51Z",
          "updatedAt": "2025-05-29T21:33:53Z",
          "comments": [
            {
              "originalPosition": 292,
              "body": "Disagree.  (1) XOF brings a lot more baggage than is necessary, (2) definitions of KDF in the literature are all over the place, and (3) as Bas points out, everyone uses RO for this anyway.\r\n\r\nI agree that the notion of \"hash function\" here is stronger than the usual definition (requiring RO instead of just collision/preimage resistance).  So maybe we need a different word.",
              "createdAt": "2025-05-29T21:29:51Z",
              "updatedAt": "2025-05-29T21:33:53Z"
            },
            {
              "originalPosition": 375,
              "body": "FWIW, we're using it for all of the concatenated things: `dk`, `ek`, and `ct`.\r\n\r\nI agree that the compound serialization doesn't matter.  But the constituent values need to be fixed-length byte strings since they're going into a hash function and you want `concat()` to be unambiguous without length prefixing.  So there's no need for anything more complicated.\r\n\r\nI'm going to leave this for now, and maybe file an issue.",
              "createdAt": "2025-05-29T21:33:45Z",
              "updatedAt": "2025-05-29T21:33:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rpEzD",
          "commit": {
            "abbreviatedOid": "869f45b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T21:36:56Z",
          "updatedAt": "2025-05-29T21:36:56Z",
          "comments": [
            {
              "originalPosition": 554,
              "body": "I don't love it either, but trying to separate from earlier names to be more neutral / give this document more coherence.\r\n\r\nAnother thing to file an issue on. Maybe you could backronym it to something?  ",
              "createdAt": "2025-05-29T21:36:56Z",
              "updatedAt": "2025-05-29T21:36:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rpHsT",
          "commit": {
            "abbreviatedOid": "869f45b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T21:42:43Z",
          "updatedAt": "2025-05-29T21:42:57Z",
          "comments": [
            {
              "originalPosition": 554,
              "body": "@BTW, what it's trying to say is that the only metadata you hash in is on the T side.  \ud83e\udd37 ",
              "createdAt": "2025-05-29T21:42:43Z",
              "updatedAt": "2025-05-29T21:42:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rpRQ6",
          "commit": {
            "abbreviatedOid": "869f45b"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T22:08:26Z",
          "updatedAt": "2025-05-29T22:21:02Z",
          "comments": [
            {
              "originalPosition": 283,
              "body": "@dconnolly citation?",
              "createdAt": "2025-05-29T22:08:26Z",
              "updatedAt": "2025-05-29T22:21:02Z"
            },
            {
              "originalPosition": 375,
              "body": "+1 to @bifurcation -- since these are being thrown into the hash, parsing them at this layer seems necessary.",
              "createdAt": "2025-05-29T22:11:45Z",
              "updatedAt": "2025-05-29T22:21:02Z"
            },
            {
              "originalPosition": 493,
              "body": "Agreed.",
              "createdAt": "2025-05-29T22:20:26Z",
              "updatedAt": "2025-05-29T22:21:02Z"
            },
            {
              "originalPosition": 554,
              "body": "Let's leave it as-is and bike shed the name later. I think it's clear enough for now.",
              "createdAt": "2025-05-29T22:20:49Z",
              "updatedAt": "2025-05-29T22:21:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6srheq",
          "commit": {
            "abbreviatedOid": "c4d01b2"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T14:53:39Z",
          "updatedAt": "2025-06-04T14:53:40Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "```suggestion\r\nThe remainder of this document is structured as follows: first, in\r\n{{cryptographic-deps}} and {{schemes}}, we define the abstractions on which the\r\nschemes are built, and then the schemes themselves.  Then, in {{security}}, we\r\n```",
              "createdAt": "2025-06-04T14:53:39Z",
              "updatedAt": "2025-06-04T14:53:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ssS1p",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T15:53:37Z",
          "updatedAt": "2025-06-04T15:53:37Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "<3",
              "createdAt": "2025-06-04T15:53:37Z",
              "updatedAt": "2025-06-04T15:53:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ssdcX",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T16:08:12Z",
          "updatedAt": "2025-06-04T16:08:12Z",
          "comments": [
            {
              "originalPosition": 266,
              "body": "Suggestions:\r\n- `All` - except it's not really all as the lengths aren't encoded necessarily in the preimage but\r\n- `Curich` - this is kinda stupid but 'Chempat' is the name of a star wars fictional manufacturer, 'Curich' is another star wars fictional manufacturer that's similar to Chempat, but not, bc the generic scheme written here is similar to the Chempat design, but not \r\n- `QSF` - short, established, at least less misleading than 'HashTraditionalOnly`\r\n\r\nI don't think including 'hash' in the names is helping",
              "createdAt": "2025-06-04T16:08:12Z",
              "updatedAt": "2025-06-04T16:09:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ssfSc",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T16:10:34Z",
          "updatedAt": "2025-06-04T16:10:34Z",
          "comments": [
            {
              "originalPosition": 375,
              "body": "fair enough",
              "createdAt": "2025-06-04T16:10:34Z",
              "updatedAt": "2025-06-04T16:10:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ssf0a",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T16:11:18Z",
          "updatedAt": "2025-06-04T16:11:18Z",
          "comments": [
            {
              "originalPosition": 355,
              "body": "Not defined",
              "createdAt": "2025-06-04T16:11:18Z",
              "updatedAt": "2025-06-04T16:11:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ssgEw",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T16:11:37Z",
          "updatedAt": "2025-06-04T16:11:37Z",
          "comments": [
            {
              "originalPosition": 378,
              "body": "Not defined",
              "createdAt": "2025-06-04T16:11:37Z",
              "updatedAt": "2025-06-04T16:11:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ssidx",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T16:14:42Z",
          "updatedAt": "2025-06-04T16:14:42Z",
          "comments": [
            {
              "originalPosition": 554,
              "body": "Yes leaving it the existing document names as-is seems fine (QSF)",
              "createdAt": "2025-06-04T16:14:42Z",
              "updatedAt": "2025-06-04T16:14:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sss9Z",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T16:31:08Z",
          "updatedAt": "2025-06-04T16:31:09Z",
          "comments": [
            {
              "originalPosition": 539,
              "body": "QSF (or rather the X-Wing style of QSF) specifically uses an XOF, skewing away seems fraught because of inputs and outputs sizes re: security levels, skewing away from proven schemes and established reviewed designs seems fraught",
              "createdAt": "2025-06-04T16:31:09Z",
              "updatedAt": "2025-06-04T16:32:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ss2Mj",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T16:46:00Z",
          "updatedAt": "2025-06-04T16:46:00Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "```suggestion\r\n- Key Derivation Functions ({{kdfs}})\r\n- Extendable-Output Functions ({{xofs}})\r\n```",
              "createdAt": "2025-06-04T16:46:00Z",
              "updatedAt": "2025-06-04T16:46:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ss6gc",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T16:51:52Z",
          "updatedAt": "2025-06-04T16:51:52Z",
          "comments": [
            {
              "originalPosition": 254,
              "body": "We must include XOFs because of X-Wing at the least but also because different KEMs/ groups may need different input seed sizes and pure hash functions are not well suited for this; HKDF allows this via Expand(..., length) but X-Wing does not use HKDF\r\n\r\n```suggestion\r\n<!-- We must include XOFs because of X-Wing at the least but also because different KEMs/ groups may need different input seed sizes out the back of the function, and pure hash functions are not well suited for this; HKDF allows this via Expand(..., length) but X-Wing does not use HKDF -->\r\n\r\n## `XOF` {#xofs}\r\n\r\nExtendable-output function (XOF). A function on bit strings in which the\r\noutput can be extended to any desired length. Ought to satisfy the following\r\nproperties as long as the specified output length is sufficiently long to\r\nprevent trivial attacks:\r\n\r\n1. (One-way) It is computationally infeasible to find any input that maps to\r\n   any new pre-specified output.\r\n\r\n2. (Collision-resistant) It is computationally infeasible to find any two\r\n   distinct inputs that map to the same output.\r\n\r\nMUST provide the bit-security required to source input randomness for PQ/T\r\ncomponents from a seed that is expanded to a output length, of which a subset\r\nis passed to the component key generation algorithms.\r\n\r\n# Hybrid KEM Schemes {#schemes}\r\n```",
              "createdAt": "2025-06-04T16:51:52Z",
              "updatedAt": "2025-06-04T16:58:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ss8Jl",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T16:54:28Z",
          "updatedAt": "2025-06-04T16:54:29Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "`.Derive()` is never used, shall we go back to `KDF(..)` ?",
              "createdAt": "2025-06-04T16:54:29Z",
              "updatedAt": "2025-06-04T16:54:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stCBy",
          "commit": {
            "abbreviatedOid": "3df988c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:03:50Z",
          "updatedAt": "2025-06-04T17:03:51Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "```suggestion\r\nWhile KDFs in the literature can typically consume and produce byte strings of\r\narbitrary length, the KDFs used in this document have a simpler form, with a fixed\r\noutput lengths:\r\n\r\n- `Nin` - The length in bytes of an input to this KDF.\r\n- `Nout` - The length in bytes of an output from this KDF.\r\n- `KDF(input) -> output`: Produce a byte string of length `Nout` from an input\r\n  byte string.\r\n\r\nThe fixed sizes are for both security and simplicity. \r\n\r\nFor instances of the `Extract()`/`Expand()` KDF paradigm such as `HKDF`, we fix the salt s and sizes to fit this form.\r\n```",
              "createdAt": "2025-06-04T17:03:50Z",
              "updatedAt": "2025-06-04T17:03:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stCyY",
          "commit": {
            "abbreviatedOid": "06b4ae4"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:05:03Z",
          "updatedAt": "2025-06-04T17:05:04Z",
          "comments": [
            {
              "originalPosition": 213,
              "body": "Do we need to even say this?",
              "createdAt": "2025-06-04T17:05:03Z",
              "updatedAt": "2025-06-04T17:05:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stP9Y",
          "commit": {
            "abbreviatedOid": "689f696"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:27:01Z",
          "updatedAt": "2025-06-04T17:27:02Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "This is incorrect, nominal groups do not align with finite fields especially regarding Diffie-Hellman - finite fields have other algebraic structure that ofc make them weaker to instantiate DH over than groups.\r\n\r\n```suggestion\r\n<!-- Yes we need to be able to model the group as a nominal group to make the proofs work, but we have proofs for the NIST curves and the Montgomery curves, I wouldn't be surprised if a nice prime order group like Ristretto or DoubleOdd could also be shown to be a nominal group; thoughts on putting the 'nominal' requirements in the bit at the bottom of the doc, and just leave this as 'Groups'? --> \r\n\r\nNominal groups are an abstract model of elliptic curve groups, over which we\r\ninstantiate Diffie-Hellman key agreement {{ABH+21}}.  A nominal group comprises\r\na set `G` together with a distinguished basis element `g`, an \"exponentiation\"\r\nmap, and some auxiliary functions:\r\n```",
              "createdAt": "2025-06-04T17:27:01Z",
              "updatedAt": "2025-06-04T17:29:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stSgS",
          "commit": {
            "abbreviatedOid": "877df2d"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:30:30Z",
          "updatedAt": "2025-06-04T17:30:31Z",
          "comments": [
            {
              "originalPosition": 190,
              "body": "```suggestion\r\n<!-- Yes we need to be able to model the group as a nominal group to make the\r\nproofs work, but we have proofs for the NIST curves and the Montgomery curves,\r\nI wouldn't be surprised if a nice prime order group like Ristretto or DoubleOdd\r\ncould also be shown to be a nominal group; thoughts on putting the 'nominal'\r\nrequirements in the security bits at the bottom of the doc, and just leave this as\r\n'Groups'? --> \r\n\r\nNominal groups are an abstract model of elliptic curve groups, over which we\r\ninstantiate Diffie-Hellman key agreement {{ABH+21}}.  A nominal group comprises\r\na set `G` together with a distinguished basis element `g`, an \"exponentiation\"\r\nmap, and some auxiliary functions:\r\n```",
              "createdAt": "2025-06-04T17:30:30Z",
              "updatedAt": "2025-06-04T17:30:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stTrg",
          "commit": {
            "abbreviatedOid": "c3bc748"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:32:02Z",
          "updatedAt": "2025-06-04T17:32:03Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "```suggestion\r\nA Key Derivation Function (KDF) is a function that a function that produces\r\nkeying material based on an input secret and other information.\r\n\r\nWhile KDFs in the literature can typically consume and produce byte strings of\r\narbitrary length, the KDFs used in this document have a simpler form, with a fixed\r\noutput lengths:\r\n\r\n- `Nin` - The length in bytes of an input to this KDF.\r\n- `Nout` - The length in bytes of an output from this KDF.\r\n- `KDF(input) -> output`: Produce a byte string of length `Nout` from an input\r\n  byte string.\r\n\r\nThe fixed sizes are for both security and simplicity. \r\n\r\nFor instances of the `Extract()`/`Expand()` KDF paradigm such as `HKDF`, we fix\r\nthe salt and sizes to fit this form.\r\n\r\nThe security requirements for KDFs used with the schemes in this document are\r\nlaid out in {{security-requirements}}.\r\n\r\n<!-- We must include XOFs because of X-Wing at the least but also because\r\ndifferent KEMs/ groups may need different input seed sizes out the back of\r\nthe function, and pure hash functions are not well suited for this; HKDF\r\nallows this via Expand(..., length) but X-Wing does not use HKDF -->\r\n```",
              "createdAt": "2025-06-04T17:32:03Z",
              "updatedAt": "2025-06-04T17:32:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stTxx",
          "commit": {
            "abbreviatedOid": "c3bc748"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:32:13Z",
          "updatedAt": "2025-06-04T17:32:14Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "Line wrap",
              "createdAt": "2025-06-04T17:32:14Z",
              "updatedAt": "2025-06-04T17:32:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stUsR",
          "commit": {
            "abbreviatedOid": "503cf12"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:33:29Z",
          "updatedAt": "2025-06-04T17:33:29Z",
          "comments": [
            {
              "originalPosition": 283,
              "body": "```suggestion\r\nIn this section, we define several generic constructions for hybrid KEMs. These\r\nconstructions share a common overall structure, differing mainly in how they\r\ncompute the final shared secret and the security requirements of their components.\r\n```",
              "createdAt": "2025-06-04T17:33:29Z",
              "updatedAt": "2025-06-04T17:33:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stVe8",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:34:41Z",
          "updatedAt": "2025-06-04T17:34:41Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "```suggestion\r\n* `XOF`: An XOF producing byte strings of length `KEM_T.Nseed + KEM_PQ.Nseed`\r\n  (`XOF.Nout == KEM_T.Nseed + KEM_PQ.Nseed`)\r\n* `KDF`: A KDF producing byte strings of length `KEM_H.Nss` (`KDF.Nout\r\n  == KEM_H.Nss`)\r\n```",
              "createdAt": "2025-06-04T17:34:41Z",
              "updatedAt": "2025-06-04T17:34:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stW_J",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:36:37Z",
          "updatedAt": "2025-06-04T17:36:37Z",
          "comments": [
            {
              "originalPosition": 311,
              "body": "```suggestion\r\nThe KEMs, groups, KDFs, and XOFs MSUT meet the security requirements in {{#security-requirements}}.\r\n```",
              "createdAt": "2025-06-04T17:36:37Z",
              "updatedAt": "2025-06-04T17:36:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stXpP",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:37:24Z",
          "updatedAt": "2025-06-04T17:37:26Z",
          "comments": [
            {
              "originalPosition": 348,
              "body": "@bwesterb @br-hale @pag-crypto \r\n\r\nI feel like there's a little bit more to this than mix/max'ing but I'm not sure",
              "createdAt": "2025-06-04T17:37:24Z",
              "updatedAt": "2025-06-04T17:37:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stX2J",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:37:45Z",
          "updatedAt": "2025-06-04T17:37:45Z",
          "comments": [
            {
              "originalPosition": 365,
              "body": "```suggestion\r\n    seed_full = XOF(seed)\r\n```",
              "createdAt": "2025-06-04T17:37:45Z",
              "updatedAt": "2025-06-04T17:37:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stYHY",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:38:14Z",
          "updatedAt": "2025-06-04T17:38:14Z",
          "comments": [
            {
              "originalPosition": 388,
              "body": "```suggestion\r\n    ss_H = KDF(concat(ss_PQ, ss_T, ct_PQ, ct_T, ek_PQ, ek_T, label))\r\n```",
              "createdAt": "2025-06-04T17:38:14Z",
              "updatedAt": "2025-06-04T17:38:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stYXN",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:38:39Z",
          "updatedAt": "2025-06-04T17:38:39Z",
          "comments": [
            {
              "originalPosition": 401,
              "body": "```suggestion\r\n    ss_H = KDF(concat(ss_PQ, ss_T, ct_PQ, ct_T, ek_PQ, ek_T, label))\r\n```",
              "createdAt": "2025-06-04T17:38:39Z",
              "updatedAt": "2025-06-04T17:38:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stZTe",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:40:22Z",
          "updatedAt": "2025-06-04T17:40:23Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "can `split()` be `split(x, N1, N2)`? Why are the input byte to be split last?",
              "createdAt": "2025-06-04T17:40:22Z",
              "updatedAt": "2025-06-04T17:40:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6staUT",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:42:09Z",
          "updatedAt": "2025-06-04T17:42:10Z",
          "comments": [
            {
              "originalPosition": 492,
              "body": "`KeyHash` does not have to have the same requirements of a KDF, it probably only needs collision resistance (but I'm not sure because we don't have a proof! @pag-crypto )",
              "createdAt": "2025-06-04T17:42:10Z",
              "updatedAt": "2025-06-04T17:42:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6steoA",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:49:18Z",
          "updatedAt": "2025-06-04T17:49:19Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "```suggestion\r\nWe don't actually know the requirements of _this_ function, we don't have a proof or \r\nrequirements laid out; the only example from Chempat is SHA3-256.\r\n\r\n* `KeyHash`: A KDF producing byte strings of length `KEM_H.Nss` (`KeyHash.Nout\r\n  == KEM_H.Nss`)\r\n```",
              "createdAt": "2025-06-04T17:49:19Z",
              "updatedAt": "2025-06-04T17:49:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ste1Q",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:49:36Z",
          "updatedAt": "2025-06-04T17:49:37Z",
          "comments": [
            {
              "originalPosition": 510,
              "body": "```suggestion\r\n    ss_H = KDF(concat(ss_PQ, ss_T, ct_PQ, ct_T, ekh, label))\r\n```",
              "createdAt": "2025-06-04T17:49:37Z",
              "updatedAt": "2025-06-04T17:49:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ste9B",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:49:50Z",
          "updatedAt": "2025-06-04T17:49:50Z",
          "comments": [
            {
              "originalPosition": 536,
              "body": "```suggestion\r\n    ss_H = KDF(concat(ss_PQ, ss_T, ct_PQ, ct_T, ekh, label))\r\n```",
              "createdAt": "2025-06-04T17:49:50Z",
              "updatedAt": "2025-06-04T17:49:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stfLJ",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:50:14Z",
          "updatedAt": "2025-06-04T17:50:15Z",
          "comments": [
            {
              "originalPosition": 554,
              "body": "```suggestion\r\n* `XOF`: A XOF producing byte strings of length `Group_T.Nseed +\r\n  KEM_PQ.Nseed` (`Expand.Nout == Group_T.Nseed + KEM_PQ.Nseed`)\r\n```",
              "createdAt": "2025-06-04T17:50:14Z",
              "updatedAt": "2025-06-04T17:50:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stfar",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:50:39Z",
          "updatedAt": "2025-06-04T17:50:39Z",
          "comments": [
            {
              "originalPosition": 608,
              "body": "```suggestion\r\n    seed_full = XOF(seed)\r\n```",
              "createdAt": "2025-06-04T17:50:39Z",
              "updatedAt": "2025-06-04T17:50:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stfqU",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:51:05Z",
          "updatedAt": "2025-06-04T17:51:05Z",
          "comments": [
            {
              "originalPosition": 636,
              "body": "```suggestion\r\n    ss_H = KDF(concat(ss_PQ, ss_T, ct_T, ek_T, Label))\r\n```",
              "createdAt": "2025-06-04T17:51:05Z",
              "updatedAt": "2025-06-04T17:51:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stfxV",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:51:16Z",
          "updatedAt": "2025-06-04T17:51:16Z",
          "comments": [
            {
              "originalPosition": 650,
              "body": "```suggestion\r\n    ss_H = KDF(concat(ss_PQ, ss_T, ct_T, ek_T, Label))\r\n```",
              "createdAt": "2025-06-04T17:51:16Z",
              "updatedAt": "2025-06-04T17:51:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sudvy",
          "commit": {
            "abbreviatedOid": "09473a3"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:25:55Z",
          "updatedAt": "2025-06-04T19:25:55Z",
          "comments": [
            {
              "originalPosition": 726,
              "body": "```suggestion\r\n> TODO: We need to provide more thorough description, and verify that\r\n> these requirements align with the requirements of the security proofs in the\r\n> literature, especially {{GHP2018}} and {{XWING}}.\r\n\r\n### Security Requirements for KEMs\r\n\r\nComponent KEMs MUST be IND-CCA-secure {{GHP2018}} {{XWING}}.\r\n\r\nFor instances of QSF, the component KEM MUST also be ciphertext second\r\npreimage resistant (C2PRI) {{XWING}}: this allows the component KEM\r\nencapsulation key and ciphertext to be left out from the KDF input. \r\n\r\n### Security Requirements for Groups\r\n\r\nThe groups MUST be modelable as nominal groups in which the strong\r\nDiffie-Hellman problem holds {{ABH+21}} {{XWING}}.\r\n\r\nThe Montgomery curves Curve25519 and Curve448 have been shown to be\r\nmodelable as nominal groups in {{ABH+21}} as well as showing the \r\n`X25519()` and `X448()` functions respectively pertain to the nominal\r\ngroup `exp(X, y)` function, specifically clamping secret keys when\r\nthey are generated, instead of clamping secret keys together with\r\nexponentiation.\r\n\r\n<!-- The short Weierstrass NIST curves have also been shown to be\r\nmodelable as nominal groups but I can't find the reference --> \r\n\r\n### Security Requirements for KDFs\r\n\r\nKDFs MUST be secure pseudorandom functions (PRFs) when keyed with\r\nthe shared secret output from the post-quantum IND-CCA-secure\r\nKEM component algorithm in QSF {{XWING}} or any of the component\r\nIND-CCA-secure KEMs when used in KitchenSink {{GHP2018}} or\r\nPreHash.\r\n\r\nKDFs must be secure instances of random oracles in the ROM and\r\nQROM {{GHP2018}} {{XWING}}. Proofs of indifferentiability from\r\nrandom oracles {{MRH03 https://eprint.iacr.org/2003/161.pdf}}\r\ngive good confidence here, as any function proven indifferentiable\r\nfrom a random oracle is resistant against collision, first, and\r\nsecond preimage attacks {{need a good cite here}}. An indifferentiability\r\nbound guarantees security against specific attacks. Although\r\nindifferentiability does not capture all properties of a random\r\noracle {{RSS11 https://eprint.iacr.org/2011/339.pdf}}, indifferentiability\r\nstill remains the best way to rule out structural attacks.\r\n\r\nSponge-based constructions such as SHA-3 have been shown to be\r\nindifferentiable against classical {{BDP+08 https://www.iacr.org/archive/eurocrypt2008/49650180/49650180.pdf}}\r\nas well as quantum adversaries \r\n{{ACM+25 https://eprint.iacr.org/2025/731.pdf}}. \r\n\r\nHKDF has been shown to be indifferentiable from a random oracle under\r\nspecific constraints {{LBB20 https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8806752}}: \r\n\r\n- that HMAC is indifferentiable from a random oracle,\r\nwhich for HMAC-SHA-256 has been shown in {{}} {{DRS+13 https://eprint.iacr.org/2013/382.pdf}}, assuming the\r\ncompression function underlying SHA-256 is a random oracle,\r\nwhich it is indifferentiably when used prefix-free.\r\n\r\n- the values of `HKDF`'s `IKM` input do not collide with\r\nvalues of `info` `||` `0x01`. This MUST be enforced by the\r\nconcrete instantiations that use `HKDF` as its KDF. \r\n\r\nThe choice of the KDF security level SHOULD be made based on the\r\nsecurity level provided by the constituent KEMs. The KDF SHOULD\r\nat least have the security level of the strongest constituent KEM.\r\n\r\n### Security Requirements for XOFs\r\n\r\nXOFs accept arbitrary bitstrings as input, and produce\r\na caller-chosen-length prefix of an infinite bitstream\r\ndeterministically defined by the input.\r\n\r\n<!-- requirements: secure PRF, bc key material? -->\r\n\r\n```",
              "createdAt": "2025-06-04T19:25:55Z",
              "updatedAt": "2025-06-04T19:25:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6suev0",
          "commit": {
            "abbreviatedOid": "75615b1"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:27:17Z",
          "updatedAt": "2025-06-04T19:27:18Z",
          "comments": [
            {
              "originalPosition": 785,
              "body": "@br-hale @pag-crypto @bwesterb ",
              "createdAt": "2025-06-04T19:27:17Z",
              "updatedAt": "2025-06-04T19:27:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sufDd",
          "commit": {
            "abbreviatedOid": "75615b1"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:27:48Z",
          "updatedAt": "2025-06-04T19:27:49Z",
          "comments": [
            {
              "originalPosition": 678,
              "body": "```suggestion\r\n### Ciphertext Second Preimage Resistant (C2PRI) Security\r\n\r\nAlso known in the literature as ciphertext collision resistance (CCR).\r\n```",
              "createdAt": "2025-06-04T19:27:49Z",
              "updatedAt": "2025-06-04T19:27:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sufv2",
          "commit": {
            "abbreviatedOid": "5681b6f"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:29:02Z",
          "updatedAt": "2025-06-04T19:29:02Z",
          "comments": [
            {
              "originalPosition": 716,
              "body": "```suggestion\r\n### Security Requirements for KEMs {#security-kems}\r\n```",
              "createdAt": "2025-06-04T19:29:02Z",
              "updatedAt": "2025-06-04T19:29:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6suf0m",
          "commit": {
            "abbreviatedOid": "5681b6f"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:29:11Z",
          "updatedAt": "2025-06-04T19:29:12Z",
          "comments": [
            {
              "originalPosition": 724,
              "body": "```suggestion\r\n### Security Requirements for Groups {#security-groups}\r\n```",
              "createdAt": "2025-06-04T19:29:11Z",
              "updatedAt": "2025-06-04T19:29:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6suf6P",
          "commit": {
            "abbreviatedOid": "5681b6f"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:29:20Z",
          "updatedAt": "2025-06-04T19:29:21Z",
          "comments": [
            {
              "originalPosition": 739,
              "body": "```suggestion\r\n### Security Requirements for KDFs {#security-kdfs}\r\n```",
              "createdAt": "2025-06-04T19:29:20Z",
              "updatedAt": "2025-06-04T19:29:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sugA0",
          "commit": {
            "abbreviatedOid": "5681b6f"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:29:33Z",
          "updatedAt": "2025-06-04T19:29:33Z",
          "comments": [
            {
              "originalPosition": 779,
              "body": "```suggestion\r\n### Security Requirements for XOFs {#security-xofs}\r\n```",
              "createdAt": "2025-06-04T19:29:33Z",
              "updatedAt": "2025-06-04T19:29:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sui11",
          "commit": {
            "abbreviatedOid": "2d3ea4f"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:34:05Z",
          "updatedAt": "2025-06-04T19:34:05Z",
          "comments": [
            {
              "originalPosition": 792,
              "body": "```suggestion\r\n## Security Properties of Hybrid KEMs\r\n\r\n[[ TODO: Define which properties are provided by the hybrid KEMs in this\r\ndocument, and citations to the papers with the corresponding proofs. ]]\r\n\r\nAll generic constructions in this document produce IND-CCA-secure KEMs \r\nwhen correctly instantiated concretely with cryptographic components that\r\nmeet the respective security requirements. Any changes to the routines,\r\nincluding key generation/derivation, are not guaranteed to produce\r\nsecure results.\r\n\r\n```",
              "createdAt": "2025-06-04T19:34:05Z",
              "updatedAt": "2025-06-04T19:34:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sujmc",
          "commit": {
            "abbreviatedOid": "6b0cc87"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:35:12Z",
          "updatedAt": "2025-06-04T19:35:12Z",
          "comments": [
            {
              "originalPosition": 665,
              "body": "```suggestion\r\n## Security Properties {#security-properties}\r\n```",
              "createdAt": "2025-06-04T19:35:12Z",
              "updatedAt": "2025-06-04T19:35:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sujsA",
          "commit": {
            "abbreviatedOid": "6b0cc87"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:35:23Z",
          "updatedAt": "2025-06-04T19:35:23Z",
          "comments": [
            {
              "originalPosition": 667,
              "body": "```suggestion\r\n### IND-CCA Security {#ind-cca}\r\n```",
              "createdAt": "2025-06-04T19:35:23Z",
              "updatedAt": "2025-06-04T19:35:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sujzS",
          "commit": {
            "abbreviatedOid": "6b0cc87"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:35:36Z",
          "updatedAt": "2025-06-04T19:35:36Z",
          "comments": [
            {
              "originalPosition": 676,
              "body": "```suggestion\r\n### Ciphertext Second Preimage Resistant (C2PRI) Security {#c2pri}\r\n```",
              "createdAt": "2025-06-04T19:35:36Z",
              "updatedAt": "2025-06-04T19:35:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6suj6V",
          "commit": {
            "abbreviatedOid": "6b0cc87"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:35:48Z",
          "updatedAt": "2025-06-04T19:35:48Z",
          "comments": [
            {
              "originalPosition": 687,
              "body": "```suggestion\r\n## Binding Properties {#binding-properties}\r\n```",
              "createdAt": "2025-06-04T19:35:48Z",
              "updatedAt": "2025-06-04T19:35:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sum1u",
          "commit": {
            "abbreviatedOid": "bbad377"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:40:50Z",
          "updatedAt": "2025-06-04T19:40:51Z",
          "comments": [
            {
              "originalPosition": 276,
              "body": "Concrete suggestions:\r\n\r\nGHP - named after GHP2018 which is the foundation of all other combiners basically\r\nPRE - prehash\r\nQSF - same as QSF in X-Wing\r\n\r\nShort, mostly meaningful, done.\r\n\r\n```suggestion\r\n* GHP - A generic construction that is suitable for use with any choice\r\n  of traditional and PQ KEMs, with minimal security assumptions on the\r\n  constituent KEMs\r\n* PRE - A performance optimization of HashEverything for the case\r\n  where encapsulation keys are large and frequently reused\r\n* QSF - An optimized generic construction for the case where the traditional\r\n  component is a nominal group and the PQ component has strong binding\r\n  properties\r\n```\r\n\r\n@bifurcation @br-hale @bwesterb @pag-crypto ",
              "createdAt": "2025-06-04T19:40:50Z",
              "updatedAt": "2025-06-04T19:40:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6suwT4",
          "commit": {
            "abbreviatedOid": "bbad377"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:54:44Z",
          "updatedAt": "2025-06-04T19:54:44Z",
          "comments": [
            {
              "originalPosition": 310,
              "body": "```suggestion\r\nThe KEMs, groups, KDFs, and XOFs MUST meet the security requirements in {{#security-requirements}}.\r\n```",
              "createdAt": "2025-06-04T19:54:44Z",
              "updatedAt": "2025-06-04T19:54:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6tK6lh",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-06T15:43:39Z",
          "updatedAt": "2025-06-06T15:43:39Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "Done",
              "createdAt": "2025-06-06T15:43:39Z",
              "updatedAt": "2025-06-06T15:43:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 31,
      "id": "PR_kwDOMmhxws6ZaT7W",
      "title": "#22 with changes on top",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/31",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-06T15:39:59Z",
      "updatedAt": "2025-06-06T19:08:29Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "9e85013a9da7226a2e54c098de0ab5043034a158",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "target-kem-vs-curve",
      "headRefOid": "c43bc983d6a4cae8d0d499d8928c8931143cb163",
      "closedAt": "2025-06-06T19:08:28Z",
      "mergedAt": "2025-06-06T19:08:28Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "c43bc983d6a4cae8d0d499d8928c8931143cb163"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 32,
      "id": "PR_kwDOMmhxws6Z6wsX",
      "title": "Light edits and comments",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/32",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-10T19:34:28Z",
      "updatedAt": "2025-06-12T14:44:48Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "c43bc983d6a4cae8d0d499d8928c8931143cb163",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "light-edit",
      "headRefOid": "b82ec08aeff02fe73582d7bf938d26c0cb009d39",
      "closedAt": "2025-06-12T14:44:38Z",
      "mergedAt": "2025-06-12T14:44:38Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "b97199aeb9977f9b525eaba9d7f46c080a9c27c3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6t6kxT",
          "commit": {
            "abbreviatedOid": "b82ec08"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T15:54:45Z",
          "updatedAt": "2025-06-11T15:54:45Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "\ud83d\udc4d",
              "createdAt": "2025-06-11T15:54:45Z",
              "updatedAt": "2025-06-11T15:54:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6t6lP7",
          "commit": {
            "abbreviatedOid": "b82ec08"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T15:55:08Z",
          "updatedAt": "2025-06-11T15:55:08Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "\ud83d\udc4d",
              "createdAt": "2025-06-11T15:55:08Z",
              "updatedAt": "2025-06-11T15:55:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6t6lch",
          "commit": {
            "abbreviatedOid": "b82ec08"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T15:55:23Z",
          "updatedAt": "2025-06-11T15:55:23Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "\ud83d\udc4d",
              "createdAt": "2025-06-11T15:55:23Z",
              "updatedAt": "2025-06-11T15:55:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6t6ll9",
          "commit": {
            "abbreviatedOid": "b82ec08"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T15:55:35Z",
          "updatedAt": "2025-06-11T15:55:35Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "ok",
              "createdAt": "2025-06-11T15:55:35Z",
              "updatedAt": "2025-06-11T15:55:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6t6nM2",
          "commit": {
            "abbreviatedOid": "b82ec08"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T15:57:48Z",
          "updatedAt": "2025-06-11T15:57:49Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Unfortunately no straightforward name from GHP18, and similarly no real equivalent name in the close one in NIST SP 800-227 # (15), which is kind of why there's no one naming rubric",
              "createdAt": "2025-06-11T15:57:49Z",
              "updatedAt": "2025-06-11T15:57:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6t6obH",
          "commit": {
            "abbreviatedOid": "b82ec08"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T15:59:32Z",
          "updatedAt": "2025-06-11T15:59:32Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "\ud83d\udc4d",
              "createdAt": "2025-06-11T15:59:32Z",
              "updatedAt": "2025-06-11T15:59:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6uIwdV",
          "commit": {
            "abbreviatedOid": "b82ec08"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-12T14:44:32Z",
          "updatedAt": "2025-06-12T14:44:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 33,
      "id": "PR_kwDOMmhxws6aHPHm",
      "title": "Add a reference implementation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/33",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds a reference implementation of the hybrid KEMs.  There are traits for the constituent parts, and then the hybrid KEMs are defined generically over types that implement the constituent parts.\r\n\r\nMy first experiment with Claude Code.  All of the code is Claude-written, I did not open any of the files in an editor.  I have not reviewed, will review as part of this PR.\r\n\r\nFull transcript:\r\n\r\n* Can you read files from the parent directory?\r\n* Make a new Cargo/Rust project in this directory.  it should be in a directory called reference-implementation, and the name of the module should be \r\n* Change directory into reference-implementation\r\n* Add a trait for the KEM interface described in ../draft-irtf-cfrg-hybrid-kems.md\r\n* Give the constants more descriptive names\r\n* Add traits for the KDF and PRG interfaces described in ../draft-irtf-cfrg-hybrid-kems.md\r\n* Rename kem.rs to something more appropriate\r\n* Now write an implementation of the GHP hybrid KEM.  The hybrid KEM should be generic over its constituents, using the traits to bound the generic \r\n* Please add real implementations for the placeholders.  You can assume that the keys, ciphertexts, and shared secrets serialize to fixed-length byte \r\n* Instead of to_bytes / from_bytes, I would use serialize and deserialize.  WHen you serialize, use slices instead of Vec.\r\n* Go back to traits.rs.  Don't use a mutable reference argument, return a reference.  And the serialize methods don't need to be fallible.\r\n* For the hybrid serialization, make the same assumption that the deserialization methods make, namely that the T and PQ serializations are \r\n* In order to make serialization and deserialization easier, change the hybrid keys and ciphertexts just to hold a byte string.\r\n* The generate_key_pair method on GHP needs to actually use random data.  You should take a randomness source as input and use it.  Update the KEM \r\n* Use the CryptoRng trait instead of Rng\r\n* Don't use Rng, just CryptoRng\r\n* Use the latest version\r\n* Don't use RngCore\r\n* Don't use Rng.  Just CryptoRng.\r\n* Thanks, great work.  Now take the GHP implementation, and use it to generate implementations of the PRE and QSF hybrid KEMs\r\n* Move the NominalGroup trait to traits.rs\r\n* Have all of the hybrid KEMs use the same error type.  Split it out into error.rs if you think that's appropriate.\r\n* Are there any placeholders left in the codebase?\r\n* Replace the placeholder in qsf.rs with real randomness\r\n* Instead of using thread_rng, encaps should take an rng argument\r\n* Don't update the trait, remove it from the qsf.rs file.\r\n* Convert this crate from a binary crate to a library crate\r\n* commit the current state to a new branch called vibe-code\r\n* Create test implementations of the traits in traits.rs.  These implementations should fulfill the API in the simplest way possible, without being \r\n* Factor out the test functions so that they can be reused with other implementations.  But keep the tests.\r\n* Now add tests for each of the hybrid KEMs.  You should be able to reuse the KEM tests you already created.\r\n* Commit the tests\r\n* /exit \r\n\r\n",
      "createdAt": "2025-06-11T22:54:14Z",
      "updatedAt": "2025-06-30T07:47:47Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "bbd7ed2497a7ead6c0a3a7f9dc735995fa56f283",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "vibe-code",
      "headRefOid": "487f991671e27ad76d6b2b11b005e6be4f96a9ef",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "* Add a github actions workflow that runs \"cargo test\" on the reference implementation\r\n* Change the name of the workflow to \"Test reference implementation\".  Only run if something in the reference implementation has changed.\r\n* Commit and push the change\r\n* /exit",
          "createdAt": "2025-06-11T23:02:54Z",
          "updatedAt": "2025-06-11T23:02:54Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "Is this one defunct in favor of https://github.com/cfrg/draft-irtf-cfrg-concrete-hybrid-kems/pull/8 now? ",
          "createdAt": "2025-06-30T07:47:47Z",
          "updatedAt": "2025-06-30T07:47:47Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6uLTW4",
          "commit": {
            "abbreviatedOid": "68e63ed"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Partial review; going to fix up the traits and try again.",
          "createdAt": "2025-06-12T18:16:19Z",
          "updatedAt": "2025-06-12T18:49:56Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Should have newlines at the end of files.",
              "createdAt": "2025-06-12T18:16:20Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 7,
              "body": "@dconnolly - Note that you are listed here, presumably based on the spec editor list.  LMK if you'd like to be removed.",
              "createdAt": "2025-06-12T18:17:54Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 6,
              "body": "It would be good for this type to implement Error.",
              "createdAt": "2025-06-12T18:19:21Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 6,
              "body": "The default type for KeyHashError should be `()`.",
              "createdAt": "2025-06-12T18:19:57Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 16,
              "body": "This type is unused, and should be deleted.",
              "createdAt": "2025-06-12T18:21:17Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 26,
              "body": "This should just be `default()`.",
              "createdAt": "2025-06-12T18:29:22Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 153,
              "body": "These `bytes` variables can just be inlined.",
              "createdAt": "2025-06-12T18:33:14Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 160,
              "body": "This is a major deficiency.  What we should do here is:\r\n* Define a trait `Label` that has an associated const `LABEL`\r\n* Make this trait implementation conditional on the hybrid KEM implementing the `Label` trait\r\n* Likewise for the PRE and QSF KEMs",
              "createdAt": "2025-06-12T18:34:45Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 92,
              "body": "This method should go in another trait that is dependent on this trait.",
              "createdAt": "2025-06-12T18:41:13Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 95,
              "body": "Instead of requiring all of these methods, we should just bound the EncapsulationKey / DecapsulationKey / Ciphertext types with `TryFrom<&[u8]> + AsRef<[u8]>`.",
              "createdAt": "2025-06-12T18:43:28Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 119,
              "body": "Instead of this method, we should just bound DecapsulationKey with `AsRef<Self::EncapsulationKey>`.",
              "createdAt": "2025-06-12T18:45:21Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 161,
              "body": "As with the KEM interface types, we should just make the Scalar and Element types serializable.",
              "createdAt": "2025-06-12T18:49:33Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 34,
      "id": "PR_kwDOMmhxws6aO4kQ",
      "title": "Remove mention of SHA3 as a PRG",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/34",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It's fine and secure but it's a little confusing as an interface mismatch",
      "createdAt": "2025-06-12T14:32:36Z",
      "updatedAt": "2025-06-12T16:40:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "6ae56af64bc8fa78a2d0565f29a3742603a854fd",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "dconnolly-patch-1",
      "headRefOid": "5f4296b86e19d67f997caadaf5737aa36809bb12",
      "closedAt": "2025-06-12T16:40:20Z",
      "mergedAt": "2025-06-12T16:40:20Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "111a9143fcff1146d73b4c3c74c7cdcca170c77a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 39,
      "id": "PR_kwDOMmhxws6beEpT",
      "title": "draft-04, Release candidate 1",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/39",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR represents my pre-flight review of the generic doc.  Only a few changes of note:\r\n\r\n* Changed \"construction\" to \"scheme\" basically everywhere, to avoid the idea that we are defining concrete constructions\r\n* Addressed and deleted comments\r\n* Moved the EncapsDerand interface to an appendix, since it is only used for test vectors\r\n* Moved the TODOs to issues and deleted the notes in the doc.",
      "createdAt": "2025-06-20T20:15:01Z",
      "updatedAt": "2025-06-24T17:14:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "111a9143fcff1146d73b4c3c74c7cdcca170c77a",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "rc1",
      "headRefOid": "991bacfa7b81db84469f961347af16ec276e26a0",
      "closedAt": "2025-06-24T17:14:38Z",
      "mergedAt": "2025-06-24T17:14:38Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "64643b80c2b91d502e26e7527f47268c22898ff4"
      },
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "_hello welcome to the bikeshed paint shop_\n\nI'm cool with replacing 'construction' everywhere, but I'm not sure about 'scheme', which tends to be used in literature for concrete designs etc. 'Framework' is used in the X-Wing paper about QSF and in other papers as in 'generic frameworks'...",
          "createdAt": "2025-06-20T22:40:27Z",
          "updatedAt": "2025-06-20T22:40:27Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I 100% do not care what word we use.  \ud83d\udeb2\ud83c\udfe0\ud83d\udd8c\ufe0f\r\n",
          "createdAt": "2025-06-22T18:25:18Z",
          "updatedAt": "2025-06-22T18:25:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6vrXr1",
          "commit": {
            "abbreviatedOid": "b4613b4"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-20T22:36:59Z",
          "updatedAt": "2025-06-20T22:47:31Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\nschemes provide strong security properties as long as the undelying\n```\n",
              "createdAt": "2025-06-20T22:37:00Z",
              "updatedAt": "2025-06-20T22:47:31Z"
            },
            {
              "originalPosition": 53,
              "body": "\ud83d\udc4d",
              "createdAt": "2025-06-20T22:45:30Z",
              "updatedAt": "2025-06-20T22:47:31Z"
            },
            {
              "originalPosition": 381,
              "body": "\ud83d\udc4d",
              "createdAt": "2025-06-20T22:47:09Z",
              "updatedAt": "2025-06-20T22:47:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6vvWdU",
          "commit": {
            "abbreviatedOid": "9440864"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-23T01:02:14Z",
          "updatedAt": "2025-06-23T01:02:14Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "\ud83c\udf89\ud83d\udeb2",
              "createdAt": "2025-06-23T01:02:14Z",
              "updatedAt": "2025-06-23T01:02:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6vvWlg",
          "commit": {
            "abbreviatedOid": "9440864"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-23T01:03:05Z",
          "updatedAt": "2025-06-23T01:03:05Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\ncombining a traditional component algorithm and a PQ KEM. Hybrid KEMs built using these\r\n```",
              "createdAt": "2025-06-23T01:03:05Z",
              "updatedAt": "2025-06-23T01:03:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6vvW2B",
          "commit": {
            "abbreviatedOid": "c558833"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-23T01:04:08Z",
          "updatedAt": "2025-06-23T01:04:08Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nframeworks for constructing hybrid Key Encapsulation Mechanisms (KEMs) based\r\non combining a traditional component algorithm and a PQ KEM. Hybrid KEMs built\r\nusing these frameworks provide strong security properties as long as the underlying\r\n```",
              "createdAt": "2025-06-23T01:04:08Z",
              "updatedAt": "2025-06-23T01:04:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6vvW-Y",
          "commit": {
            "abbreviatedOid": "bf817d6"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-23T01:05:01Z",
          "updatedAt": "2025-06-23T01:05:01Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "```suggestion\r\nThese frameworks share a common overall structure, differing mainly in how they\r\n```",
              "createdAt": "2025-06-23T01:05:01Z",
              "updatedAt": "2025-06-23T01:05:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6wG0OB",
          "commit": {
            "abbreviatedOid": "270c87e"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-24T16:34:24Z",
          "updatedAt": "2025-06-24T16:34:24Z",
          "comments": [
            {
              "originalPosition": 380,
              "body": "```suggestion\r\nBy design, the calls to `KDF` in these frameworks and usage anywhere else\r\n```",
              "createdAt": "2025-06-24T16:34:24Z",
              "updatedAt": "2025-06-24T16:34:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6wHNzE",
          "commit": {
            "abbreviatedOid": "991bacf"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-24T17:14:29Z",
          "updatedAt": "2025-06-24T17:14:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 40,
      "id": "PR_kwDOMmhxws6bmg6L",
      "title": "A few editorial contributions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/40",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The draft is in good shape otherwise.",
      "createdAt": "2025-06-23T06:32:35Z",
      "updatedAt": "2025-06-24T17:19:14Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "111a9143fcff1146d73b4c3c74c7cdcca170c77a",
      "headRepository": "martinthomson/hybrid-kems",
      "headRefName": "notation-domain",
      "headRefOid": "8a70fa36bb5bf6293fea4b66db24e47fa7e23cfc",
      "closedAt": "2025-06-24T17:19:13Z",
      "mergedAt": "2025-06-24T17:19:13Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "b2b13d6afe972a9019217f68cdbb3163e3b8d9f3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6wHQvs",
          "commit": {
            "abbreviatedOid": "226e617"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-24T17:18:20Z",
          "updatedAt": "2025-06-24T17:18:21Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nA set is denoted by listing values in braces: `{a,b,c}`.\r\n\r\nA vector of set elements of length `n` is denoted with exponentiation,\r\nsuch as for the `n`-bit value: {0,1}<sup>n</sup>.\r\n\r\nDrawing uniformly at random from an `n`-bit vector into a value `x`\r\nis denoted: x $\u2190 {0,1}<sup>n</sup>.\r\n\r\nA function `f` that maps from one domain to another is denoted\r\nusing a right arrow to separate inputs from outputs: f : inputs \u2192 outputs.\r\n```",
              "createdAt": "2025-06-24T17:18:20Z",
              "updatedAt": "2025-06-24T17:18:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6wHRLC",
          "commit": {
            "abbreviatedOid": "8a70fa3"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-24T17:19:04Z",
          "updatedAt": "2025-06-24T17:19:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 41,
      "id": "PR_kwDOMmhxws6bmp_E",
      "title": "Remove duplicate CCR mention",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/41",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This pull request needs a Big Lebowski quote.",
      "createdAt": "2025-06-23T06:49:20Z",
      "updatedAt": "2025-06-24T17:19:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "111a9143fcff1146d73b4c3c74c7cdcca170c77a",
      "headRepository": "martinthomson/hybrid-kems",
      "headRefName": "say-it-twice",
      "headRefOid": "6b230801f46160df979219e34a6e4fc47009164c",
      "closedAt": "2025-06-24T17:19:52Z",
      "mergedAt": "2025-06-24T17:19:52Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "1771cce6e26a225c701a727917a43454a034ea29"
      },
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> And was there anything of value in the pull request?\n\n> Oh, yeah. A tape deck, some [CCR] tapes, and there was a, uh, my briefcase",
          "createdAt": "2025-06-23T07:48:39Z",
          "updatedAt": "2025-06-23T07:48:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6wHRlW",
          "commit": {
            "abbreviatedOid": "6b23080"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-24T17:19:42Z",
          "updatedAt": "2025-06-24T17:19:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 42,
      "id": "PR_kwDOMmhxws6bmt-w",
      "title": "Correct some variable names",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/42",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I didn't check thoroughly, but these stood out.",
      "createdAt": "2025-06-23T06:56:17Z",
      "updatedAt": "2025-06-25T05:18:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "111a9143fcff1146d73b4c3c74c7cdcca170c77a",
      "headRepository": "martinthomson/hybrid-kems",
      "headRefName": "ghp-seed_full",
      "headRefOid": "595d63629d3e5a346fa9cbab8b39fb20554b935e",
      "closedAt": "2025-06-24T17:20:52Z",
      "mergedAt": "2025-06-24T17:20:51Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "9102c7275d46a889aae881d3c4bb7cfcedb4017b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6wHSLP",
          "commit": {
            "abbreviatedOid": "595d636"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-24T17:20:45Z",
          "updatedAt": "2025-06-24T17:20:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 43,
      "id": "PR_kwDOMmhxws6bm0ez",
      "title": "Some abstract editing",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/43",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This was originally just a typo fix for a missing 'r'.  But then you had a \"we\", that was unnecessary.\r\n\r\nI split this into two paragraphs, but I'm going to suggest that you delete the first one entirely.  Everything that is needed is in the second.",
      "createdAt": "2025-06-23T07:08:42Z",
      "updatedAt": "2025-06-24T22:32:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "9102c7275d46a889aae881d3c4bb7cfcedb4017b",
      "headRepository": "martinthomson/hybrid-kems",
      "headRefName": "abstract-typo",
      "headRefOid": "05659e673c6b66e2b3d4464c74000068c34b6444",
      "closedAt": "2025-06-24T22:32:42Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation wdyt",
          "createdAt": "2025-06-24T17:47:34Z",
          "updatedAt": "2025-06-24T17:47:34Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm good either way.  Slight preference for removing the first paragraph, but also happy to keep it if people like context.",
          "createdAt": "2025-06-24T21:31:26Z",
          "updatedAt": "2025-06-24T21:31:26Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 45,
      "id": "PR_kwDOMmhxws6b8mCN",
      "title": "Abstract",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/45",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "there was a git booboo",
      "createdAt": "2025-06-24T22:32:11Z",
      "updatedAt": "2025-06-24T22:32:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "9102c7275d46a889aae881d3c4bb7cfcedb4017b",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "abstract",
      "headRefOid": "7b270cc80ece59ccce06694733e4587374113526",
      "closedAt": "2025-06-24T22:32:40Z",
      "mergedAt": "2025-06-24T22:32:40Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "791528bf542ac7538b43bcd801a578f71c0731e8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 46,
      "id": "PR_kwDOMmhxws6b-UBe",
      "title": "Cite how prime order groups like p256 etc are examples of nominal groups",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/46",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #37",
      "createdAt": "2025-06-25T03:44:15Z",
      "updatedAt": "2025-06-25T03:44:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "791528bf542ac7538b43bcd801a578f71c0731e8",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "nominal",
      "headRefOid": "6baf8bf8a82dd67cd67acb5144fc030aa6dd7b4b",
      "closedAt": "2025-06-25T03:44:38Z",
      "mergedAt": "2025-06-25T03:44:38Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "bbd7ed2497a7ead6c0a3a7f9dc735995fa56f283"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 50,
      "id": "PR_kwDOMmhxws6cJCaQ",
      "title": "A stab at 'why these generic frameworks' section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/50",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #48",
      "createdAt": "2025-06-26T00:00:08Z",
      "updatedAt": "2025-06-26T00:01:26Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "bbd7ed2497a7ead6c0a3a7f9dc735995fa56f283",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "expand-on-framework-choices",
      "headRefOid": "818a71ebc1ee7bca4c6e28a2c83720f52abb13b8",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 51,
      "id": "PR_kwDOMmhxws6cJHRy",
      "title": "Add appendix with QSF BIND proof sketches written  by Bas Westerbaan",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/51",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@bwesterb \r\n\r\nResolves https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/52",
      "createdAt": "2025-06-26T00:20:25Z",
      "updatedAt": "2025-06-26T00:22:14Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "bbd7ed2497a7ead6c0a3a7f9dc735995fa56f283",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "sketch-of-qsf-bind-proofs",
      "headRefOid": "97b93ab05bfe4211178e4a039018fb2917279ba3",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 57,
      "id": "PR_kwDOMmhxws6ce8jC",
      "title": "DRAFT: started rewrite of security properties subsection. added some proof sketches",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/57",
      "state": "OPEN",
      "author": "pag-crypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "WRiteup is still work in progress, but i thought people would like to see what i'm working on, to give feedback. STill TODO is fleshing out proofs for leak-bind. ",
      "createdAt": "2025-06-27T20:13:49Z",
      "updatedAt": "2025-06-30T12:56:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "bbd7ed2497a7ead6c0a3a7f9dc735995fa56f283",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "sec-props",
      "headRefOid": "192b6efab9e172566e3f5b9a01f51f28cdcb6dec",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6xCDGr",
          "commit": {
            "abbreviatedOid": "694d555"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T06:54:30Z",
          "updatedAt": "2025-06-30T06:54:30Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n## Cryptographic Security Goals for Hybrid KEMs {#security-properties}\r\n```",
              "createdAt": "2025-06-30T06:54:30Z",
              "updatedAt": "2025-06-30T06:54:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCFj5",
          "commit": {
            "abbreviatedOid": "09afb00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T06:58:44Z",
          "updatedAt": "2025-06-30T06:58:44Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "For KEMs with uniform messages IND-CCA1 and IND-CCA2 are [equivalent](https://eprint.iacr.org/2007/036.pdf#section.C) anyway, most of the literature just calls it (~IND-CCA2) IND-CCA now including NIST ",
              "createdAt": "2025-06-30T06:58:44Z",
              "updatedAt": "2025-06-30T07:30:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCLwB",
          "commit": {
            "abbreviatedOid": "09afb00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:09:33Z",
          "updatedAt": "2025-06-30T07:09:34Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "SHOULD is normative language and since we haven't targeted MAL-BIND and aren't giving our reader explicitly MAL-BIND options in this document (some of the concrete instances in the other document may be) we should probably take this out",
              "createdAt": "2025-06-30T07:09:33Z",
              "updatedAt": "2025-06-30T07:09:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCMlZ",
          "commit": {
            "abbreviatedOid": "09afb00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:10:55Z",
          "updatedAt": "2025-06-30T07:10:55Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "todo: distinguish key binding from the things we call X-BIND-K-[CT/PK] above but haven't explained yet",
              "createdAt": "2025-06-30T07:10:55Z",
              "updatedAt": "2025-06-30T07:10:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCaYu",
          "commit": {
            "abbreviatedOid": "09afb00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:32:51Z",
          "updatedAt": "2025-06-30T07:32:52Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "```suggestion\r\nThe KDF MUST be indifferentiable from a random oracle (RO) {{MRH03}}, even to a quantum attacker {{QROM}}.\r\n```",
              "createdAt": "2025-06-30T07:32:52Z",
              "updatedAt": "2025-06-30T07:32:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCcCx",
          "commit": {
            "abbreviatedOid": "3fd6fe6"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:35:29Z",
          "updatedAt": "2025-06-30T07:35:30Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "```suggestion\r\n### Security Properties of PRE {#security-pre}\r\n```",
              "createdAt": "2025-06-30T07:35:30Z",
              "updatedAt": "2025-06-30T07:35:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCc3G",
          "commit": {
            "abbreviatedOid": "fc8fc80"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:36:45Z",
          "updatedAt": "2025-06-30T07:36:45Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "```suggestion\r\nThe PRE hybrid KEM framework uses a function KeyHash to generate a short digest of the encapsulation keys.\r\nFor IND-CCA2 of PRE, this function must be collision-resistant.\r\n```",
              "createdAt": "2025-06-30T07:36:45Z",
              "updatedAt": "2025-06-30T07:36:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCdJ7",
          "commit": {
            "abbreviatedOid": "fc8fc80"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:37:11Z",
          "updatedAt": "2025-06-30T07:37:12Z",
          "comments": [
            {
              "originalPosition": 154,
              "body": "```suggestion\r\n## Security Properties of Hybrid KEMs Frameworks\r\n```",
              "createdAt": "2025-06-30T07:37:11Z",
              "updatedAt": "2025-06-30T07:37:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCddG",
          "commit": {
            "abbreviatedOid": "fc8fc80"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:37:40Z",
          "updatedAt": "2025-06-30T07:37:40Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "todo: define broken",
              "createdAt": "2025-06-30T07:37:40Z",
              "updatedAt": "2025-06-30T07:37:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCgWY",
          "commit": {
            "abbreviatedOid": "fc8fc80"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:42:07Z",
          "updatedAt": "2025-06-30T07:42:07Z",
          "comments": [
            {
              "originalPosition": 164,
              "body": "```suggestion\r\nThis document's exact GHP and PRE constructions do not have IND-CCA2 analyses; the GHP paper gives a slightly different version, namely they do not include the public keys in the KDF. However, we argue that the proof goes through with trivial modifications if the public keys are included in the KDF. The relevant step is claim 3 of Theorem 1, which reduces to the split-key pseudorandomness of the KDF. (GHP call the KDF a \"core\" function, and denote it as W.) We observe that adding the public keys to the inputs only changes the concrete contents of the reduction's queries to its oracle. Since the reduction chooses the public keys itself, they can be added to the oracle inputs, and the remainder of the proof goes through unmodified.\r\n```",
              "createdAt": "2025-06-30T07:42:07Z",
              "updatedAt": "2025-06-30T07:42:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCiYX",
          "commit": {
            "abbreviatedOid": "8fa0ae0"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:45:16Z",
          "updatedAt": "2025-06-30T07:45:16Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "```suggestion\r\nWe also argue that this extension applies again with trivial modifications to prove security of PRE. Observe that the only difference between GHP and PRE is prehashing of the encapsulation keys. As long as the hash function is collision-resistant, any event that happens in the IND-CCA2 game of GHP happens only with negligible probability in the IND-CCA2 game of PRE.\r\n\r\nWe reiterate that modulo some low-level technical details, our requirement that the KDF is indifferentiable from an RO implies that, in the random oracle model (ROM), the KDF used in GHP and PRE meets the split-key pseudorandomness property used in GHP's analysis.\r\n```",
              "createdAt": "2025-06-30T07:45:16Z",
              "updatedAt": "2025-06-30T07:45:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCjIt",
          "commit": {
            "abbreviatedOid": "8fa0ae0"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:46:26Z",
          "updatedAt": "2025-06-30T07:46:26Z",
          "comments": [
            {
              "originalPosition": 174,
              "body": "```suggestion\r\nTherefore all three hybrid KEMs in this document are IND-CCA2 when instantiated with\r\ncryptographic components that meet the security requirements described above. Any\r\nchanges to the algorithms, including key generation/derivation, are not guaranteed\r\nto produce secure results.\r\n```",
              "createdAt": "2025-06-30T07:46:26Z",
              "updatedAt": "2025-06-30T07:46:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xF58l",
          "commit": {
            "abbreviatedOid": "09afb00"
          },
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T12:52:44Z",
          "updatedAt": "2025-06-30T12:52:45Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Ah thanks for pointing this out - let's just use IND-CCA then",
              "createdAt": "2025-06-30T12:52:44Z",
              "updatedAt": "2025-06-30T12:52:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xF85F",
          "commit": {
            "abbreviatedOid": "8fa0ae0"
          },
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T12:56:22Z",
          "updatedAt": "2025-06-30T12:56:22Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Oops I just realized this text is not correct - I didn't complete the thought. The statement about \"negligible probability\" is obviously false. It should say \"happens with only negligibly different probability\". ",
              "createdAt": "2025-06-30T12:56:22Z",
              "updatedAt": "2025-06-30T12:56:22Z"
            }
          ]
        }
      ]
    }
  ]
}