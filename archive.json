{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-11-18T01:10:12.300317+00:00",
  "repo": "cfrg/draft-irtf-cfrg-hybrid-kems",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "TODO",
      "description": "Known gap in the document",
      "color": "28F613"
    },
    {
      "name": "discuss",
      "description": "Needs discussion to identify the right outcome",
      "color": "C96DEA"
    }
  ],
  "issues": [
    {
      "number": 4,
      "id": "I_kwDOMmhxws6rCIMm",
      "title": "Should instance labels include the XOF that's used for key generation?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/4",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "For example, `QSF-SHA3-256-ML-KEM-768-P-256` doesn't say that it uses SHAKE256 for the XOF. Should we?",
      "createdAt": "2025-02-21T16:15:05Z",
      "updatedAt": "2025-02-25T17:22:50Z",
      "closedAt": "2025-02-25T17:22:50Z",
      "comments": []
    },
    {
      "number": 7,
      "id": "I_kwDOMmhxws6rz1bb",
      "title": "Consider renaming KitchenSink to TranscriptHash",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/7",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See [this post](https://mailarchive.ietf.org/arch/msg/cfrg/L7G1rXH9g_acH1uhs4G2IKRN7dU/).",
      "createdAt": "2025-02-26T18:39:03Z",
      "updatedAt": "2025-05-29T21:54:19Z",
      "closedAt": "2025-05-29T21:54:18Z",
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "NONE",
          "body": "I'm not sure that's right thought\n\n``` \nss = LabeledHKDF(pq_SS, trad_SS, pq_CT, pq_PK, trad_CT, trad_PK, label)\n```\n\nThere's no \"transcript\" in there, unless you jam it into the label, but that's not required by the text? And I think that TLS has a well-defined concept of a \"transcript\", but I think it's less clear what counts as \"transcript\" for example if you have a JWT payload on an HTTP POST -- does \"transcript\" mean that the entire payload of the JWT should be included in the label? Or does \"transcript\" mean the entire sequence of HTTP messages exchanged so far on this connection? Obviously that's not what's intended, but might be how a non-cryptographer interprets the word \"transcript\". I don't have a better suggestion than \"KitchenSink\", but I don't think that \"TranscriptHash\" is the right connotation for protocols that aren't TLS.",
          "createdAt": "2025-02-26T20:06:05Z",
          "updatedAt": "2025-02-26T20:24:15Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Dupe of #20 ",
          "createdAt": "2025-05-29T21:54:18Z",
          "updatedAt": "2025-05-29T21:54:18Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOMmhxws6sPD0w",
      "title": "IANA Register HPKE KDFs?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/8",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The IANA \"Hybrid Public Key Encryption (HPKE)\" page has registries for KEMs, KDFs, and AEADs. Currently, the only KDFs registered are HKDF-SHA256/384512.\n\nI believe that someone needs to register at least these two KDFs in the IANA registry before HPKE key derivation is truly supported:\n- KDF(SHA3-256) \u2014 referring to Section 6.1 of FIPS202\n- XOF(SHAKE256) \u2014 referring to Section 6.2 of FIPS202\n\nThis document seems a likely place for that registration. It may have the nice side effect that the names of the QSF-based KEMs can become shorter.\n",
      "createdAt": "2025-03-02T15:52:34Z",
      "updatedAt": "2025-03-07T20:34:52Z",
      "closedAt": "2025-03-07T20:34:52Z",
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.",
          "createdAt": "2025-03-02T19:48:41Z",
          "updatedAt": "2025-03-02T19:49:02Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.\n\nA separate document to register SHA3 as an HPKE KDF will probably be useful but that's apart from this one",
          "createdAt": "2025-03-02T19:54:50Z",
          "updatedAt": "2025-03-02T19:54:50Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.\n> \n> A separate document to register SHA3 as an HPKE KDF will probably be useful but that's apart from this one\n\nSimilarly, X-Wing is registered In IANA as an HPKE KEM. X-Wing uses SHA3 as its KDF and SHAKE256 as an XOF in its key generation/derivation. Those functions are separate from the HPKE KDFs, same with the KEMs defined and registered in this document and the functions they use internally.",
          "createdAt": "2025-03-02T20:00:26Z",
          "updatedAt": "2025-03-02T20:00:26Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> > > Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.\n> > \n> > \n> > A separate document to register SHA3 as an HPKE KDF will probably be useful but that's apart from this one\n> \n> Similarly, X-Wing is registered In IANA as an HPKE KEM. X-Wing uses SHA3 as its KDF and SHAKE256 as an XOF in its key generation/derivation. Those functions are separate from the HPKE KDFs, same with the KEMs defined and registered in this document and the functions they use internally.\n\n@rohanmahy I've created this to register SHA-3 for HPKE KDFs: https://datatracker.ietf.org/doc/draft-connolly-cfrg-sha3-hpke/",
          "createdAt": "2025-03-04T00:03:04Z",
          "updatedAt": "2025-03-04T00:03:04Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "SHA-3 unfortunately doesn't match the Extract/Expand API expected by HPKE spec so it's not as easy but we can keep working on it",
          "createdAt": "2025-03-07T20:34:44Z",
          "updatedAt": "2025-03-07T20:34:44Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOMmhxws6tFcFU",
      "title": "Make concatenation of KDF inputs explicit in concrete pseudocode",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/10",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We can clarify this concatenation to match the generic QSF construction more closely using the explicit concat() routine described earlier",
      "createdAt": "2025-03-07T20:35:32Z",
      "updatedAt": "2025-05-29T21:53:00Z",
      "closedAt": "2025-05-29T21:52:58Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in current `main`.",
          "createdAt": "2025-05-29T21:52:59Z",
          "updatedAt": "2025-05-29T21:52:59Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOMmhxws6tFlU6",
      "title": "Type inconsistency for `trad_PK`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/11",
      "state": "CLOSED",
      "author": "bluegate010",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "- In `expandDecapsulationKey` (and therefore in `KeyGen`, `DeriveKey`, and `Decaps`), `trad_PK` is a serialized byte array (`trad_PK = G.SerializeElement(NominalGroup.ScalarMultBase(trad_SK))`)\n- In `Encaps`, `trad_PK` is a deserialized element (`trad_PK = P-256.DeserializeElement(pk[1184:1217])`)\n- In `EncapsDerand` for QSF-P256, `trad_PK` is a deserialized element (`trad_PK = P-256.DeserializeElement(pk[1184:1217])`), but is later treated as a serialized byte array (`ss = SHA3-256(pq_SS, trad_SS, trad_CT, trad_PK, label)`)\n- In `EncapsDerand` for KS-X25519, `trad_PK` is a serialized byte array (`trad_PK = pk[1184:1216]`)\n- In `EncapsDerand` for QSF-P384, `trad_PK` is deserialized element (`trad_PK = P-384.DeserializeElement(pk[1568:1629])`)\n\nFor clarity, it seems reasonable for `trad_PK` to always be a serialized byte array.",
      "createdAt": "2025-03-07T20:55:14Z",
      "updatedAt": "2025-05-29T21:49:21Z",
      "closedAt": "2025-05-29T21:49:21Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This has been fixed in the latest `main`.  All the values the KEM interface deals with are fixed-length byte arrays.",
          "createdAt": "2025-05-29T21:49:21Z",
          "updatedAt": "2025-05-29T21:49:21Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOMmhxws6y1iX9",
      "title": "Flesh out the 'out of scope' details more",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/13",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dconnolly"
      ],
      "labels": [
        "TODO"
      ],
      "body": "",
      "createdAt": "2025-04-16T18:10:07Z",
      "updatedAt": "2025-05-29T21:56:34Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 14,
      "id": "I_kwDOMmhxws6y1lj0",
      "title": "Flesh out tradeoffs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/14",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "TODO"
      ],
      "body": "- [ ] include not looking at 'layered' style hybrids\n- [ ] include not looking at split/dualPRF style",
      "createdAt": "2025-04-16T18:15:46Z",
      "updatedAt": "2025-09-29T19:29:37Z",
      "closedAt": "2025-09-29T19:29:37Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate / subset of #13 ?",
          "createdAt": "2025-05-29T21:52:38Z",
          "updatedAt": "2025-05-29T21:52:38Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> Duplicate / subset of [#13](https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/13) ?\n\nDefinitely subset\n\n\n\n",
          "createdAt": "2025-07-03T19:49:02Z",
          "updatedAt": "2025-07-03T19:49:02Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "I_kwDOMmhxws6016Gs",
      "title": "Rename to '-generic-hybrid-kems' to match '-concrete-hybrid-kems'",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/16",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "",
      "createdAt": "2025-05-01T14:50:46Z",
      "updatedAt": "2025-08-11T20:47:56Z",
      "closedAt": "2025-08-11T20:47:55Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems like more keystrokes for no real value.",
          "createdAt": "2025-05-29T21:57:18Z",
          "updatedAt": "2025-05-29T21:57:18Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOMmhxws63zN4v",
      "title": "Names for the schemes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/20",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "GHP? ",
      "createdAt": "2025-05-22T14:51:19Z",
      "updatedAt": "2025-07-03T19:42:30Z",
      "closedAt": "2025-07-03T19:42:30Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I presume you mean \"KitchenSink\" \ud83d\ude04  \n\nWhat does \"GHP\" mean?",
          "createdAt": "2025-05-27T21:32:25Z",
          "updatedAt": "2025-05-27T21:32:25Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "I presume [Giacon, Heuer, Poettering](https://eprint.iacr.org/2018/024.pdf)\n",
          "createdAt": "2025-05-27T21:41:19Z",
          "updatedAt": "2025-05-27T21:41:19Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Renamed the issue to be a little more generic.  Current `main` renames things to try to be more neutral / descriptive: HashEverything / PreHashKeys / HashTraditionalOnly.  The original names (KitchenSink / Chempat / QSF) are a little catchier.  It would be nice if there were something catchy that was also more descriptive of what's going on.  Suggestions welcome.",
          "createdAt": "2025-05-29T21:51:45Z",
          "updatedAt": "2025-05-29T21:51:45Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOMmhxws6401jO",
      "title": "Instantiation of KitchenSink / HashEverything with a nominal group instead of a KEM",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/23",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "",
      "createdAt": "2025-05-29T16:31:47Z",
      "updatedAt": "2025-07-03T19:42:54Z",
      "closedAt": "2025-07-03T19:42:54Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It is technically possible to instantiate the KitchenSink / HashEverything scheme with a nominal group (e.g., ECDH) in place of the IND-CCA KEM called for in the current text.  You just define a pseudo-KEM where the CT is a group element and Encap/Decap are DH operations.\n\nOn the one hand, it seems like this should be secure.  In the case where the PQ KEM is broken, it is effecitively DH-KEM, which is IND-CCA.\n\nOn the other hand, it's not clear that this is a construction that has been analyzed in the literature.  The GHP paper that underlies KitchenSink / HashEverything requires that the inputs be IND-CCA KEMs.\n\nIf we are going to specify this, then we have two choices as to how to define it:\n\n1. Define the \"pseudo-KEM\" sketched above.  This option is notationally compact, but risks people implementing ECDH as a KEM even though it's not secure.\n2. Write out the full instantiation using the Group API.  This option is verbose, but doesn't define a KEM that is not IND-CCA.",
          "createdAt": "2025-05-29T22:08:26Z",
          "updatedAt": "2025-05-29T22:08:26Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOMmhxws641cOD",
      "title": "Refactor security properties subsection of Security Considerations section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/24",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "TODO"
      ],
      "body": "We have some language on IND-CCA and C2PRI but need more on the rest:\n\n## Security Properties\n\n### INDistinguishability against Chosen-Ciphertext Attacks (IND-CCA)\n\n### Ciphertext Second Preimage Resistance (C2PR)\n\n### Binding Properties (X-BIND-P-Q)\n\n### Survival if One KEM Fails\n\n## Security of the Combiners\n\n### Everything {#everything-sec}\n\n### OnlyTraditional {#only-traditional-sec}\n\n### OnlySharedSecrets {#only-shared-secrets-sec}",
      "createdAt": "2025-05-29T17:36:01Z",
      "updatedAt": "2025-07-03T19:43:01Z",
      "closedAt": "2025-07-03T19:43:01Z",
      "comments": [
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "~~Can you point me towards the existing language in the draft on IND-CCA and C2PRI?~~\n\nnever mind, found it",
          "createdAt": "2025-06-11T17:18:31Z",
          "updatedAt": "2025-06-11T17:39:37Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOMmhxws643qD-",
      "title": "Specify the security requirements for constituent elements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/25",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "pag-crypto"
      ],
      "labels": [
        "discuss"
      ],
      "body": "We have three types of constituents that go into our hybrid schemes:\n\n1. KEMs\n2. Nominal groups\n3. Hash functions\n\nThe security requirements for the former two are pretty clear: A KEM needs to be IND-CCA, and if it is going to be used with QSF / HashTraditionalOnly, it needs to have some additional binding properties.  A nominal group needs to be secure in the sense of [ABH+20].\n\nFor the \"hash functions\", we should define a requirement that aligns well with the constructions in the literature, some combination of notions of XOF, KDF, and RO.",
      "createdAt": "2025-05-29T22:12:54Z",
      "updatedAt": "2025-09-17T22:45:32Z",
      "closedAt": "2025-09-17T22:45:32Z",
      "comments": [
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "The current draft has some language on this. Did you want me to review it or add something specific to it?",
          "createdAt": "2025-06-24T18:32:45Z",
          "updatedAt": "2025-06-24T18:32:45Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I would treat the current text as a baseline and feel free to review / revise / reorient as makes sense to tell the overall story.",
          "createdAt": "2025-06-24T21:37:27Z",
          "updatedAt": "2025-06-24T21:37:27Z"
        },
        {
          "author": "ilaril",
          "authorAssociation": "NONE",
          "body": "On the QSF description text, I would strike out the \"the traditional component is a nominal group and\" part. While X-Wing paper only proves the nominal group case, the proof goes through with trivial modifications for any hashed traditional part (with whatever terms arise from traditional part replacing the nominal group terms in the advantage bound).\n",
          "createdAt": "2025-07-17T06:51:49Z",
          "updatedAt": "2025-07-17T06:51:49Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #78 ",
          "createdAt": "2025-09-17T22:45:32Z",
          "updatedAt": "2025-09-17T22:45:32Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOMmhxws643qoZ",
      "title": "Define the desired security properties for the hybrid KEMs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/26",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "pag-crypto"
      ],
      "labels": [
        "TODO"
      ],
      "body": "Normal KEM security notions apply, particularly IND-CCA and X-BIND-P-Q.\n\nThe interesting thing will be how to discuss the \"hybrid\" security notion, i.e., the survival of at least IND-CCA when at least one KEM fails -- for some definition of \"fails\".",
      "createdAt": "2025-05-29T22:14:34Z",
      "updatedAt": "2025-09-29T19:30:23Z",
      "closedAt": "2025-09-29T19:30:23Z",
      "comments": [
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "Do we want some kind of \"hybrid\" security notion for all the KEM security properties we care about? E.g., do we care about the X-BIND-P-Q security of the hybrid if the X-BIND-P-Q security of one of the components fails?",
          "createdAt": "2025-06-24T17:46:17Z",
          "updatedAt": "2025-06-24T17:46:17Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "My impression is that (a) binding properties are generally less important\r\nthan confidentiality properties (IND-CCA), but also (b) binding properties\r\ntend to hold up better than confidentiality properties.  So on the one\r\nhand, if this is a hard thing to show, I might not be sad to lose it.  But\r\non the other hand, I kind of expect we will get some binding properties\r\ntotally irrespective of the security properties of the constituents, e.g.,\r\nX-BIND-SS-Q just by virtue of hashing stuff.\r\n\r\nOn Tue, Jun 24, 2025 at 1:46\u202fPM Paul Grubbs ***@***.***>\r\nwrote:\r\n\r\n> *pag-crypto* left a comment (cfrg/draft-irtf-cfrg-hybrid-kems#26)\r\n> <https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/26#issuecomment-3001363390>\r\n>\r\n> Do we want some kind of \"hybrid\" security notion for all the KEM security\r\n> properties we care about? E.g., do we care about the X-BIND-P-Q security of\r\n> the hybrid if the X-BIND-P-Q security of one of the components fails?\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/26#issuecomment-3001363390>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAASOTJVCI7HA34TXDV43UT3FGFH5AVCNFSM6AAAAAB6GTH3UGVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZTAMBRGM3DGMZZGA>\r\n> .\r\n> You are receiving this because you authored the thread.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2025-06-24T21:30:01Z",
          "updatedAt": "2025-06-24T21:30:01Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "I have not seen even a somewhat realistic scenario where MAL-BIND-P-Q is relevant. But LEAK-BIND-K-PK certainly [has come up](https://iacr.org/submit/files/slides/2025/pkc/pkc2025/19/19_slides.pdf). Abstractions are a bit annoying here: assuming hashes are secure, a concrete hybrid of ML-KEM that hashes in the traditional public key is LEAK-BIND-K-PK, but you can not prove this if you take the components opaquely.",
          "createdAt": "2025-06-25T10:50:59Z",
          "updatedAt": "2025-06-25T10:50:59Z"
        },
        {
          "author": "ilaril",
          "authorAssociation": "NONE",
          "body": "Has there been even remotely realistic scenarios where LEAK-BIND-K-PK is needed, but MAL-BIND-K-CT is not enough? Because for some stuff (e.g., anything involving RSA, HQC or FrodoKEM), binding the key is much more annoying than binding the ciphertext. And the hybrid construction seems to be always MAL-BIND-K-CT if the hashes are strong enough (since either the component ciphertext is hashed, or component is C2PIR).\n\nThere may be some annoying edge cases, tho, e.g., ciphertexts that always decrypt the same way for any key (one infamous KEM had those?), but no honest initiator should ever produce those, so I think that should be enough to stop at least re-encapsulation attacks.",
          "createdAt": "2025-07-17T07:14:30Z",
          "updatedAt": "2025-07-17T07:22:58Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #78 ",
          "createdAt": "2025-09-29T19:30:23Z",
          "updatedAt": "2025-09-29T19:30:23Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOMmhxws643rU2",
      "title": "Describe how the hybrid schemes meet the security goals",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/27",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "pag-crypto"
      ],
      "labels": [
        "TODO"
      ],
      "body": "We should provide citations to proofs in the literature that the schemes we describe are secure given our requirements on the inputs.\n\n* HashEverything should map to one of the schemes in GHP20\n* PreHashKeys - not clear what the right citation is here?\n* HashTraditionalOnly maps to the QSF construction in BCD+24",
      "createdAt": "2025-05-29T22:16:33Z",
      "updatedAt": "2025-07-03T19:42:23Z",
      "closedAt": "2025-07-03T19:42:23Z",
      "comments": [
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "I just read over GHP again; none of their constructions actually match what we now call \"GHP\" in the draft. The issue is that their \"parallel KEM combiner\" construction doesn't hash the public keys, but our \"GHP\" does. Briefly skimming their Theorem 1 (page 10), though, it seems their result would go through basically unmodified if the public keys were added. (The relevant step is claim 3 in that proof. The observation is just that adding the public keys to their \"core\" function W would not change the way the split-key pseudorandomness reduction works except for the concrete Eval oracle inputs.)",
          "createdAt": "2025-06-24T18:09:21Z",
          "updatedAt": "2025-06-24T18:09:21Z"
        },
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "For PRE, as I alluded to in a comment on a different issue - if the gesture I made above at an extension of the GHP analysis is satisfying, then the same analysis should also imply the CCA2 security of PRE as long as you add a step that \"gets rid of\" collisions in the key hash.",
          "createdAt": "2025-06-24T18:11:31Z",
          "updatedAt": "2025-06-24T18:11:31Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOMmhxws643s8r",
      "title": "Serialization of compound values",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/28",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "The values that a hybrid KEM deals with are compound:\n\n* `dk_H = (dk_T, dk_PQ)`\n* `ek_H = (ek_T, ek_PQ)`\n* `ct_H = (ct_T, ct_PQ)`\n\nThe constituent values are fixed-length byte strings, which is needed because we want to feed them into hash functions without ambiguity and without length prefixes.\n\nThe current text specifies that the hybrid values are just the concatenation of the constituent values, and does `concat()` and `split()` as appropriate.  On the one hand, this is a simple construction (avoiding encoding ambiguities one sees, e.g., with ECDSA signatures), and means that the hybrid KEM meets the same KEM API as the constituents.  On the other hand, there's no real need to specify an encoding for these values, so we could punt on the question.",
      "createdAt": "2025-05-29T22:21:23Z",
      "updatedAt": "2025-08-11T20:47:39Z",
      "closedAt": "2025-08-11T20:47:39Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this based on feedback in the PQUIP meeting at IETF 123 that the right approach in general is for algorithms (including the hybrid algorithms specified here) to specify simple encodings for encapsulation keys / ciphertexts, as opposed to, say, delegating to the application to encode these tuples in JSON or something.",
          "createdAt": "2025-08-11T20:47:39Z",
          "updatedAt": "2025-08-11T20:47:39Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOMmhxws6437i1",
      "title": "Should DeriveKeyPair be optional?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/29",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "In the KEM interface, we currently require a DeriveKeyPair algorithm.  We could make this optional, in the same way that `EncapsDerand` is optional.\n\nOn the one hand, this algorithm is not typically included in descriptions of KEMs in the literature.  On the other hand, it is important for integration with things like HPKE and MLS, and most KEMs provide such an algorithm in practice (even if just by making the randomness used by GenerateKeyPair explicit).",
      "createdAt": "2025-05-29T23:05:53Z",
      "updatedAt": "2025-07-03T19:43:48Z",
      "closedAt": "2025-07-03T19:43:48Z",
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Another application is FIDO2, where key pairs are derived determinisitcally. I see no downside to making this required.",
          "createdAt": "2025-06-25T11:10:01Z",
          "updatedAt": "2025-06-25T11:10:01Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "Currently written as required",
          "createdAt": "2025-07-03T19:43:48Z",
          "updatedAt": "2025-07-03T19:43:48Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOMmhxws6438FT",
      "title": "EncapsDerand: Use it or lose it.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/30",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, we define `EncapsDerand` as an optional method on the KEM interface.  But we don't use it anywhere, and we don't define it for the hybrid KEMs.  We should either define this method for the hybrid KEMs when the constituents support it (and thus use it), or delete it.\n\nIf we want it just for purposes of test vectors, we could move it to an appendix.",
      "createdAt": "2025-05-29T23:07:52Z",
      "updatedAt": "2025-06-24T17:14:40Z",
      "closedAt": "2025-06-24T17:14:40Z",
      "comments": []
    },
    {
      "number": 35,
      "id": "I_kwDOMmhxws67anGj",
      "title": "Group_T.ElementToSharedSecret - what does this mean?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/35",
      "state": "CLOSED",
      "author": "pag-crypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft does not specify this procedure, but suggests the possibility of doing x-truncation of an elliptic curve point. The details here seem important for security - for example, x-truncation actually does not bind the entire shared secret into the context - the sign bit is omitted, so there are two possible points even in the case of an honest Encaps.",
      "createdAt": "2025-06-13T17:55:50Z",
      "updatedAt": "2025-07-01T18:38:54Z",
      "closedAt": "2025-07-01T18:38:54Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "The intent here is to capture standard practices w.r.t. elliptic curves.  Despite the fact that there are two points on a curve with the same X coordinate, truncation to the X coordinate is the standard way to get a shared secret from an elliptic curve point.  [NIST SP 800-56A](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar3.pdf) (Section 5.7.1.2) lays this out for the Weierstrass curves that NIST uses.  [RFC 7748](https://datatracker.ietf.org/doc/html/rfc7748#section-5) defines X25519 and X448 purely in terms of U coordinates, ignoring the V coordinate entirely.",
          "createdAt": "2025-06-20T15:41:47Z",
          "updatedAt": "2025-06-20T15:41:47Z"
        },
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "I see, thanks for explaining that. I have a slight suspicion that this could cause problems for beyond-CCA2 properties like binding, because for any DH shared secret the values aG and (-a)G are both valid KEM ciphertexts for a given public key. (It's possible I did the math wrong here, but some kind of negative-sign-swap has to be possible since information is lost in the truncation...) In short, the \"full\" context isn't really bound into the derived key if only the x-coordinate is hashed. ",
          "createdAt": "2025-06-24T17:14:56Z",
          "updatedAt": "2025-06-24T17:14:56Z"
        },
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, I'm thinking about this more and I'm not sure DH-KEM in general is even CCA2 secure if you get rid of the y-coordinate? In the CCA game the adversary, given its challenge DH-KEM ciphertext C, can just negate C and submit -C to the decaps oracle. If in decaps you ignore the y-coordinate, C and -C derive the same key and the adversary wins w.p. 1. Maybe I'm missing something and this attack doesn't work, though.",
          "createdAt": "2025-06-24T18:20:03Z",
          "updatedAt": "2025-06-24T18:20:03Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that the terminology here is a bit twitchy -- there's the obvious\r\n\"KEM\" induced by DH, and there's also DHKEM in the sense of HPKE / RFC9180.\r\n\r\nDHKEM in the sense of HPKE / RFC 9180 is IND-CCA, as I think is shown in\r\nABH+21.  (The -Y issue is addressed by hashing in the full public key (X,\r\nY).)\r\n\r\nDHKEM in the sense of the obvious \"KEM\" induced by DH -- I think this is\r\ngenerally known to be not IND-CCA.  That's why there's a separate nominal\r\ngroup treatment instead of just specifying the obvious KEM.\r\n\r\nOn Tue, Jun 24, 2025 at 2:20\u202fPM Paul Grubbs ***@***.***>\r\nwrote:\r\n\r\n> *pag-crypto* left a comment (cfrg/draft-irtf-cfrg-hybrid-kems#35)\r\n> <https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/35#issuecomment-3001459178>\r\n>\r\n> Actually, I'm thinking about this more and I'm not sure DH-KEM in general\r\n> is even CCA2 secure if you get rid of the y-coordinate? In the CCA game the\r\n> adversary, given its challenge DH-KEM ciphertext C, can just negate C and\r\n> submit -C to the decaps oracle. If in decaps you ignore the y-coordinate, C\r\n> and -C derive the same key and the adversary wins w.p. 1. Maybe I'm missing\r\n> something and this attack doesn't work, though.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/35#issuecomment-3001459178>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAASOTJ4T5FUQ2YCSMP3CET3FGJGRAVCNFSM6AAAAAB7IXJUYSVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZTAMBRGQ2TSMJXHA>\r\n> .\r\n> You are receiving this because you commented.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2025-06-24T21:45:28Z",
          "updatedAt": "2025-06-24T21:45:28Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "> Actually, I'm thinking about this more and I'm not sure DH-KEM in general is even CCA2 secure if you get rid of the y-coordinate? In the CCA game the adversary, given its challenge DH-KEM ciphertext C, can just negate C and submit -C to the decaps oracle.\n\nYou'd need to get rid of the y-coordinate everywhere (so also the decaps oracle only takes x coordinate.)\n\n",
          "createdAt": "2025-06-25T10:57:46Z",
          "updatedAt": "2025-06-25T10:57:46Z"
        },
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "I see, yeah - hashing the public key and nominal group ciphertext fixes this. ",
          "createdAt": "2025-07-01T18:38:40Z",
          "updatedAt": "2025-07-01T18:38:40Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "I_kwDOMmhxws68ku2x",
      "title": "Determine the security requirements for PRE/KeyHash",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/36",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "The PRE scheme requires a KeyHash function for pre-hashing the encapsulation keys.  We should specify what security definitions this function needs to meet.\n\nThe only example we have right now is the use of SHA3-256 in the Chempat specification, which does not include a general security definition or any proofs of security from which we could back out a definition.",
      "createdAt": "2025-06-20T15:45:47Z",
      "updatedAt": "2025-07-03T19:44:04Z",
      "closedAt": "2025-07-03T19:44:04Z",
      "comments": [
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't really see why plain collision-resistance can't work here? As far as the analysis goes, as long as you \"get rid of\" KeyHash collisions using a CRH game hop, in the rest of the analysis you can treat the hash as being basically the same as the keys themselves. Put slightly differently I suspect you could take an analysis of pretty much any property for GHP and mechanically transform the analysis into one for PRE, by just adding one step that gets rid of collisions at the beginning. (Usual caveats apply, since I made up this claim on the spot just now.)",
          "createdAt": "2025-06-24T17:42:55Z",
          "updatedAt": "2025-06-24T17:42:55Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems plausible to me that collision-resistance is sufficient.  But we would want to either cite something to that effect or lay out the analysis in the document.",
          "createdAt": "2025-06-24T21:26:17Z",
          "updatedAt": "2025-06-24T21:26:17Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "I_kwDOMmhxws68kvgh",
      "title": "Add citations to proofs that NIST curves are nominal groups",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/37",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "TODO"
      ],
      "body": "",
      "createdAt": "2025-06-20T15:46:53Z",
      "updatedAt": "2025-06-25T03:44:39Z",
      "closedAt": "2025-06-25T03:44:39Z",
      "comments": [
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "The HPKE analysis paper discusses how to view NIST P-curves, Curve25519, and Curve448 as nominal groups: https://eprint.iacr.org/2020/1499.pdf \n\nis this what you mean? I'm not sure what a more precise \"proof\" would look like - the nominal groups notion seems more syntactic than like a hardness assumption or something like that.",
          "createdAt": "2025-06-24T17:37:47Z",
          "updatedAt": "2025-06-24T17:37:47Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I think that's probably the right citation.  We just need to cite it!\n\nTo your point about hardness: Seems like the right phrasing is probably something like \"A nominal group in which the [some Diffie-Hellman] problem is hard\", right?  Where the DH notion would be whatever the relevant hybrid KEM proofs rely on.",
          "createdAt": "2025-06-24T21:22:54Z",
          "updatedAt": "2025-06-24T21:24:46Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "I_kwDOMmhxws68kxoa",
      "title": "Define a registry of combination labels?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/38",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "The hybrid schemes include a \"label\" input that provides domain separation between specific instantiations.  It could help interoperability if there were a central list of these labels, with references to the instantiations they go with.  This could be a very simple IANA registry, just a \"label\" column and a \"reference\" column.  It might even be fine to make the registration policy First Come First Served.",
      "createdAt": "2025-06-20T15:50:21Z",
      "updatedAt": "2025-07-03T19:44:22Z",
      "closedAt": "2025-07-03T19:44:22Z",
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "not sure about labels per se, also this sounds closer to an IANA registry for KEMs period, which i don't think cfrg has done for any primitive; also labels may be the same across different kdfs, inputs, lengths, and achieve oracle cloning, so",
          "createdAt": "2025-06-20T22:43:47Z",
          "updatedAt": "2025-06-20T22:43:47Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now, I think ",
          "createdAt": "2025-07-03T19:44:22Z",
          "updatedAt": "2025-07-03T19:44:22Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "I_kwDOMmhxws69Gt1V",
      "title": "Explicit vs. implicit rejection KEMs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/44",
      "state": "OPEN",
      "author": "pag-crypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "TODO"
      ],
      "body": "In the current draft, none of the constructions seem to handle the case where a KEM can \"explicitly\" fail during decapsulation - that is, output some failure indicator instead of a syntactically-valid shared secret. If the constructions only work for implicit-rejection KEMs, we should probably make this clear in the draft to remove a potential future footgun. (Apologies if this was covered somewhere and I missed it..)",
      "createdAt": "2025-06-24T16:51:38Z",
      "updatedAt": "2025-09-29T19:29:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> In the current draft, none of the constructions seem to handle the case where a KEM can \"explicitly\" fail during decapsulation - that is, output some failure indicator instead of a syntactically-valid shared secret. If the constructions only work for implicit-rejection KEMs, we should probably make this clear in the draft to remove a potential future footgun. (Apologies if this was covered somewhere and I missed it..)\n\nThe QSF construction 'passes through' whatever its PQ KEM does; GHP seems underspecified; PRE would basically do whatever GHP does, but [GHP18](https://eprint.iacr.org/2018/024.pdf) doesn't even consider implicit/explicit rejection; I've seen sketches of constructions that basically say 'if any component returns \u23da, return \u23da'",
          "createdAt": "2025-06-25T03:48:05Z",
          "updatedAt": "2025-06-25T03:48:05Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Most contact with reality makes an implicitly rejecting KEM explicitly rejecting: for instance, in TLS if both sides do not agree on the same shared secret, the AEAD will error out, and the failed connection is rather explicit. Thus, for security analysis we should assume KEMs are explicitly rejecting (but luckily that [doesn't seem to matter much](https://link.springer.com/chapter/10.1007/978-3-031-86602-9_12).) On the other hand, from an API usability perspective it's better to have an implicitly KEM, as it's one less corner case to deal with. ",
          "createdAt": "2025-06-25T10:22:26Z",
          "updatedAt": "2025-06-25T10:22:26Z"
        },
        {
          "author": "ilaril",
          "authorAssociation": "NONE",
          "body": "It is not just the KEM that could fail, but the traditional part as well. E.g., X25519.\n\n(And explicit rejection is easier to test.)",
          "createdAt": "2025-07-17T07:27:43Z",
          "updatedAt": "2025-07-17T07:31:00Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @bwesterb that we should consider all KEMs here explicitly rejecting.\n\nThe Python-ish pseudocode we are using kind of obscures this, since Python exceptions can be raised anywhere.  So it would be good to be explicit.",
          "createdAt": "2025-08-11T20:44:44Z",
          "updatedAt": "2025-08-11T20:44:44Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2025-09: Hybrid KEMs should only pass on any failures from the component KEMs.  Basically: \u201cwrite pseudocode as if things are infallible, write advisory text about failures\u201d. Where the advisory text would be something like \"if one KEM fails, fail the hybrid, but don't reveal anything other than failure\".  We should not do the strong form of \"implicit\", which would be something like, \"if a KEM explicitly fails, generate a random SS for it\"\n",
          "createdAt": "2025-09-29T19:29:06Z",
          "updatedAt": "2025-09-29T19:29:06Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "I_kwDOMmhxws69Sro7",
      "title": "Sketch proofs for leak-bind-k-[pk, ct] for generics in appendix",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/47",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bwesterb",
        "dconnolly",
        "pag-crypto"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-25T14:04:59Z",
      "updatedAt": "2025-07-03T19:37:24Z",
      "closedAt": "2025-07-03T19:37:24Z",
      "comments": []
    },
    {
      "number": 48,
      "id": "I_kwDOMmhxws69S5qS",
      "title": "Expand on generic framework choices in subsection ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/48",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dconnolly"
      ],
      "labels": [],
      "body": "GHP: works for generic IND-CCA components, IND-CCA proofs from GHP18, including PKs fits in 'additional data' parts of the split key PRF proof there, and binds to PKs which is nice for protocols, and whole thing matches pubs like NIST SP 800-227 IPD, and gives good binding properties / is generally safe / no caveats on use for broad array of components with current IND-CCA analysis etc\n\nQSF: works for most common elliptic curve groups and C2PRI pq KEMs, optimization that leaves out large ciphertexts and PKs from hashing if the PQ KEM meets requirements, more KEMs can be proven to have C2PRI \n\nPRE: same benefits as GHP while allowing an optimization to pre-hash static PKs, which if large can be a performance improvement",
      "createdAt": "2025-06-25T14:18:55Z",
      "updatedAt": "2025-07-07T23:23:41Z",
      "closedAt": "2025-07-07T23:23:41Z",
      "comments": []
    },
    {
      "number": 49,
      "id": "I_kwDOMmhxws69TQER",
      "title": "sketch how PRE is still IND-CCA in appendix",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/49",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "pag-crypto"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-25T14:45:25Z",
      "updatedAt": "2025-07-03T19:41:12Z",
      "closedAt": "2025-07-03T19:41:12Z",
      "comments": []
    },
    {
      "number": 52,
      "id": "I_kwDOMmhxws69YbHJ",
      "title": "Sketch BIND proofs for QSF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/52",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-26T00:21:04Z",
      "updatedAt": "2025-07-03T19:40:45Z",
      "closedAt": "2025-07-03T19:40:45Z",
      "comments": []
    },
    {
      "number": 53,
      "id": "I_kwDOMmhxws69YbJS",
      "title": "Sketch GHP BIND proofs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/53",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-26T00:21:13Z",
      "updatedAt": "2025-07-03T19:40:40Z",
      "closedAt": "2025-07-03T19:40:40Z",
      "comments": []
    },
    {
      "number": 54,
      "id": "I_kwDOMmhxws69YbON",
      "title": "Sketch PRE BIND proofs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/54",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "pag-crypto"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-26T00:21:29Z",
      "updatedAt": "2025-07-03T19:40:32Z",
      "closedAt": "2025-07-03T19:40:32Z",
      "comments": []
    },
    {
      "number": 55,
      "id": "I_kwDOMmhxws69wzkg",
      "title": "Ciphertext second-preimage resistance for hybrid KEMs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/55",
      "state": "CLOSED",
      "author": "pag-crypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the current draft, ciphertext second pre-image resistance (C2PRI) is listed as a desired property of our hybrid KEMs. What is the justification for this? It is clear that QSF requires the PQ KEM to have ciphertext preimage resistance in order for the composition to be IND-CCA2, but does this mean C2PRI is necessarily a design goal for the whole composition? If so, what is the justification?",
      "createdAt": "2025-06-27T18:08:34Z",
      "updatedAt": "2025-07-03T19:41:04Z",
      "closedAt": "2025-07-03T19:41:04Z",
      "comments": [
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "In my rewrite of the \"security properties\" subsection I'm going to remove it for now, but it'd be pretty easy to add back.",
          "createdAt": "2025-06-27T18:09:50Z",
          "updatedAt": "2025-06-27T18:09:50Z"
        }
      ]
    },
    {
      "number": 56,
      "id": "I_kwDOMmhxws69xXZY",
      "title": "KDF security properties",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/56",
      "state": "CLOSED",
      "author": "pag-crypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dconnolly"
      ],
      "labels": [
        "TODO"
      ],
      "body": "The current writeup is unclear about the security requirements for the KDF: it says both that they must be PRFs and random oracles. I think I know why this ambiguity exists - the X-Wing paper's analyses of QSF have different requirements on the KDF depending on whether security is proved from the strong DH problem or the CCA2 security of the KEM. (The SDH proof requires the ROM - in a nontrivial way - and the CCA2 proof only requires PRF.) \n\nSince (modulo some details) having the KDF modelled as a RO is stronger than treating it as a PRF, i think it would be conservative as a starting point to just require the KDF to be indifferentiable from a RO. However, I think we'll probably get some pushback on this from the CFRG.",
      "createdAt": "2025-06-27T19:07:29Z",
      "updatedAt": "2025-10-20T22:20:49Z",
      "closedAt": "2025-10-20T22:20:49Z",
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> The current writeup is unclear about the security requirements for the KDF: it says both that they must be PRFs and random oracles. I think I know why this ambiguity exists - the X-Wing paper's analyses of QSF have different requirements on the KDF depending on whether security is proved from the strong DH problem or the CCA2 security of the KEM. (The SDH proof requires the ROM - in a nontrivial way - and the CCA2 proof only requires PRF.)\n> \n> Since (modulo some details) having the KDF modelled as a RO is stronger than treating it as a PRF, i think it would be conservative as a starting point to just require the KDF to be indifferentiable from a RO. However, I think we'll probably get some pushback on this from the CFRG.\n\nI'm fine with this, especially if we explicitly say in the text 'indiff. implies PRF security' in a way",
          "createdAt": "2025-07-03T19:46:36Z",
          "updatedAt": "2025-07-03T19:46:36Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> > The current writeup is unclear about the security requirements for the KDF: it says both that they must be PRFs and random oracles. I think I know why this ambiguity exists - the X-Wing paper's analyses of QSF have different requirements on the KDF depending on whether security is proved from the strong DH problem or the CCA2 security of the KEM. (The SDH proof requires the ROM - in a nontrivial way - and the CCA2 proof only requires PRF.)\n> > Since (modulo some details) having the KDF modelled as a RO is stronger than treating it as a PRF, i think it would be conservative as a starting point to just require the KDF to be indifferentiable from a RO. However, I think we'll probably get some pushback on this from the CFRG.\n> \n> I'm fine with this, especially if we explicitly say in the text 'indiff. implies PRF security' in a way\n\nI added a todo [here](https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/blob/6183080e4c32287080e8de6b9ba16cac6bf547c3/draft-irtf-cfrg-hybrid-kems.md?plain=1#L922), we may be able to just do this arguing in the text using indiff. literature to make the argument, since there doesn't seem to be a nice tidy citation ",
          "createdAt": "2025-07-03T19:48:00Z",
          "updatedAt": "2025-07-03T19:48:00Z"
        },
        {
          "author": "fluppe2",
          "authorAssociation": "NONE",
          "body": "@dconnolly Concerning the todo [here](https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/blob/6183080e4c32287080e8de6b9ba16cac6bf547c3/draft-irtf-cfrg-hybrid-kems.md?plain=1#L922), i.e.\n\n> We reiterate that modulo some low-level technical details, our requirement\n> that the KDF is indifferentiable from an RO implies that, in the ROM, the KDF\n> used in GHP and PRE meets the split-key pseudorandomness property used in\n> GHP's analysis.\n> TODO: apparently there is no good citation for this foklore, maybe we can explicitly lay it out\n\nI guess, Lemma 6 in combination with Example 3 in GHP18 (https://eprint.iacr.org/2018/024) is exactly what you are looking for.\n\nIn Lemma 6 they construct\n\n> a pseudorandom skPRF from any almost-uniform keymixing function in the random oracle model\n\nby `H(g(k1,...,kn), x) `, where `H` is modeled as a random oracle and `g` is $\\epsilon$-almost uniform. Example 3 qualifies `g(k1,...,kn) = k1 || ... || kn` as $\\epsilon$-almost uniform (with $\\epsilon = 1/ \\mathrm{len} (k_1 \\mathrm{||} \\ldots \\mathrm{||} k_n)$. ",
          "createdAt": "2025-07-25T06:49:03Z",
          "updatedAt": "2025-07-25T08:16:45Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you @fluppe2 !",
          "createdAt": "2025-10-20T21:52:36Z",
          "updatedAt": "2025-10-20T21:52:36Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "I_kwDOMmhxws6-GnVJ",
      "title": "restore rederivation from seed via DeriveKeyPair(seed) inside Decaps()",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/58",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dconnolly"
      ],
      "labels": [],
      "body": "This got mangled in the major refactor",
      "createdAt": "2025-06-30T18:04:24Z",
      "updatedAt": "2025-07-01T19:25:58Z",
      "closedAt": "2025-07-01T19:25:58Z",
      "comments": []
    },
    {
      "number": 60,
      "id": "I_kwDOMmhxws6-V9NE",
      "title": "move impl of generic frameworks into the concrete repo as internals/private only",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/60",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [
        "TODO"
      ],
      "body": "",
      "createdAt": "2025-07-01T18:22:25Z",
      "updatedAt": "2025-08-08T00:58:05Z",
      "closedAt": "2025-08-08T00:58:05Z",
      "comments": []
    },
    {
      "number": 64,
      "id": "I_kwDOMmhxws6_g-0p",
      "title": "Describe multi-user security and how each framework achieves it",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/64",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "",
      "createdAt": "2025-07-08T16:16:28Z",
      "updatedAt": "2025-10-20T22:58:38Z",
      "closedAt": "2025-10-20T22:58:38Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussing among the authors, it doesn't seem like this is a critical property for KEMs, and it is probably implied by the binding properties anyway",
          "createdAt": "2025-10-20T22:58:38Z",
          "updatedAt": "2025-10-20T22:58:38Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "I_kwDOMmhxws7A7JKv",
      "title": "add paul as author",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/66",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-16T17:15:49Z",
      "updatedAt": "2025-07-21T00:30:53Z",
      "closedAt": "2025-07-21T00:30:53Z",
      "comments": []
    },
    {
      "number": 67,
      "id": "I_kwDOMmhxws7A9yln",
      "title": "Always use (PQ, T) ordering",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/67",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "There are a few cases in the document where a PQ thing and a T thing are paired together, and we don't always use the same order, for example:\n\n* Hybrid ciphertexts and encapsulation keys: (T, PQ)\n* Shared secret inputs to the KDF: (PQ, T)\n\nFor consistency, it would be good to use the same ordering for all of these cases.  As far as I know, this ordering makes no difference cryptographically or in terms of compliance requirements.  (I believe there were some FIPS concerns which are now obsolete.)\n\nPersonally, I would probably go with the (PQ, T) ordering, because it matches the QSF paper and the GHP paper ([see Fig. 4](https://eprint.iacr.org/2018/024.pdf)) is agnostic.",
      "createdAt": "2025-07-16T21:40:33Z",
      "updatedAt": "2025-08-28T15:23:11Z",
      "closedAt": "2025-08-28T15:23:11Z",
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "i think this is fine and shouldn't have any interop issues with X-Wing",
          "createdAt": "2025-07-16T21:53:42Z",
          "updatedAt": "2025-07-16T21:53:42Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "It is a compat issue. Discovered when checking test vectors.",
          "createdAt": "2025-07-17T05:13:13Z",
          "updatedAt": "2025-07-17T05:13:13Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> It is a compat issue. Discovered when checking test vectors.\n\nFor the others besides X-Wing as specified in draft-connolly-cfrg-xwing-kem-06+ ? Drat",
          "createdAt": "2025-07-17T17:02:43Z",
          "updatedAt": "2025-07-17T17:02:43Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "NONE",
          "body": "> Personally, I would probably go with the (PQ, T) ordering, because it matches the QSF paper and the GHP paper \n\n... and LAMPS Composites.",
          "createdAt": "2025-07-21T15:43:10Z",
          "updatedAt": "2025-07-21T15:43:10Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "I_kwDOMmhxws7IxU0T",
      "title": "HKDF as a KDF is under-specified",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/74",
      "state": "CLOSED",
      "author": "bluegate010",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "KEM constructions specified in this document leverage their KDF with a single input and single output parameter (i.e. `ss_H = KDF(concat(ss_PQ, ss_T, ct_T, ek_T, Label))`). HKDF takes salt, IKM, info, and L. The spec does not specify how to populate each of these fields.\n\nAn [earlier version](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hybrid-kems-01#name-kitchensink-hkdf-sha-256-ml) fully specified how HKDF should be used (salt = \"\", IKM = \"hybrid_prk\" || preimage, info = I2OSP(32, 2) || \"shared_secret\", L = 32).",
      "createdAt": "2025-08-29T22:36:07Z",
      "updatedAt": "2025-09-12T16:49:19Z",
      "closedAt": "2025-09-12T16:49:19Z",
      "comments": [
        {
          "author": "bluegate010",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Update: none of the parameterizations in [draft-irtf-cfrg-concrete-hybrid-kems](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-concrete-hybrid-kems) use HKDF (with the current exception of QSF-MLKEM1024-P384-SHA3256-SHAKE256, but that's a bug, the KDF parameter should read SHA3-256).\n\nSo draft-irtf-cfrg-hybrid-kems could simply omit references to HKDF.",
          "createdAt": "2025-08-29T23:53:28Z",
          "updatedAt": "2025-08-31T01:47:42Z"
        }
      ]
    },
    {
      "number": 77,
      "id": "I_kwDOMmhxws7L01up",
      "title": "Should external keygen be considered a different algorithm?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/77",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "TODO"
      ],
      "body": "In #73, we allow for two different styles of key generation: the default \"shared seed\" approach, and an \"external keygen\" approach that basically just invokes whatever keygen the component algorithms provide.  In the shared seed approach, the decapsulation key is `seed`; in the \"external keygen\" approach, the decapsulation key is `(dk_PQ, dk_T)`.\n\nConsider two implementations of a hybrid KEM that differ **only in terms of keygen** -- they use the same component algorithms, same constants, etc.  Should these implementations be considered to be different things?\n\nIn the scope of this document, this question primarily comes down to labels -- should these two cases have different domain separation labels?\n\nIn favor of different:\n* The two keygen processes result in different security properties.  MAL-BIND vs. LEAK-BIND\n* Since the decapsulation key formats are different, so it's not clear what private key format an implementation of the algorithm should accept\n\nIn favor of same:\n* The two \"algorithms\" are identical when it comes to the part that matters for interop, i.e., the encapsulation logic.\n* Which key generation the decapsulator uses is invisible to the encapsulator.  Any claim about is an unenforceable promise.  The encapsulator shouldn't have to care.",
      "createdAt": "2025-09-15T21:46:50Z",
      "updatedAt": "2025-10-20T22:49:59Z",
      "closedAt": "2025-10-20T22:49:59Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Personally, my preference would be for \"same\", because MAL-BIND doesn't seem that important in practice, and because I don't think it's useful to promise something in the label that the decapsulator might be lying about.\n\nI also think that implementations that actually achieve MAL-BIND will be rare, because the moment you cache intermediate keys, you lose MAL-BIND with respect to a local attacker.  And caching will be very tempting for implementors.",
          "createdAt": "2025-09-15T21:50:31Z",
          "updatedAt": "2025-09-15T21:50:31Z"
        },
        {
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "body": "_Strong_ preference for same. My current use case for the hybrids is post-quantum age keys. It would be ridiculous for a key split half in hardware (P-256) and half in software (ML-KEM-768) not to interoperate with a key wholly in software. I would almost certainly disregard the \"external keygen\" label, and use the default one everywhere. But then we'd be obviously signing ourselves up for endless interoperability issues and MUST violation debates when others disagree and feel backed up by the RFC.\n\nI can't make sense of expressing in the label properties of the keygen. Should we have different labels for ECDH keys generated with rejection sampling and wide reduction? With a FIPS 140 DRBG or not?\n\nIn my career I don't think I have cared once about a malicious private key (further than \"can it crash the system\").",
          "createdAt": "2025-09-15T23:16:50Z",
          "updatedAt": "2025-09-15T23:16:50Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "I do not favor 'same', at least because supporting two different keygens for 'one' possible scheme supported by this document with the same secret key value (eg 96 bytes, either as a seed or two keygens slapped together) will produce different public keys. This does impact the binding properties of the generic schemes, whose component KEMs we don't have further requirements on their own binding properties (C2PRI is preimage resistance, not collision resistance.) In contrast, for the X-Wing scheme, which is concretely using ML-KEM-768 and x25519, we can make a more informed decision about whether the 'same' keygen variant is fine to use alongside the actual specified seed variant\u2014 we have multiple papers now analyzing the zoo of binding properties of ML-KEM and other more practical properties in practice (bugs like KyberSlash etc). For generics, there's a lot more unwritten about the component schemes\u2014 we only make requirements about IND-CCA and C2PRI and SDH, etc.\n\nI think having /two/ keygens be allowed for a concrete hybrid KEM is not good\u2014 picking one, whichever one, is more important. We've already seen consequences of two key formats for FIPS 203/FIPS 204. \n\nIn the generic document, writing the algorithms down for one keygen seems necessary to have a whole generic hybrid KEM framework to analyze; having a section that's basically a escape hatch ('when instantiating these schemes concretely, you MAY choose a non-seed variant of the keygen, but you SHOULD only choose one keygen per concrete instance', or something like that) seems like a compromise that will favor seed-based as a default, but allow exceptions. I know this doesn't help much with doing non-seed X-Wing keygen, but that was already going off-spec anyway\u2014 but if that proposed language were in the generic document, it would be compliant, I think",
          "createdAt": "2025-09-16T18:08:43Z",
          "updatedAt": "2025-09-16T18:13:28Z"
        },
        {
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "body": "> having a section that's basically a escape hatch ('when instantiating these schemes concretely, you MAY choose a non-seed variant of the keygen, but you SHOULD only choose one keygen per concrete instance', or something like that) seems like a compromise that will favor seed-based as a default, but allow exceptions\n\nThat sounds good to me. Non-seed keygen can and IMHO should be an exceptional, even off-spec path. As long as it's still interoperable when it makes sense (e.g. in the hardware case, where there isn't the concept of turning bytes into keys at all).",
          "createdAt": "2025-09-16T19:08:45Z",
          "updatedAt": "2025-09-16T19:08:45Z"
        },
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "> having a section that's basically a escape hatch ('when instantiating these schemes concretely, you MAY choose a non-seed variant of the keygen, but you SHOULD only choose one keygen per concrete instance', or something like that) seems like a compromise that will favor seed-based as a default, but allow exceptions.\n\nI agree with Deirdre - this seems like a good approach.",
          "createdAt": "2025-09-16T20:59:03Z",
          "updatedAt": "2025-09-16T20:59:03Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with guiding toward shared-seed as the default.  The only part of the quoted text that concerns me is:\n\n> you SHOULD only choose one keygen per concrete instance\n\nIn the parlance we are using, \"concrete instance\" means \"specific combination of KEMs and KDF\", so this would mean, for example, \"only seeds are allowed with X-Wing\".  It is precisely the \"different\" approach, in the sense that if you want both seed and separate keygen, they would have to be different \"concrete instances\", thus different labels, thus non-interoperable.  And as I said above, this is all pain and no gain.",
          "createdAt": "2025-09-18T00:20:18Z",
          "updatedAt": "2025-09-18T00:20:18Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> I agree with guiding toward shared-seed as the default. The only part of the quoted text that concerns me is:\n> \n> > you SHOULD only choose one keygen per concrete instance\n> \n> In the parlance we are using, \"concrete instance\" means \"specific combination of KEMs and KDF\", so this would mean, for example, \"only seeds are allowed with X-Wing\". It is precisely the \"different\" approach, in the sense that if you want both seed and separate keygen, they would have to be different \"concrete instances\", thus different labels, thus non-interoperable. And as I said above, this is all pain and no gain.\n\nCorrect, which is why it's written SHOULD, and not MUST. ",
          "createdAt": "2025-09-18T00:24:36Z",
          "updatedAt": "2025-09-18T00:24:36Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe [OUGHT TO](https://rfcs.online/rfcs/rfc6919.html#section-4)?  \n\nA SHOULD here would basically say, \"support only one of shared seed or separate unless you need to support both\".  But this seems like too low a level at which to address this question.  Does QSF-MLKEM768-P256 need to support separate keygen?  Who knows!  Who knows where it will get deployed?",
          "createdAt": "2025-09-18T00:32:13Z",
          "updatedAt": "2025-09-18T00:32:13Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> Maybe [OUGHT TO](https://rfcs.online/rfcs/rfc6919.html#section-4)?\n> \n> A SHOULD here would basically say, \"support only one of shared seed or separate unless you need to support both\". But this seems like too low a level at which to address this question. Does QSF-MLKEM768-P256 need to support separate keygen? Who knows! Who knows where it will get deployed?\n\nAt the level of the scheme this is a perfectly fine level to address this question, same as if we were discussing it for Ed25519 or RSA. It is appropriate to say 'you really SHOULD pick one, but we're not going to call you incompatible/non-compliant if you have two, we know at least one or two scenarios where that may be necessary'",
          "createdAt": "2025-09-18T00:36:46Z",
          "updatedAt": "2025-09-18T00:36:46Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Going back to this concern:\n\n> the same secret key value (eg 96 bytes, either as a seed or two keygens slapped together) will produce different public keys\n\nFailing to distinguish between key formats is a library design / higher-level protocol failure.  (Thanks to LAMPS for showing that [it's something we need to worry about](https://keymaterial.net/2025/02/19/how-not-to-format-a-private-key/).)  I agree we should do what we can here, but that could be as simple as requiring `Nseed != KEM_PQ.Ndk + KEM_T.Ndk`.",
          "createdAt": "2025-09-18T00:38:21Z",
          "updatedAt": "2025-09-18T00:38:21Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> I agree we should do what we can here, but that could be as simple as requiring `Nseed != KEM_PQ.Ndk + KEM_T.Ndk`\n\nOh that's a good idea",
          "createdAt": "2025-09-18T00:40:15Z",
          "updatedAt": "2025-09-18T00:40:15Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "> > A SHOULD here would basically say, \"support only one of shared seed or separate unless you need to support both\". But this seems like too low a level at which to address this question. Does QSF-MLKEM768-P256 need to support separate keygen? Who knows! Who knows where it will get deployed?\n> \n> At the level of the scheme this is a perfectly fine level to address this question, same as if we were discussing it for Ed25519 or RSA. It is appropriate to say 'you really SHOULD pick one, but we're not going to call you incompatible/non-compliant if you have two, we know at least one or two scenarios where that may be necessary'\n\nExcept this is unlike Ed25519 and RSA, because there are constituent algorithms involved.  Which is precisely why we have this problem.\n\nAlso, I wonder if we're talking past each other a little.  If you mean \"**Each implementation** should be shared-seed only, unless you really need to support separate\", I'm on board with that, because implementations are the right spot to think about use cases.  My problem is when you say \"**Each combination** should be one keygen only\".",
          "createdAt": "2025-09-18T00:42:30Z",
          "updatedAt": "2025-09-18T00:42:30Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> Except this is unlike Ed25519 and RSA, because there are constituent algorithms involved. Which is precisely why we have this problem.\n\nAnd yet we are designing a cryptographic scheme. Just because different signing algorithms use existing hash functions or primitives doesn't mean they are not distinguished from each other at the parameter set level, etc.\n\n\n> \"Each combination should be one keygen only\".\n\nYes, each concrete instantiation (including generic framework, kdf, prg, component algorithms) SHOULD be one keygen only, where SHOULD is to be interpreted as described in [RFC2119](https://datatracker.ietf.org/doc/rfc2119/)\n",
          "createdAt": "2025-09-18T00:55:13Z",
          "updatedAt": "2025-09-18T00:55:13Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Just because we're designing a KEM doesn't meant that it's hermetically sealed and created from scratch.  People are going to build it with the tools they have.\n\nTBH, I think if you write it that way, it's going to be [MUST (BUT WE KNOW YOU WON'T)](https://rfcs.online/rfcs/rfc6919.html#section-1).  Because everyone designing an instantiation is going to be like \"Well, I don't know if someone is going to try to do this on an HSM, maybe @FiloSottile is going to want to use a YubiKey for half of it\".",
          "createdAt": "2025-09-18T01:15:28Z",
          "updatedAt": "2025-09-18T01:15:28Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "\n> TBH, I think if you write it that way, it's going to be [MUST (BUT WE KNOW YOU WON'T)](https://rfcs.online/rfcs/rfc6919.html#section-1).\n\n```\nSHOULD   This word, or the adjective \"RECOMMENDED\", mean that there\n   may exist valid reasons in particular circumstances to ignore a\n   particular item, but the full implications must be understood and\n   carefully weighed before choosing a different course.\n```\n\nI think SHOULD is exactly appropriate here.\n",
          "createdAt": "2025-09-18T01:18:34Z",
          "updatedAt": "2025-09-18T01:18:34Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> > TBH, I think if you write it that way, it's going to be [MUST (BUT WE KNOW YOU WON'T)](https://rfcs.online/rfcs/rfc6919.html#section-1).\n> \n> ```\n> SHOULD   This word, or the adjective \"RECOMMENDED\", mean that there\n>    may exist valid reasons in particular circumstances to ignore a\n>    particular item, but the full implications must be understood and\n>    carefully weighed before choosing a different course.\n> ```\n> \n> I think SHOULD is exactly appropriate here.\n\nWhat we recommend with the SHOULD in the generics document does not say boo about what a concrete instantiation document says\u2014 this proposed text for this document says concrete instantiators SHOULD choose a single keygen, and then they may know their audience better and have more than one for a single concrete instance and use whatever keywords they like, hopefully having 'understood the full implications' and 'carefully weighed' them before doing so. ",
          "createdAt": "2025-09-18T01:25:57Z",
          "updatedAt": "2025-09-18T01:25:57Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2025-09: .  We should allow interop, but (1) have shared-seed keygen be the default and (2) put appropriate warning labels around separate keygen.",
          "createdAt": "2025-09-29T19:27:53Z",
          "updatedAt": "2025-09-29T19:27:53Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "I_kwDOMmhxws7MErJv",
      "title": "Appendix to describe pre-hashing?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/80",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "TODO"
      ],
      "body": "In scenarios where encapsulation keys and ciphertexts are reused for multiple decapsulation operations, it can be improve the performance of decapsulation operations to have a combiner that pre-hashes these values and a stateful algorithm that caches the pre-hashed values.  This was the basis for the Chempat and PRE hybrid KEMs that have been discussed.\n\nFeedback at the CFRG meeting at IETF 123 and subsequent mailing list discussion indicated that these use cases are not a priority for the CFRG community, and thus that the additional complexity of pre-hashing doesn't make sense for the main body of the document.  There was also concern that the introduction of extra hashes took us further from the constructions that have been validated in the literature, though it was proposed on the mailing list that there might be easy indifferentiability arguments to connect the pre-hashed variants with their non-pre-hashed analogues.\n\nIf the latter argument could be fleshed out and made precise, we could add an appendix to the document that describes variants of the main hybrid KEM framework that provide pre-hashing, which applications could use if the key/ciphertext reuse cases are important to them.  I would propose the following outline for the content of this section\n\n* Review of use cases in which pre-hashing can make a performance difference\n* Combinator functions:\n    * Pre-hash CT: `KDF(concat(ss_PQ, ss_T, H(ct_PQ, ct_T), ek_PQ, ek_T, label))`\n    * Pre-hash PK: `KDF(concat(ss_PQ, ss_T, ct_PQ, ct_T, H(ek_PQ, ek_T), label))`\n    * Pre-hash both: `KDF(concat(ss_PQ, ss_T, H(ct_PQ, ct_T), H(ek_PQ, ek_T), label))`\n* Security analysis\n    * Requirements for the pre-hashing function H\n    * Indifferentiability arguments for the security of the pre-hashed constructions\n    * Label MUST be different from non-pre-hashed variant with the same constituents\n\nBut we should only do this if enough folks are interested to merit it.",
      "createdAt": "2025-09-16T21:16:18Z",
      "updatedAt": "2025-10-20T21:43:10Z",
      "closedAt": "2025-10-20T21:43:10Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2025-09: No, we should not actually specify it.  At most, we could mention it in our \u201cpaths not taken\u201d section.",
          "createdAt": "2025-09-29T19:27:18Z",
          "updatedAt": "2025-09-29T19:27:18Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "We currently do not mention it at all nor other paths not taken\n",
          "createdAt": "2025-10-20T21:42:27Z",
          "updatedAt": "2025-10-20T21:42:27Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "I_kwDOMmhxws7MFCoI",
      "title": "IANA registry for labels?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/81",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "The `label` input to the KDFs is intended to distinguish different instances of the hybrid KEM framework.  Right now, this is a free text field, which means there's a risk that different implementations might choose the same label, removing the desired separation.  It might be good to be a little more structured about labels to reduce the risk of such collisions.\n\nThe maximally structured approach would be to do something like HPKE: Assign unique identifiers to the constituent components (KEMs, KDF, etc.) and encode that into a standard label.  That has a couple of drawbacks: You need to manage registries of constituent components, and forcing everything to use a standard label would prevent backward compatibility with X-Wing.\n\nIt seems to me that there are a couple of options here.  They all involve an IANA registry (the standard IETF technology for collision avoidance), the question is what goes in the registry and how we accommodate X-Wing as a legacy case.\n\n| Label | T component | PQ component | KDF | ... |\n|-------|-----|-----|-----|-----|\n|  ??? | X25519 | ML-KEM-768 | SHAKE256 | ... |\n|  ??? | RSA-1024 | HQC | HKDF-SHA-256 | ... |\n\n* **Labels are strings:** Labels is any string chosen by the person that registers the combination.  We might recommend a default construction (e.g., concatenating names as we have done [in the concrete doc](https://github.com/cfrg/draft-irtf-cfrg-concrete-hybrid-kems/blob/main/draft-irtf-cfrg-concrete-hybrid-kems.md#qsf-mlkem768-p256-sha3256-shake256-qsf-p256))  This would directly accommodate X-Wing by registering its label string for the appropriate combination.\n\n* **Labels are integers:** Label is an integer selected by IANA at registration time (since all we need for domain separation is a few distinct bits).  There would have to be some convention for how this integer was translated to a byte string, e.g., a varint encoding.  X-Wing would be an explicit legacy case.\n\nSo the questions for feedback are:\n\n1. Should we bother with an IANA registry here at all?\n2. If so, should we use strings or integers?\n\nPersonally, my take is (1) yes, and (2) strings.  Having a clear conflict avoidance story seems worth the overhead of maintaining a registry.  Integers don't save you anything over strings (unless the strings are huge and cause extra hash iterations, which is avoidable), and it's simpler to describe both how they plug into the KDF and how they accommodate X-Wing.",
      "createdAt": "2025-09-16T22:00:50Z",
      "updatedAt": "2025-09-29T18:50:13Z",
      "closedAt": "2025-09-29T18:50:13Z",
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree on yes; strings. Nit: perhaps the strings should (also) be represented in hex for clarity?",
          "createdAt": "2025-09-17T09:45:46Z",
          "updatedAt": "2025-09-17T09:45:46Z"
        },
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "Apologies for a basic question, but what would be involved in an IANA registry? Is the process simple or time-consuming?",
          "createdAt": "2025-09-26T16:46:21Z",
          "updatedAt": "2025-09-26T16:46:21Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "To create the registry, we would just include a section in this document.\r\n\r\nTo register a new value \u2014 we can decide how much work we want to make it\r\n(by setting the policy for the registry in this document).  The simplest\r\nwould be \u201cFirst come first served\u201d, in which case registering a new value\r\njust requires sending email to IANA.  The next level up would be\r\n\u201cSpecification Required\u201d, to which you have to publish some spec (like an\r\nInternet draft) and send email to IANA, which then gets reviewed by some\r\npeople designated by CFRG.  For example, Chris Wood and I are the reviewers\r\nfor the HPKE registries.\r\n\r\nEither way, IANA does the work of actually putting stuff in the registry\r\nand publishing it.\r\n\r\nI think we definitely don\u2019t need anything more than Specification Required\r\nhere, and might be fine with FCFS, especially if we go with strings.\r\n\r\n\r\nOn Fri, Sep 26, 2025 at 06:46 Paul Grubbs ***@***.***> wrote:\r\n\r\n> *pag-crypto* left a comment (cfrg/draft-irtf-cfrg-hybrid-kems#81)\r\n> <https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/81#issuecomment-3339577516>\r\n>\r\n> Apologies for a basic question, but what would be involved in an IANA\r\n> registry? Is the process simple or time-consuming?\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/81#issuecomment-3339577516>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAASOTLCZTWWDNT4JQOAT2D3UVUXHAVCNFSM6AAAAACGWHFRA6VHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZTGMZZGU3TONJRGY>\r\n> .\r\n> You are receiving this because you authored the thread.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2025-09-26T20:57:44Z",
          "updatedAt": "2025-09-26T20:57:44Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "I_kwDOMmhxws7OlUpx",
      "title": "Names:  GK, GM, KK, KM",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/83",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Isn't X the same as K; so wouldn't GK, GM, KK, KM make more sense?",
      "createdAt": "2025-09-29T17:16:39Z",
      "updatedAt": "2025-10-20T22:21:27Z",
      "closedAt": "2025-10-20T22:21:27Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see how \"X is the same as K\" follows.  And \"KK\" has some unfortunate resonances.",
          "createdAt": "2025-09-29T19:26:33Z",
          "updatedAt": "2025-09-29T19:26:33Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "I think moot for now",
          "createdAt": "2025-10-20T22:21:27Z",
          "updatedAt": "2025-10-20T22:21:27Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "I_kwDOMmhxws7Pm4th",
      "title": "Comments from Chris Patton",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/84",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/cfrg/SsuoZgdaZGqUwS1Sn6Q6L7QzqvY/\n\n- I ended up combining the PRG and KDF APIs into a single trait that was more convenient for defining the KEMs.\n- I ended up combining Nseed, Nss, and Nout into one variable. I suspect most of the time these will all always be the same, though perhaps not for larger than usual elliptic curves.\n- Rather than rederive the encapsulation key during decapsulation, I just stored the encapsulation key in the decapsulation key. My guess is that implementations would do this most of the time.\n- Section 3: It seems like `GenerateKeyPair()` is there just for convenience. I would get rid of it and just explain that `DeriveKeyPair()` needs a (pseudo)random input.\n- Section 3: The draft uses `random()` for samping random bytes strings and the more academic $x \\getsr \\bits^n$ for sampling bit strings. I would go with just one of these.\n- Section 4.2: `DeriveScalar(seed)` would be more consistent than `RandomScalar(seed)`.\n- Section 4.3: The first paragraph calls the function `G`, but the rest of the document uses `PRG`.\n- nit: I like `Combine()` as the name for the combiner function rather than `Combine()`. This aligns grammatically better with the rest of the API in the doc.\n- nit: Perhaps drop \"PQ\" from \"PQImplicit\". I understand \"explicit\" to mean \"explicitly hash the PQ ciphertext and encapsulation key\", in which case \"PQ\" is a little redundant.",
      "createdAt": "2025-10-04T02:29:31Z",
      "updatedAt": "2025-10-04T02:29:31Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 86,
      "id": "I_kwDOMmhxws7SA1lq",
      "title": "Be consistent about backticks",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/86",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Right now, we are not consistent about which words go in `verbatim` backtics.  The current document is mixed (`Encaps()`, but not `DeriveKeyPair`).  We should be consistent here.\n\nMy usual policy is to reserve backticks for words that start lower-case (so `derive_key_pair` but not `DeriveKeyPair`), since there's more risk of ambiguity there.  But I would be open to verbatim-izing more things if folks prefer.",
      "createdAt": "2025-10-16T20:35:45Z",
      "updatedAt": "2025-10-20T22:37:48Z",
      "closedAt": "2025-10-20T22:37:48Z",
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah I traditionally `backtick` any function names ",
          "createdAt": "2025-10-20T21:37:52Z",
          "updatedAt": "2025-10-20T21:37:52Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Feel free to implement it either way, I don't really care.",
          "createdAt": "2025-10-20T21:49:58Z",
          "updatedAt": "2025-10-20T21:49:58Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "I_kwDOMmhxws7SA5tr",
      "title": "Naming of combiners",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/87",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In #85, the two combiner functions are Universal and C2PRI.  Are there other names that would be better?\n\n* Basic / C2PRI\n* \"Any PQ KEM\" / \"Only C2PRI PQ KEM\" (would need to figure out how to make into labels)\n",
      "createdAt": "2025-10-16T20:41:43Z",
      "updatedAt": "2025-10-16T20:41:43Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 88,
      "id": "I_kwDOMmhxws7SA9xu",
      "title": "DeriveKeyPair: (ek, dk) or (dk, ek)?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/88",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "`Encaps()` returns the secret output first, `(ss, ct)`.  `DeriveKeyPair` should do the same thing.",
      "createdAt": "2025-10-16T20:48:31Z",
      "updatedAt": "2025-11-02T21:15:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Along similar lines, look at whether `concat` is on its own line or inline.  I think \"own line\" is probably a little clearer, because you get to give a name to the compound thing.",
          "createdAt": "2025-10-16T20:49:56Z",
          "updatedAt": "2025-10-16T20:49:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Along similar lines, maybe suffix the subruotines with `_KEM` and `_Group` instead of `K`/`G`.",
          "createdAt": "2025-10-16T20:55:22Z",
          "updatedAt": "2025-10-16T20:55:22Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "I favor (dk, ek)",
          "createdAt": "2025-10-20T21:36:37Z",
          "updatedAt": "2025-10-20T21:36:37Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we resolved this\n",
          "createdAt": "2025-11-02T21:15:09Z",
          "updatedAt": "2025-11-02T21:15:09Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOMmhxws6G-GIs",
      "title": "Fix build and references",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/1",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-01-07T18:01:15Z",
      "updatedAt": "2025-01-08T04:15:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "8f18831dc6e7d2b4cbe13e809c0481aa350625e6",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/fix-refs",
      "headRefOid": "f795b47e09e04f14fc9afae5b8591ec55dd4fd58",
      "closedAt": "2025-01-08T04:15:08Z",
      "mergedAt": "2025-01-08T04:15:08Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "503214de9161bbabeb9ffeb76d24596d8af66752"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6XJ7HM",
          "commit": {
            "abbreviatedOid": "f795b47"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-01-08T04:14:54Z",
          "updatedAt": "2025-01-08T04:14:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 2,
      "id": "PR_kwDOMmhxws6HIQRB",
      "title": "Refactor, cleanup, reorganize",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/2",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This change refactors some stuff and cleans up the in-lined KEM implementation details.",
      "createdAt": "2025-01-08T21:24:34Z",
      "updatedAt": "2025-01-23T18:47:30Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ea0a9337871b8f52777783e10780d40f21b6ca14",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/reorg",
      "headRefOid": "75a1f6564a51ae64ddb2ae86cb25355a8997b705",
      "closedAt": "2025-01-23T18:47:30Z",
      "mergedAt": "2025-01-23T18:47:30Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "5557ce637cb791f95f09cf3271ec5623825047b1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6XcYyA",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-09T19:48:22Z",
          "updatedAt": "2025-01-09T19:48:23Z",
          "comments": [
            {
              "originalPosition": 477,
              "body": "\ud83d\udc4d",
              "createdAt": "2025-01-09T19:48:22Z",
              "updatedAt": "2025-01-09T19:48:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOLdI",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:01:46Z",
          "updatedAt": "2025-01-23T18:01:47Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "```suggestion\r\n- `EncapsDerand(pk, randomness) -> (ct, shared_secret)`: A deterministic encapsulation\r\n   algorithm, which takes as input a public encapsulation key `pk` and randomness\r\n   `randomness`, and outputs a ciphertext `ct` and shared secret `shared_secret`.\r\n```",
              "createdAt": "2025-01-23T18:01:46Z",
              "updatedAt": "2025-01-23T18:01:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOMAE",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:02:53Z",
          "updatedAt": "2025-01-23T18:02:53Z",
          "comments": [
            {
              "originalPosition": 610,
              "body": "```suggestion\r\ndef EncapsDerand(pk, randomness):\r\n  pq_PK = pk[0:1184]\r\n  trad_PK = pk[1184:1217]\r\n  (pq_SS, pq_CT) = ML-KEM-768.EncapsDerand(pq_PK, randomness[0:32])\r\n  ek = randomness[32:65]\r\n  trad_CT = P-256.ScalarMultBase(ek)\r\n  trad_SS = P-256.ScalarMult(ek, trad_PK)\r\n  ss = SHA3-256(pq_SS, trad_SS, trad_CT, trad_PK, label)\r\n  ct = concat(pq_CT, trad_CT)\r\n```",
              "createdAt": "2025-01-23T18:02:53Z",
              "updatedAt": "2025-01-23T18:02:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOMGw",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:03:05Z",
          "updatedAt": "2025-01-23T18:03:06Z",
          "comments": [
            {
              "originalPosition": 619,
              "body": "```suggestion\r\nNote that `randomness` MUST be 65 bytes.\r\n```",
              "createdAt": "2025-01-23T18:03:05Z",
              "updatedAt": "2025-01-23T18:03:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOMoP",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:04:11Z",
          "updatedAt": "2025-01-23T18:04:12Z",
          "comments": [
            {
              "originalPosition": 864,
              "body": "```suggestion\r\ndef EncapsDerand(pk, randomness):\r\n  pq_PK = pk[0:1184]\r\n  trad_PK = pk[1184:1216]\r\n  (pq_SS, pq_CT) = PQ-KEM.EncapsDerand(pq_PK, randomness[0:32])\r\n  ek = randomness[32:64]\r\n```",
              "createdAt": "2025-01-23T18:04:11Z",
              "updatedAt": "2025-01-23T18:04:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZONxs",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:06:33Z",
          "updatedAt": "2025-01-23T18:06:34Z",
          "comments": [
            {
              "originalPosition": 877,
              "body": "```suggestion\r\nNote that `randomness` MUST be 64 bytes.\r\n```",
              "createdAt": "2025-01-23T18:06:33Z",
              "updatedAt": "2025-01-23T18:06:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOPiO",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:10:14Z",
          "updatedAt": "2025-01-23T18:10:14Z",
          "comments": [
            {
              "originalPosition": 1161,
              "body": "```suggestion\r\ndef EncapsDerand(pk, randomness):\r\n  pq_PK = pk[0:1568]\r\n  trad_PK = pk[1568:1629]\r\n  (pq_SS, pq_CT) = ML-KEM-1024.EncapsDerand(pq_PK, randomness[0:32])\r\n  ek = randomness[32:80]\r\n  trad_CT = P-384.ScalarMultBase(ek)\r\n  trad_SS = P-384.ScalarMult(ek, trad_PK)\r\n  ss = SHA3-256(pq_SS, trad_SS, trad_CT, trad_PK, label)\r\n  ct = concat(pq_CT, trad_CT)\r\n```",
              "createdAt": "2025-01-23T18:10:14Z",
              "updatedAt": "2025-01-23T18:10:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOPoo",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:10:28Z",
          "updatedAt": "2025-01-23T18:10:28Z",
          "comments": [
            {
              "originalPosition": 1170,
              "body": "```suggestion\r\nNote that `randomness` MUST be 80 bytes.\r\n```",
              "createdAt": "2025-01-23T18:10:28Z",
              "updatedAt": "2025-01-23T18:10:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOk4A",
          "commit": {
            "abbreviatedOid": "75a1f65"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-01-23T18:46:24Z",
          "updatedAt": "2025-01-23T18:46:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 3,
      "id": "PR_kwDOMmhxws6I0Zg9",
      "title": "Preliminary reference implementations and test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/3",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This mirrors the spec implementation for X-Wing, but it uses Sage for the NIST curve implementation. (Primarily because I had that laying around from other specs. We can replace with a Python implementation in the future if desired.) It fixes some things in the primary spec around key generation (formatting keys as byte strings), fully specifying the DH operations, etc. It also includes preliminary HPKE KEM codepoint registration requests. And, importantly, adds the test vectors produced from the reference implementation.",
      "createdAt": "2025-01-23T21:30:19Z",
      "updatedAt": "2025-02-03T18:44:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "5557ce637cb791f95f09cf3271ec5623825047b1",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/vectors",
      "headRefOid": "9771afd2307ec7032d8d6e8298849e06017c0264",
      "closedAt": "2025-02-03T18:44:49Z",
      "mergedAt": "2025-02-03T18:44:49Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "2f0ea74c9e3e93b7dd4fbd3f0c33fb76256e6fef"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@dconnolly I added a `ScalarFromBytes` function, distinct from `DeserializeScalar`, as an infallible constructor that takes bytes and produces `Scalar` values, with an implementation that matches the reference code under the hood. Please take another look!",
          "createdAt": "2025-02-03T17:35:02Z",
          "updatedAt": "2025-02-03T17:35:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6aOQeU",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\ud83d\ude4f",
          "createdAt": "2025-01-31T17:50:01Z",
          "updatedAt": "2025-01-31T17:50:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6aOT4_",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-31T17:52:25Z",
          "updatedAt": "2025-01-31T17:52:25Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "`%` needs defining above",
              "createdAt": "2025-01-31T17:52:25Z",
              "updatedAt": "2025-01-31T17:52:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6aOXz0",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-31T17:55:37Z",
          "updatedAt": "2025-01-31T17:55:37Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "We could leverage the text above about `Scalar`s and `Element`s to enforce that all instances of `Scalar`s MUST be modulo their order, otherwise they aren't real `Scalar`s ",
              "createdAt": "2025-01-31T17:55:37Z",
              "updatedAt": "2025-01-31T17:55:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6aOYml",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Do we want to enforce the `Scalar` being always modulo its `Order()` via its instantiation? Otherwise we need to define `%` as used in `expandDecapsulationKey` etc",
          "createdAt": "2025-01-31T17:57:13Z",
          "updatedAt": "2025-01-31T17:57:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6aaI9p",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-03T17:11:55Z",
          "updatedAt": "2025-02-03T17:11:55Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "That's a cleaner way to handle this. I'll update the textual description of Scalar to include something about mapping from bytes, and say that the bytes are reduced modulo the order, or something.",
              "createdAt": "2025-02-03T17:11:55Z",
              "updatedAt": "2025-02-03T17:11:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6aa29j",
          "commit": {
            "abbreviatedOid": "9771afd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-03T18:44:32Z",
          "updatedAt": "2025-02-03T18:44:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOMmhxws6MFI2K",
      "title": "Update labels to include XOF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/5",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hopefully these labels are not too terrible on the eyes \ud83e\udd37 \r\n\r\nCloses #4.",
      "createdAt": "2025-02-21T17:19:15Z",
      "updatedAt": "2025-02-25T17:22:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "a1093192626f720d448880692a5d8b258fbf783c",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/update-labels",
      "headRefOid": "9abc6fcfb262e42878b0b67cece04cec09bba491",
      "closedAt": "2025-02-25T17:22:49Z",
      "mergedAt": "2025-02-25T17:22:49Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "10867607a87847ff4d9e03029dcfcd4117b83620"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6dAy3d",
          "commit": {
            "abbreviatedOid": "a7175ff"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T21:14:24Z",
          "updatedAt": "2025-02-21T21:14:24Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\n2. `KitchenSink-KEM(ML-KEM-768,X25519)-XOF(SHAKE256)-KDF(HKDF-SHA-256)` {{ks-x25519}}:\r\n```\r\n\r\nHm I worry about a comma in a label like this, have we done this in other i*tf crypto protocols? Is it fine in practice?",
              "createdAt": "2025-02-21T21:14:24Z",
              "updatedAt": "2025-02-21T21:14:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6deCz8",
          "commit": {
            "abbreviatedOid": "a7175ff"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-25T17:21:26Z",
          "updatedAt": "2025-02-25T17:21:27Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "merging for now, but may want to keep an eye on it",
              "createdAt": "2025-02-25T17:21:27Z",
              "updatedAt": "2025-02-25T17:21:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOMmhxws6MGGlY",
      "title": "Add generic keygen and derivation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/6",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@chris-wood wdyt of the attempt at including slicing of the XOF output into the bytes that go into each component algorithm? \ud83d\ude05",
      "createdAt": "2025-02-21T19:50:44Z",
      "updatedAt": "2025-02-25T17:20:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "f50c9557531cb1237d8be28871842f6fa8675134",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "generic-keygen",
      "headRefOid": "9fcef57ff286640cf383b48579c201ecec104507",
      "closedAt": "2025-02-25T17:20:28Z",
      "mergedAt": "2025-02-25T17:20:28Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "a1093192626f720d448880692a5d8b258fbf783c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6dASs8",
          "commit": {
            "abbreviatedOid": "d76eae8"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T19:57:03Z",
          "updatedAt": "2025-02-21T19:57:11Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Maybe we replace `Nxofout` with `Npqseed + Ntradseed`? I think the `expanded[..Npqseed]` is fairly clear, but we should probably add some text to the terminology section that describes how it works. Something like:\r\n\r\n```\r\nWhen `x` is a byte string, we use the notation `x[..i]` and `x[i..]` to denote the slice of bytes in `x` starting from the beginning of `x` and leading up to index `i`, including the `i`-th byte, and the slice the bytes in `x` starting from index `i` to the end of `x`, respectively. For example, if `x = [0, 1, 2, 3]`, then `x[..2] = [0, 1]` and `x[2..] = [2, 3]`.\r\n```",
              "createdAt": "2025-02-21T19:57:03Z",
              "updatedAt": "2025-02-21T19:57:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6dAzLR",
          "commit": {
            "abbreviatedOid": "d76eae8"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T21:15:08Z",
          "updatedAt": "2025-02-21T21:15:08Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done; can you cross check the numbers for Ntradseed for the p256 and p384 instances?",
              "createdAt": "2025-02-21T21:15:08Z",
              "updatedAt": "2025-02-21T21:15:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6deB_p",
          "commit": {
            "abbreviatedOid": "9fcef57"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-25T17:20:13Z",
          "updatedAt": "2025-02-25T17:20:13Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "confirmed out of bad - they are larger than expected  to make sure the Scalar isn't biased (not a power of 2), these match HashToCurve",
              "createdAt": "2025-02-25T17:20:13Z",
              "updatedAt": "2025-02-25T17:20:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 9,
      "id": "PR_kwDOMmhxws6N0rBY",
      "title": "Clarify concatenation operations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/9",
      "state": "CLOSED",
      "author": "bluegate010",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Clarify that SHA3-256 takes one input which is a concatenation of multiple values.",
      "createdAt": "2025-03-07T20:30:38Z",
      "updatedAt": "2025-05-29T22:03:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ca4807c8b1249830e36a18dbc8b218087eb7bcb8",
      "headRepository": "bluegate010/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "patch-1",
      "headRefOid": "ec575c84b83fe47edd02460667e9e1eda3cc561b",
      "closedAt": "2025-05-29T22:03:37Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "We can clarify this concatenation to match the generic QSF construction more closely using the explicit `concat()` routine described earlier ",
          "createdAt": "2025-03-07T20:33:31Z",
          "updatedAt": "2025-03-07T20:33:31Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "Opened https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/10 for this ",
          "createdAt": "2025-03-07T20:35:50Z",
          "updatedAt": "2025-03-07T20:35:50Z"
        },
        {
          "author": "bluegate010",
          "authorAssociation": "NONE",
          "body": "> We can clarify this concatenation to match the generic QSF construction more closely using the explicit `concat()` routine described earlier\r\n\r\nGot it, have made this adjustment.",
          "createdAt": "2025-03-07T21:01:07Z",
          "updatedAt": "2025-03-07T21:01:07Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by events",
          "createdAt": "2025-05-29T22:03:37Z",
          "updatedAt": "2025-05-29T22:03:37Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOMmhxws6N01c3",
      "title": "Make trad_PK consistently a serialized byte array.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/12",
      "state": "CLOSED",
      "author": "bluegate010",
      "authorAssociation": "NONE",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Resolves https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/11",
      "createdAt": "2025-03-07T20:55:55Z",
      "updatedAt": "2025-05-29T22:03:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ca4807c8b1249830e36a18dbc8b218087eb7bcb8",
      "headRepository": "bluegate010/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "trad_PK",
      "headRefOid": "96dac879d6c53b62e542a06d902b46db8666e6ab",
      "closedAt": "2025-05-29T22:03:18Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by events.",
          "createdAt": "2025-05-29T22:03:18Z",
          "updatedAt": "2025-05-29T22:03:18Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 15,
      "id": "PR_kwDOMmhxws6UNmZE",
      "title": "Remove concrete instantiations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/15",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR removes the following content from this document:\r\n\r\n* The sections defining concrete combiners\r\n* The test vectors section\r\n* The IANA considerations section\r\n* Mentions of specific combinations in the prose\r\n\r\nMost of this text should be moved to the concrete document (https://github.com/cfrg/draft-irtf-cfrg-concrete-hybrid-kems/pull/1).  The only exception is the IANA considerations section, which should be handled by the HPKE WG.",
      "createdAt": "2025-04-28T18:26:12Z",
      "updatedAt": "2025-05-01T14:47:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ca4807c8b1249830e36a18dbc8b218087eb7bcb8",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "no-concrete",
      "headRefOid": "b7fbef939decc1ce486dabe8a60147f4a846fefd",
      "closedAt": "2025-05-01T14:47:40Z",
      "mergedAt": "2025-05-01T14:47:39Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "55400d76088569aad2bffda3dc1aca2ad5095cde"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6nfIH5",
          "commit": {
            "abbreviatedOid": "b7fbef9"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-01T14:47:33Z",
          "updatedAt": "2025-05-01T14:47:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOMmhxws6VGG6-",
      "title": "Refactor KEM Constructions section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/17",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The basic proposal here is to refactor the Hybrid KEM Constructions section so that:\r\n\r\n* It more clearly addresses the whole definition of the hybrid KEM (including all the specified methods)\r\n* It includes a slightly broader range of options (Chempat-like, TLS-like)\r\n\r\nThe current text is just a sketch; it needs to be turned into actual prose.  But it should give a pretty clear idea of the intended direction.",
      "createdAt": "2025-05-06T12:03:54Z",
      "updatedAt": "2025-05-22T14:03:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "55400d76088569aad2bffda3dc1aca2ad5095cde",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "draft-text",
      "headRefOid": "b774ed6c28b8d6a8d7a23a9ae36aaaae5b5efb25",
      "closedAt": "2025-05-22T14:03:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Replaced by #19 ",
          "createdAt": "2025-05-22T14:03:27Z",
          "updatedAt": "2025-05-22T14:03:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6oNUv0",
          "commit": {
            "abbreviatedOid": "b774ed6"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-07T14:46:08Z",
          "updatedAt": "2025-05-07T17:28:00Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "* Treat Generate-only as an exception case; default assumption is DeriveKeyPair\r\n* RSA for example is missing DKP, though in principle it could be defined",
              "createdAt": "2025-05-07T14:46:08Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 50,
              "body": "TODO: Make sure that we have all the security properties we need for this.\r\n\r\n* SHAKE calls it the \"flat sponge property\" -- capacity is 2x security level.\r\n* Might need to be a dual PRF for some definition?\r\n* Might not be if we use a different tool (KDF) for the combiners.\r\n\r\nTODO: Re-add / maintain that distinction (XOF + KDF)",
              "createdAt": "2025-05-07T14:52:16Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 83,
              "body": "* Having seed expansion makes it hard to manipulate seeds\r\n* Should be `Nseed = max(KEM_T.Nseed, KEM_PQ.Nseed)` ?\r\n* In concept, 2x security level (would need to state the security level)\r\n    * Might have a birthday collision issue?\r\n    * Could lead to generating shorter secrets from longer secrets at the higher security level",
              "createdAt": "2025-05-07T15:03:45Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 86,
              "body": "* Might not be natural for CT to be fixed size in some case\r\n* Only implication to variable length would be length prefixes in combiners\r\n* Assume fixed size for now, let people push back on it\r\n* Fall-back: Document how you could fit a variable-size values",
              "createdAt": "2025-05-07T15:12:13Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 77,
              "body": "* Could start with one label field, then build a structured label that has (construction + app)\r\n* Having a single label field can get the discussion started in the WG about why people want labels\r\n* Might call it a \"context\" if provided by the app\r\n* Some KEMs (e.g., ML-KEM) have a context input, could reflect in KEM API, probably not worthwhile",
              "createdAt": "2025-05-07T15:21:31Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 180,
              "body": "* Might need some additional assumptions on the KEMs to get here.\r\n* Why does it work with X25519 and ML-KEM?\r\n",
              "createdAt": "2025-05-07T15:36:04Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 180,
              "body": "cc @bwesterb ",
              "createdAt": "2025-05-07T15:36:21Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 18,
      "id": "PR_kwDOMmhxws6VpV7t",
      "title": "Several editorial changes and rewrites",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/18",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR makes several primarily editorial changes, in preparation for the more significant edits to the combiners and security properties sections.\r\n\r\n* (pk, sk) -> (ek, dk)\r\n* New text in the abstract and introduction\r\n* Removes a couple of unnecessary function definitions\r\n* Clean up in the definition of the KEM interface\r\n* Rewrote the DH section as a KEM-to-DH construction\r\n\r\nThe last change is the most substantial one.  The current combiner constructions make explicit reference to the DH functions of the T algorithm.  The idea of this rewrite is to handle both the PQ and T algorithms through the KEM interface.  \r\n\r\nHandling both algorithms through the same interface is aesthetically nicer, since things will be more parallel, but could also allow for non-DH options like RSA.  At least in principle; I would object to actually spending words on such a possibility in this document.  In fact, I'm not totally sure we need to have the DH KEM construction in the main text, as opposed to having it in an appendix that is referred to as necessary.  (I also thought about moving it to the concrete combiners document, but it seems generic enough and useful enough as a motivator to be included here.)\r\n\r\nI'm not sure why `includes.mk` got deleted.  I presume it was was something in the tooling; I didn't do it deliberately.",
      "createdAt": "2025-05-09T22:09:06Z",
      "updatedAt": "2025-05-27T21:26:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "55400d76088569aad2bffda3dc1aca2ad5095cde",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "edit-pass",
      "headRefOid": "37bda778108e222e735cd5f1f630da10a421c730",
      "closedAt": "2025-05-22T14:56:21Z",
      "mergedAt": "2025-05-22T14:56:21Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "9e85013a9da7226a2e54c098de0ab5043034a158"
      },
      "comments": [
        {
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for this revision. I think it looks largely good (a few comments added). I similarly would recommend punting description of RSA. For DH, I think it depends on whether the concrete options will be DH-based or DHKEM-based. The latter can be generalized for KEM, but we talked about efficiencies of the former. It would see odd to have a concrete document that uses DH instead of DHKEM, if the generalism is all KEM-based or DH doesn't feature heavily. So I am somewhat inclined to have the DH discussion fairly prominent.",
          "createdAt": "2025-05-10T20:22:47Z",
          "updatedAt": "2025-05-10T20:22:47Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed on authors call, will revert the IND-CPA DH section back to an explicit group section.\r\n\r\nAlso @dconnolly sorry I missed your comments here, will address them in the next round.",
          "createdAt": "2025-05-22T14:57:44Z",
          "updatedAt": "2025-05-22T14:57:44Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6ovoVv",
          "commit": {
            "abbreviatedOid": "e20cca7"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-10T20:14:33Z",
          "updatedAt": "2025-05-10T20:14:34Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I recommend that we avoid \"timed\" statements in the draft that might not age well. This can be changed to:\r\n\r\nPost-quantum (PQ) algorithms offer a redesign of traditional algorithms tailored towards resisting attack from a quantum computer. Key Encapsulation Mechanisms (KEMs), are a standardized algorithm type that can be used to build protocols in lieu of traditional, quantum-vulnerable variants such as Diffie-Hellman (DH) based protocols. Given the novelty of PQ algorithms, however....",
              "createdAt": "2025-05-10T20:14:33Z",
              "updatedAt": "2025-05-10T20:14:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQnn8",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T10:49:19Z",
          "updatedAt": "2025-05-14T10:49:20Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Feel free to ignore this stylistic blabbering: personally I like to write \"post-quantum algorithms are designed to resist attack of quantum computers\". Then we don't need any qualifications like \"promise\" or \"believe to\" etc. Of course it's not completely true: several schemes were first designed before quantum computers were known about.",
              "createdAt": "2025-05-14T10:49:19Z",
              "updatedAt": "2025-05-14T10:49:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQqh5",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T10:53:16Z",
          "updatedAt": "2025-05-14T10:53:17Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "There are two more affordances of hybrids\u2014not sure we should go into that now.\r\n\r\n1. You can satisfy an old policy (or expectation) while already adopting PQ.\r\n2. You protect against implementation mistakes. (Say, using a hybrid we protect against a say timing-based active attack in either component.\r\n",
              "createdAt": "2025-05-14T10:53:16Z",
              "updatedAt": "2025-05-14T10:53:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQrRn",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T10:54:20Z",
          "updatedAt": "2025-05-14T10:54:21Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "`brken` typo",
              "createdAt": "2025-05-14T10:54:21Z",
              "updatedAt": "2025-05-14T10:54:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQwCU",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T11:00:44Z",
          "updatedAt": "2025-05-14T11:00:45Z",
          "comments": [
            {
              "originalPosition": 277,
              "body": "IND-CCA and IND-CPA might be meaningless to the reader at this point. What about the following\r\n\r\n> This KEM is not secure against active attack (not IND-CCA).",
              "createdAt": "2025-05-14T11:00:44Z",
              "updatedAt": "2025-05-14T11:00:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQ6Zp",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T11:14:42Z",
          "updatedAt": "2025-05-14T11:14:43Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "I know it makes sense to define the IND-CPA KEM like this, but I'm worried that once it's defined, it's very tempting for implementors to put it in the KEM slot and have it available to users, which do not understand warnings such as \"this is only IND-CPA\".\r\n\r\nNot assigning a code points helps, but maybe we can do more.\r\n\r\nIdeally we'd make the interface of a component incompatible with a proper KEM, but I don't see any non-artificial way to do that.\r\n\r\nDifferent naming only goes so far: I think *Component* or say *PreKEM* would be better.\r\n",
              "createdAt": "2025-05-14T11:14:42Z",
              "updatedAt": "2025-05-14T11:14:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQ7DH",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T11:15:46Z",
          "updatedAt": "2025-05-14T11:15:47Z",
          "comments": [
            {
              "originalPosition": 392,
              "body": "This is breaking abstraction.",
              "createdAt": "2025-05-14T11:15:46Z",
              "updatedAt": "2025-05-14T11:15:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQ8Pv",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-14T11:17:42Z",
          "updatedAt": "2025-05-14T11:17:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6pQ8r8",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T11:18:28Z",
          "updatedAt": "2025-05-14T11:18:28Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Typo",
              "createdAt": "2025-05-14T11:18:28Z",
              "updatedAt": "2025-05-14T11:18:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6psmmU",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-16T15:55:48Z",
          "updatedAt": "2025-05-16T15:55:48Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Added a couple of sentences to this effect in the Introduction.",
              "createdAt": "2025-05-16T15:55:48Z",
              "updatedAt": "2025-05-16T15:55:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6psr9D",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-16T16:05:45Z",
          "updatedAt": "2025-05-16T16:05:45Z",
          "comments": [
            {
              "originalPosition": 277,
              "body": "Reworded this to be more reader-friendly, and provide a forward pointer to the security considerations.",
              "createdAt": "2025-05-16T16:05:45Z",
              "updatedAt": "2025-05-16T16:05:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pss52",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-16T16:07:31Z",
          "updatedAt": "2025-05-16T16:07:31Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "I added some text that explicitly says \"This KEM should not be used on its own.\"  Unfortunately the \ud83d\udea8 emoji isn't allowed in RFCs.",
              "createdAt": "2025-05-16T16:07:31Z",
              "updatedAt": "2025-05-16T16:07:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pstwr",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-16T16:09:15Z",
          "updatedAt": "2025-05-16T16:09:24Z",
          "comments": [
            {
              "originalPosition": 392,
              "body": "Yep, this will get fixed in the next PR.  The only reason this part is getting touched is the global `(sk, pk) -> (dk, ek)` terminology change.",
              "createdAt": "2025-05-16T16:09:15Z",
              "updatedAt": "2025-05-16T16:09:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdlcX",
          "commit": {
            "abbreviatedOid": "6791b79"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:00:09Z",
          "updatedAt": "2025-05-22T06:00:10Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nsecurity against quantum attack. In this document, we define constructions for\r\nhybrid Key Encapsulation Mechanisms (KEMs) based on combining a traditional KEM\r\nand a PQ KEM. Hybrid KEMs using these constructions provide strong security\r\nproperties as long as the undelying algorithms are secure.\r\n```",
              "createdAt": "2025-05-22T06:00:09Z",
              "updatedAt": "2025-05-22T06:00:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdlzu",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:01:02Z",
          "updatedAt": "2025-05-22T06:01:03Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "```suggestion\r\nPost-quantum (PQ) algorithms offer new constructions based on problems tailored\r\ntowards resisting attack from a quantum computer. Key Encapsulation Mechanisms\r\n(KEMs), are a standardized algorithm type that can be used to build protocols in\r\n```",
              "createdAt": "2025-05-22T06:01:02Z",
              "updatedAt": "2025-05-22T06:01:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdmNf",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:02:03Z",
          "updatedAt": "2025-05-22T06:02:03Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "```suggestion\r\nlieu of traditional, quantum-vulnerable variants such as finite field\r\nor elliptic curve Diffie-Hellman (DH) based protocols. Upgrading protocols\r\nto use PQ KEMs is a priority for the\r\n```",
              "createdAt": "2025-05-22T06:02:03Z",
              "updatedAt": "2025-05-22T06:02:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdmvn",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:03:17Z",
          "updatedAt": "2025-05-22T06:03:18Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nbased protocols.  Upgrading key establishment protocols to use PQ KEMs is a\r\npriority for the protocol design community, due to the possibility of\r\n\"harvest now, decrypt later\" attacks.\r\n```",
              "createdAt": "2025-05-22T06:03:18Z",
              "updatedAt": "2025-05-22T06:03:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdnAf",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:03:55Z",
          "updatedAt": "2025-05-22T06:03:55Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "'retains the properties' needs clarity",
              "createdAt": "2025-05-22T06:03:55Z",
              "updatedAt": "2025-05-22T06:03:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdnbg",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:04:28Z",
          "updatedAt": "2025-05-22T06:04:28Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "```suggestion\r\neven if the other KEM is compromised.  If the PQ KEM is broken, then the hybrid\r\nKEM should continue to provide security against\r\n```",
              "createdAt": "2025-05-22T06:04:28Z",
              "updatedAt": "2025-05-22T06:04:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdoAZ",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:05:05Z",
          "updatedAt": "2025-05-22T06:05:06Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "```suggestion\r\nIn addition to guarding against algorithm weakness, this property also guards\r\nagainst flaws in implementations, such as timing attacks.  Hybrid KEMs can also\r\nfacilitate faster deployment of PQ security by allowing applications to\r\n```",
              "createdAt": "2025-05-22T06:05:05Z",
              "updatedAt": "2025-05-22T06:05:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdocC",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:05:58Z",
          "updatedAt": "2025-05-22T06:05:59Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "But not only KEMs as components, as in QSF - we combine traditional components and PQ KEMs",
              "createdAt": "2025-05-22T06:05:59Z",
              "updatedAt": "2025-05-22T06:05:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdoi5",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:06:13Z",
          "updatedAt": "2025-05-22T06:06:14Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "```suggestion\r\nof techniques for constructing hybrid KEMs designed to achieve specific security\r\nproperties given conforming component algorithms, that should be suitable for\r\nthe majority of use cases.\r\n```",
              "createdAt": "2025-05-22T06:06:14Z",
              "updatedAt": "2025-05-22T06:06:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdo3B",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:06:58Z",
          "updatedAt": "2025-05-22T06:06:58Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "nice ",
              "createdAt": "2025-05-22T06:06:58Z",
              "updatedAt": "2025-05-22T06:06:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdpZM",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:08:16Z",
          "updatedAt": "2025-05-22T06:08:17Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "'Yes but', in the literature there is just keygen, so idk if we want to add a word or two to like, make this more 'applied', or applicable just in this document, or something",
              "createdAt": "2025-05-22T06:08:16Z",
              "updatedAt": "2025-05-22T06:08:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdpsH",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:08:58Z",
          "updatedAt": "2025-05-22T06:08:58Z",
          "comments": [
            {
              "originalPosition": 190,
              "body": "```suggestion\r\nWe assume that the values produced and consumed by the above functions are all\r\nbyte strings, with fixed lengths per parameter set:\r\n```",
              "createdAt": "2025-05-22T06:08:58Z",
              "updatedAt": "2025-05-22T06:08:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdqB2",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:09:44Z",
          "updatedAt": "2025-05-22T06:09:44Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "True, but why mention it?",
              "createdAt": "2025-05-22T06:09:44Z",
              "updatedAt": "2025-05-22T06:09:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdqSP",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:10:17Z",
          "updatedAt": "2025-05-22T06:10:17Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "I really don't think we should do this, this is not a secure IND-CCA KEM (it doesn't match DH-KEM in HPKE, for example)",
              "createdAt": "2025-05-22T06:10:17Z",
              "updatedAt": "2025-05-22T06:10:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qkDOU",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "assuming future changes",
          "createdAt": "2025-05-22T14:56:01Z",
          "updatedAt": "2025-05-22T14:56:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6rOlnI",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-27T21:25:29Z",
          "updatedAt": "2025-05-27T21:25:29Z",
          "comments": [
            {
              "originalPosition": 190,
              "body": "I'm putting in a note for now, but I suspect we should make this optional and parallel to `EncapsDerand`.",
              "createdAt": "2025-05-27T21:25:29Z",
              "updatedAt": "2025-05-27T21:25:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rOmja",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-27T21:26:52Z",
          "updatedAt": "2025-05-27T21:26:53Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "In case people have already read HPKE and are looking at this.  I have added markup to make it an inset note / aside.  I'm not that committed to it; happy to delete it if people feel strongly.",
              "createdAt": "2025-05-27T21:26:52Z",
              "updatedAt": "2025-05-27T21:26:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 19,
      "id": "PR_kwDOMmhxws6Wgb0y",
      "title": "Hybrid constructions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/19",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR builds on #18 by actually defining the hybrid KEM constructions.  First we define the overall KEM structure, being generic over combiner functions, and then we define the combiners.\r\n\r\nI have focused on functional definitions here, with security notions and arguments punted to the Security Considerations.  I added an outline of what I think we need the Security Considerations to look like at the end, mainly so that I could have targets for the cross-references above.",
      "createdAt": "2025-05-16T18:17:04Z",
      "updatedAt": "2025-05-29T22:02:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "9e85013a9da7226a2e54c098de0ab5043034a158",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "hybrid-constructions",
      "headRefOid": "dcced8928ede11206cddb706f87e15b95b947005",
      "closedAt": "2025-05-29T22:02:53Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed on authors call, will remove the \"OnlySharedSecrets\" option (nobody's asking for it; arguably not sound) and reframe the OnlyTraditional option in terms of a T group.",
          "createdAt": "2025-05-22T14:58:43Z",
          "updatedAt": "2025-05-22T14:58:43Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Subsumed in #22 ",
          "createdAt": "2025-05-29T22:02:50Z",
          "updatedAt": "2025-05-29T22:02:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6qkD1h",
          "commit": {
            "abbreviatedOid": "86bea7e"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "assuming future changes",
          "createdAt": "2025-05-22T14:56:43Z",
          "updatedAt": "2025-05-22T14:56:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOMmhxws6X2tuT",
      "title": "Post #18 edits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/21",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* Addresses a bunch of editorial comments from @dconnolly.  \r\n* Removes the OnlySharedSecrets combiner, as discussed on the authors call",
      "createdAt": "2025-05-27T21:30:37Z",
      "updatedAt": "2025-05-29T22:03:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "9e85013a9da7226a2e54c098de0ab5043034a158",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "post-18",
      "headRefOid": "1138e27278bb141638319d458ea782badc538f59",
      "closedAt": "2025-05-29T22:03:04Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Subsumed in #22 ",
          "createdAt": "2025-05-29T22:03:04Z",
          "updatedAt": "2025-05-29T22:03:04Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 22,
      "id": "PR_kwDOMmhxws6YCzWa",
      "title": "Reframe in terms of groups ++",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/22",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR rewrites the hybrid KEMs in terms of nominal groups as appropriate.\r\n\r\n* Adds a \"nominal group\" API much like the KEM API.\r\n* The HashEverything hybrid is defined in terms of KEM+KEM\r\n    * The PreHashKeys hybrid is defined as an optimization of HashEverything\r\n    * We define a way of instantiating the above with a group instead of a KEM\r\n* The HashTraditionalOnly hybrid is define in terms of Group+KEM (as in [BCD+24])\r\n",
      "createdAt": "2025-05-29T00:34:54Z",
      "updatedAt": "2025-06-06T15:44:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "9e85013a9da7226a2e54c098de0ab5043034a158",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "kem-vs-curve",
      "headRefOid": "85abd303cacb9d72fc4b6204a080efb43f353c81",
      "closedAt": "2025-06-06T15:44:08Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation is this branch all the commits from PR #18 and #21? ",
          "createdAt": "2025-05-29T15:23:53Z",
          "updatedAt": "2025-05-29T15:23:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@dconnolly - Yes, i've just been building ahead linearly.",
          "createdAt": "2025-05-29T15:24:54Z",
          "updatedAt": "2025-05-29T15:24:54Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "All these changes have been included in #31, closing",
          "createdAt": "2025-06-06T15:44:08Z",
          "updatedAt": "2025-06-06T15:44:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6rkRSP",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T13:55:19Z",
          "updatedAt": "2025-05-29T13:55:19Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Recommend removal of HNDL attacks. Motivation for PQC is not specific to that, but due to quantum threats.",
              "createdAt": "2025-05-29T13:55:19Z",
              "updatedAt": "2025-05-29T13:55:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rkaq8",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T14:07:54Z",
          "updatedAt": "2025-05-29T14:07:54Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "The idea of mentioning HNDL is just to explain why the focus on KEMs vs. Authentication.  But I don't feel super strongly.",
              "createdAt": "2025-05-29T14:07:54Z",
              "updatedAt": "2025-05-29T14:07:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rkmIx",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T14:23:43Z",
          "updatedAt": "2025-05-29T14:23:44Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Well, the whole draft is about KEMs only, so...",
              "createdAt": "2025-05-29T14:23:43Z",
              "updatedAt": "2025-05-29T14:23:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rlSL4",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T15:21:58Z",
          "updatedAt": "2025-05-29T15:21:58Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "And KEMs are not only used for key establishment, sometimes they are used for auth too",
              "createdAt": "2025-05-29T15:21:58Z",
              "updatedAt": "2025-05-29T15:21:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rlTZ0",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T15:23:42Z",
          "updatedAt": "2025-05-29T15:23:43Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Fine, fine, we can delete it :)",
              "createdAt": "2025-05-29T15:23:43Z",
              "updatedAt": "2025-05-29T15:23:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rl8nU",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T16:14:03Z",
          "updatedAt": "2025-05-29T16:14:03Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "```suggestion\r\n# Hybrid KEM Generic Constructions {#generic-constructions}\r\n```",
              "createdAt": "2025-05-29T16:14:03Z",
              "updatedAt": "2025-05-29T16:14:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rl886",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T16:14:37Z",
          "updatedAt": "2025-05-29T16:14:37Z",
          "comments": [
            {
              "originalPosition": 265,
              "body": "```suggestion\r\nIn this section, we define three generic constructions for hybrid KEMs:\r\n```",
              "createdAt": "2025-05-29T16:14:37Z",
              "updatedAt": "2025-05-29T16:14:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rl9km",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T16:15:39Z",
          "updatedAt": "2025-05-29T16:15:39Z",
          "comments": [
            {
              "originalPosition": 279,
              "body": "```suggestion\r\n* HashEverything - A generic construction that is suitable for use with any choice\r\n  of traditional and PQ KEMs, with minimal security assumptions on the\r\n  constituent KEMs\r\n* PreHashedKeys - A performance optimization of HashEverything for the case\r\n  where encapsulation keys are large and frequently reused\r\n* HashTraditionalOnly - An optimized generic construction for the case where the traditional\r\n  component is a nominal group and the PQ component has strong binding\r\n  properties\r\n```",
              "createdAt": "2025-05-29T16:15:39Z",
              "updatedAt": "2025-05-29T16:15:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmAVm",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T16:20:17Z",
          "updatedAt": "2025-05-29T16:20:17Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "Let's duplicate Encaps and Decaps from HashEverything here and just change/add these lines",
              "createdAt": "2025-05-29T16:20:17Z",
              "updatedAt": "2025-05-29T17:57:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmLUB",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T16:33:23Z",
          "updatedAt": "2025-05-29T16:33:23Z",
          "comments": [
            {
              "originalPosition": 496,
              "body": "Let's remove this for now, tracked with #23 ",
              "createdAt": "2025-05-29T16:33:23Z",
              "updatedAt": "2025-05-29T16:33:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmpfv",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:17:09Z",
          "updatedAt": "2025-05-29T17:17:09Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "```suggestion\r\nPost-quantum (PQ) cryptographic schemes offer new constructions based on problems conjectured as resistant to attacks possible on a quantum computer. Key Encapsulation Mechanisms\r\n```",
              "createdAt": "2025-05-29T17:17:09Z",
              "updatedAt": "2025-05-29T17:17:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmp0U",
          "commit": {
            "abbreviatedOid": "c8874d0"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:17:43Z",
          "updatedAt": "2025-05-29T17:17:44Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "```suggestion\r\nlieu of traditional, quantum-vulnerable variants such as finite field or\r\nelliptic curve Diffie-Hellman (DH) based protocols.\r\n```",
              "createdAt": "2025-05-29T17:17:43Z",
              "updatedAt": "2025-05-29T17:17:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmrwH",
          "commit": {
            "abbreviatedOid": "d64370f"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:20:11Z",
          "updatedAt": "2025-05-29T17:20:11Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\nPost-quantum (PQ) cryptographic schemes offer new constructions based on problems\r\nconjectured as resistant to attacks possible on a quantum computer. Key Encapsulation\r\nMechanisms (KEMs), are a standardized class of cryptographic scheme that can be used\r\nto build protocols in\r\n```",
              "createdAt": "2025-05-29T17:20:11Z",
              "updatedAt": "2025-05-29T17:20:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmsgF",
          "commit": {
            "abbreviatedOid": "a6ee732"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:21:02Z",
          "updatedAt": "2025-05-29T17:21:03Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nPost-quantum (PQ) cryptographic schemes offer new constructions based on problems\r\nconjectured as resistant to attacks possible on a quantum computer. Key \r\nEncapsulation Mechanisms (KEMs), are a standardized class of cryptographic scheme\r\nthat can be used to build protocols in lieu of traditional, quantum-vulnerable\r\nvariants such as finite field or elliptic curve Diffie-Hellman (DH) based protocols.\r\n```",
              "createdAt": "2025-05-29T17:21:02Z",
              "updatedAt": "2025-05-29T17:21:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmtSu",
          "commit": {
            "abbreviatedOid": "c80503e"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:22:06Z",
          "updatedAt": "2025-05-29T17:22:06Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "```suggestion\r\nIn this document, we define generic constructions for hybrid KEMs based on combining a\r\n```",
              "createdAt": "2025-05-29T17:22:06Z",
              "updatedAt": "2025-05-29T17:22:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmulX",
          "commit": {
            "abbreviatedOid": "7eca073"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:23:25Z",
          "updatedAt": "2025-05-29T17:23:25Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "So this is tricky, it's being used to split secret key material and public key material, and being leaky on one is acceptable and being leaky on the other is not...",
              "createdAt": "2025-05-29T17:23:25Z",
              "updatedAt": "2025-05-29T17:23:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmvel",
          "commit": {
            "abbreviatedOid": "407a07b"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:24:30Z",
          "updatedAt": "2025-05-29T17:24:30Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "```suggestion\r\n  input a seed `seed` and generates a public encapsulation key `ek` and a secret\r\n```",
              "createdAt": "2025-05-29T17:24:30Z",
              "updatedAt": "2025-05-29T17:24:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmxKK",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:26:43Z",
          "updatedAt": "2025-05-29T17:26:43Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "All mention of 'KDF' and 'XOF' has been removed and 'hash functions' has been added, these things are not the same",
              "createdAt": "2025-05-29T17:26:43Z",
              "updatedAt": "2025-05-29T17:26:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmxhB",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "blocked on KDF, XOF ",
          "createdAt": "2025-05-29T17:27:08Z",
          "updatedAt": "2025-05-29T17:27:08Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6rm0Wf",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:31:01Z",
          "updatedAt": "2025-05-29T17:31:01Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "These things are not isomorphic and I don't think we should talk about them this way, I think we should bring back the language about KDFs and XOFs @pag-crypto @br-hale @bwesterb \r\n",
              "createdAt": "2025-05-29T17:31:01Z",
              "updatedAt": "2025-05-29T17:37:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rm2Sl",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:33:47Z",
          "updatedAt": "2025-05-29T17:33:48Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "```suggestion\r\n- `split(N1, N2, x)`: Split a byte string `x` of length `N1 + N2` into its first\r\n  `N1` bytes and its last `N2` bytes.  This function is the inverse of\r\n  `concat(x1, x2)` when `x1` is `N1` bytes long and `x2` is `N2` bytes long. It\r\n  is an error to call this function with a byte string that does not have length\r\n  `N1 + N2`. Since this function operates over secret data it MUST be constant-time.\r\n```",
              "createdAt": "2025-05-29T17:33:47Z",
              "updatedAt": "2025-05-29T17:33:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rm3-k",
          "commit": {
            "abbreviatedOid": "ac43444"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:36:40Z",
          "updatedAt": "2025-05-29T17:36:41Z",
          "comments": [
            {
              "originalPosition": 681,
              "body": "Removed for now but tracked in https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/24\r\n\r\n```suggestion\r\n```",
              "createdAt": "2025-05-29T17:36:40Z",
              "updatedAt": "2025-05-29T17:36:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rm62L",
          "commit": {
            "abbreviatedOid": "43f5e03"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:41:35Z",
          "updatedAt": "2025-05-29T17:41:35Z",
          "comments": [
            {
              "originalPosition": 375,
              "body": "I might not even define 'split()` in this document, it may be generic enough to decompose into component dk's with an explicit `Decompose()` or something, leave the byte-wise notions to -concrete",
              "createdAt": "2025-05-29T17:41:35Z",
              "updatedAt": "2025-05-29T18:18:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rm9Wb",
          "commit": {
            "abbreviatedOid": "43f5e03"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:45:49Z",
          "updatedAt": "2025-05-29T17:45:49Z",
          "comments": [
            {
              "originalPosition": 283,
              "body": "Found it; this is not just a hash function, it has to be a secure KDF (it can't be SHA1 or SHA-256, it should be something like SHA3 or HKDF-SHA256)",
              "createdAt": "2025-05-29T17:45:49Z",
              "updatedAt": "2025-05-29T17:45:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnHxg",
          "commit": {
            "abbreviatedOid": "43f5e03"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:01:02Z",
          "updatedAt": "2025-05-29T18:01:02Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "```suggestion\r\noracle.\r\n\r\nFor QSF, the KDF function must be a secure random oracle in the random oracle\r\nmodel and quantum random oracle model and as a secure pseudorandom\r\nfunction (PRF) in the standard model.\r\n```",
              "createdAt": "2025-05-29T18:01:02Z",
              "updatedAt": "2025-05-29T18:01:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnPN3",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:12:30Z",
          "updatedAt": "2025-05-29T18:12:30Z",
          "comments": [
            {
              "originalPosition": 554,
              "body": "I don't love this name (I don't quite understand what it's trying to say) and think `QSF` is as good a name as any, short, and unless you already know it's associated with X-Wing, non-controversial?",
              "createdAt": "2025-05-29T18:12:30Z",
              "updatedAt": "2025-05-29T18:12:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnPnN",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:13:14Z",
          "updatedAt": "2025-05-29T18:13:14Z",
          "comments": [
            {
              "originalPosition": 498,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-05-29T18:13:14Z",
              "updatedAt": "2025-05-29T18:13:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnPuw",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:13:28Z",
          "updatedAt": "2025-05-29T18:13:28Z",
          "comments": [
            {
              "originalPosition": 504,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-05-29T18:13:28Z",
              "updatedAt": "2025-05-29T18:13:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnP04",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:13:38Z",
          "updatedAt": "2025-05-29T18:13:39Z",
          "comments": [
            {
              "originalPosition": 510,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-05-29T18:13:39Z",
              "updatedAt": "2025-05-29T18:13:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnP_9",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:13:57Z",
          "updatedAt": "2025-05-29T18:13:58Z",
          "comments": [
            {
              "originalPosition": 542,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-05-29T18:13:57Z",
              "updatedAt": "2025-05-29T18:13:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnQKi",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:14:16Z",
          "updatedAt": "2025-05-29T18:14:16Z",
          "comments": [
            {
              "originalPosition": 543,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-05-29T18:14:16Z",
              "updatedAt": "2025-05-29T18:14:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnQWW",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:14:37Z",
          "updatedAt": "2025-05-29T18:14:37Z",
          "comments": [
            {
              "originalPosition": 548,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-05-29T18:14:37Z",
              "updatedAt": "2025-05-29T18:14:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnTkz",
          "commit": {
            "abbreviatedOid": "89fd845"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:20:12Z",
          "updatedAt": "2025-05-29T18:20:12Z",
          "comments": [
            {
              "originalPosition": 292,
              "body": "I really think we should explicitly call these what they are, XOF's and KDF's, 'hash function' blends them together in a way that is not correct and can lead to security issues",
              "createdAt": "2025-05-29T18:20:12Z",
              "updatedAt": "2025-05-29T18:20:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnXG5",
          "commit": {
            "abbreviatedOid": "89fd845"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:26:09Z",
          "updatedAt": "2025-05-29T18:26:09Z",
          "comments": [
            {
              "originalPosition": 453,
              "body": "```suggestion\r\n## PreHash {#prehash}\r\n```",
              "createdAt": "2025-05-29T18:26:09Z",
              "updatedAt": "2025-05-29T18:26:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnX1E",
          "commit": {
            "abbreviatedOid": "09a30e9"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:27:06Z",
          "updatedAt": "2025-05-29T18:27:07Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "```suggestion\r\nGiven the novelty of these PQ schemes however, there is some concern that PQ\r\nalgorithms currently believed to be secure will be broken.  Hybrid\r\nconstructions that combine both PQ and traditional algorithms can help moderate\r\nthis risk while still providing security against quantum attack.  If construted\r\n```",
              "createdAt": "2025-05-29T18:27:07Z",
              "updatedAt": "2025-05-29T18:27:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnZZk",
          "commit": {
            "abbreviatedOid": "487c1fc"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:29:15Z",
          "updatedAt": "2025-05-29T18:29:16Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "```suggestion\r\n- Key Encapsulation Mechanisms {{kems}}\r\n- Nominal Groups {{group}}\r\n- Key-derivation Functions {{kdfs}}\r\n- Extendable-output Functions {{xofs}}\r\n- Hash Functions {{hash}}\r\n```",
              "createdAt": "2025-05-29T18:29:15Z",
              "updatedAt": "2025-05-29T18:29:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rng1R",
          "commit": {
            "abbreviatedOid": "487c1fc"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:39:41Z",
          "updatedAt": "2025-05-29T18:39:41Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "```suggestion\r\n> \"decapsulation\" as opposed to \"public\" and \"secret\".\r\n\r\n## Key Derivation Function `KDF` {#kdf}\r\n\r\nA secure key derivation function (KDF) that is modeled as a secure\r\npseudorandom function (PRF) in the standard model {{GHP2018}} and\r\nindependent random oracle in the random oracle model (ROM) and quantum\r\nrandom oracle model. Generally a strong KDF will have a proof of\r\nindifferentiability from a random oracle.\r\n\r\nExamples of secure KDFs in practice include HKDF-SHA256 and SHA3.\r\nSHA-256 is not generally considered a strong KDF except under\r\nconstrained circumstances {{CDMP2005}}.\r\n\r\n## Extendable-output function `XOF` {#xof}\r\n\r\nExtendable-output function (XOF). A function on bit strings in which the\r\noutput can be extended to any desired length. Ought to satisfy the following\r\nproperties as long as the specified output length is sufficiently long to\r\nprevent trivial attacks:\r\n\r\n1. (One-way) It is computationally infeasible to find any input that maps to\r\n   any new pre-specified output.\r\n\r\n2. (Collision-resistant) It is computationally infeasible to find any two\r\n   distinct inputs that map to the same output.\r\n\r\nMUST provide the bit-security required to source input randomness for PQ/T\r\ncomponents from a seed that is expanded to a output length, of which a subset\r\nis passed to the component key generation algorithms.\r\n\r\n## Hash functions {#hash}\r\n```",
              "createdAt": "2025-05-29T18:39:41Z",
              "updatedAt": "2025-05-29T18:39:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnhBx",
          "commit": {
            "abbreviatedOid": "487c1fc"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:40:02Z",
          "updatedAt": "2025-05-29T18:40:02Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "@br-hale @bwesterb thoughts?",
              "createdAt": "2025-05-29T18:40:02Z",
              "updatedAt": "2025-05-29T18:40:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnknM",
          "commit": {
            "abbreviatedOid": "487c1fc"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:45:33Z",
          "updatedAt": "2025-05-29T18:45:33Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "I would concure that this is 'encapulation' and 'decapsulation' (vs enc / dec). Those are the functions. For the key, a \"secret encapsulation key\" and \"public decapsultation key\" seem appropriate.",
              "createdAt": "2025-05-29T18:45:33Z",
              "updatedAt": "2025-05-29T18:45:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnm1y",
          "commit": {
            "abbreviatedOid": "89fd845"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:48:58Z",
          "updatedAt": "2025-05-29T18:48:59Z",
          "comments": [
            {
              "originalPosition": 292,
              "body": "Concur",
              "createdAt": "2025-05-29T18:48:58Z",
              "updatedAt": "2025-05-29T18:48:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnpJT",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:52:37Z",
          "updatedAt": "2025-05-29T18:52:38Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "Concur",
              "createdAt": "2025-05-29T18:52:38Z",
              "updatedAt": "2025-05-29T18:52:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnr1Q",
          "commit": {
            "abbreviatedOid": "89fd845"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:57:14Z",
          "updatedAt": "2025-05-29T18:57:14Z",
          "comments": [
            {
              "originalPosition": 292,
              "body": "I've added some short sections on what they are and will take a stab at utilizing the them in the generic schemes' pseudocode next",
              "createdAt": "2025-05-29T18:57:14Z",
              "updatedAt": "2025-05-29T18:57:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnsLg",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:57:53Z",
          "updatedAt": "2025-05-29T18:57:54Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Yes, there is a very significant difference for security. The descriptions (generic and concrete) need to match the generic building blocks used in the analyses. \r\n\r\nALSO, we need to look at and discuss if the write concrete choices are used for the end goal (e.g., if something is using SHA256, SHA384, or SHA3). This may or may not be the same as used in the analysis - which means that if we change a building block from what is used in the analysis we need to take a closer look that the right properties are statisfied. \r\n\r\nI am also concerned the properties stated (e.g., collision resistance and second preimage resis) may not align to the properties needed for security, i.e., per what analysis has shown. We need to cite the write attributes.  ",
              "createdAt": "2025-05-29T18:57:54Z",
              "updatedAt": "2025-05-29T18:57:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rn0YG",
          "commit": {
            "abbreviatedOid": "869f45b"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T19:12:42Z",
          "updatedAt": "2025-05-29T19:12:42Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Agreed; 'KitchenSink'/'HashEverything' seems closest to GHP2018, QSF to QSF ofc, which both require the KDF to be a 'good' random oracle (and QSF in the standard model requires a 'secure' PRF) which seems to basically mean 'indiff. from an RO' now, even if it's assumed/understated? Chempat doesn't have a proof but maybe we can deduce requirements from GHP2018?",
              "createdAt": "2025-05-29T19:12:42Z",
              "updatedAt": "2025-05-29T19:12:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ro5H_",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T21:11:00Z",
          "updatedAt": "2025-05-29T21:11:01Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "I think the proposed change is an improvement. QROM is clearly the strongest requirement on a hash function, and for the PQ KEMs I checked, they all require one anyway.\r\n\r\nLet me entertain a brief tangent. If I could go back a decade or so, I'd propose the CFRG to write a document with the title \"What is a good hash?\". It'd explain ROM, PRF, and all subtle academic differences in security properties. But in the end it'd simply say: length-prefixed-SHA2 & SHA-3 good; MD5, SHA-1 bad.",
              "createdAt": "2025-05-29T21:11:01Z",
              "updatedAt": "2025-05-29T21:11:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rpAiY",
          "commit": {
            "abbreviatedOid": "869f45b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T21:26:41Z",
          "updatedAt": "2025-05-29T21:26:42Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "I think it will actually be cleanest just to delete this text for now, and punt on it like we have for all of the other security descriptions.  I will also add some text at the top of this section clarifying that we're just defining functional definitions here, and the security requirements are below.",
              "createdAt": "2025-05-29T21:26:41Z",
              "updatedAt": "2025-05-29T21:26:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rpB1q",
          "commit": {
            "abbreviatedOid": "869f45b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T21:29:51Z",
          "updatedAt": "2025-05-29T21:33:53Z",
          "comments": [
            {
              "originalPosition": 292,
              "body": "Disagree.  (1) XOF brings a lot more baggage than is necessary, (2) definitions of KDF in the literature are all over the place, and (3) as Bas points out, everyone uses RO for this anyway.\r\n\r\nI agree that the notion of \"hash function\" here is stronger than the usual definition (requiring RO instead of just collision/preimage resistance).  So maybe we need a different word.",
              "createdAt": "2025-05-29T21:29:51Z",
              "updatedAt": "2025-05-29T21:33:53Z"
            },
            {
              "originalPosition": 375,
              "body": "FWIW, we're using it for all of the concatenated things: `dk`, `ek`, and `ct`.\r\n\r\nI agree that the compound serialization doesn't matter.  But the constituent values need to be fixed-length byte strings since they're going into a hash function and you want `concat()` to be unambiguous without length prefixing.  So there's no need for anything more complicated.\r\n\r\nI'm going to leave this for now, and maybe file an issue.",
              "createdAt": "2025-05-29T21:33:45Z",
              "updatedAt": "2025-05-29T21:33:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rpEzD",
          "commit": {
            "abbreviatedOid": "869f45b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T21:36:56Z",
          "updatedAt": "2025-05-29T21:36:56Z",
          "comments": [
            {
              "originalPosition": 554,
              "body": "I don't love it either, but trying to separate from earlier names to be more neutral / give this document more coherence.\r\n\r\nAnother thing to file an issue on. Maybe you could backronym it to something?  ",
              "createdAt": "2025-05-29T21:36:56Z",
              "updatedAt": "2025-05-29T21:36:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rpHsT",
          "commit": {
            "abbreviatedOid": "869f45b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T21:42:43Z",
          "updatedAt": "2025-05-29T21:42:57Z",
          "comments": [
            {
              "originalPosition": 554,
              "body": "@BTW, what it's trying to say is that the only metadata you hash in is on the T side.  \ud83e\udd37 ",
              "createdAt": "2025-05-29T21:42:43Z",
              "updatedAt": "2025-05-29T21:42:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rpRQ6",
          "commit": {
            "abbreviatedOid": "869f45b"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T22:08:26Z",
          "updatedAt": "2025-05-29T22:21:02Z",
          "comments": [
            {
              "originalPosition": 283,
              "body": "@dconnolly citation?",
              "createdAt": "2025-05-29T22:08:26Z",
              "updatedAt": "2025-05-29T22:21:02Z"
            },
            {
              "originalPosition": 375,
              "body": "+1 to @bifurcation -- since these are being thrown into the hash, parsing them at this layer seems necessary.",
              "createdAt": "2025-05-29T22:11:45Z",
              "updatedAt": "2025-05-29T22:21:02Z"
            },
            {
              "originalPosition": 493,
              "body": "Agreed.",
              "createdAt": "2025-05-29T22:20:26Z",
              "updatedAt": "2025-05-29T22:21:02Z"
            },
            {
              "originalPosition": 554,
              "body": "Let's leave it as-is and bike shed the name later. I think it's clear enough for now.",
              "createdAt": "2025-05-29T22:20:49Z",
              "updatedAt": "2025-05-29T22:21:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6srheq",
          "commit": {
            "abbreviatedOid": "c4d01b2"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T14:53:39Z",
          "updatedAt": "2025-06-04T14:53:40Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "```suggestion\r\nThe remainder of this document is structured as follows: first, in\r\n{{cryptographic-deps}} and {{schemes}}, we define the abstractions on which the\r\nschemes are built, and then the schemes themselves.  Then, in {{security}}, we\r\n```",
              "createdAt": "2025-06-04T14:53:39Z",
              "updatedAt": "2025-06-04T14:53:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ssS1p",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T15:53:37Z",
          "updatedAt": "2025-06-04T15:53:37Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "<3",
              "createdAt": "2025-06-04T15:53:37Z",
              "updatedAt": "2025-06-04T15:53:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ssdcX",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T16:08:12Z",
          "updatedAt": "2025-06-04T16:08:12Z",
          "comments": [
            {
              "originalPosition": 266,
              "body": "Suggestions:\r\n- `All` - except it's not really all as the lengths aren't encoded necessarily in the preimage but\r\n- `Curich` - this is kinda stupid but 'Chempat' is the name of a star wars fictional manufacturer, 'Curich' is another star wars fictional manufacturer that's similar to Chempat, but not, bc the generic scheme written here is similar to the Chempat design, but not \r\n- `QSF` - short, established, at least less misleading than 'HashTraditionalOnly`\r\n\r\nI don't think including 'hash' in the names is helping",
              "createdAt": "2025-06-04T16:08:12Z",
              "updatedAt": "2025-06-04T16:09:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ssfSc",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T16:10:34Z",
          "updatedAt": "2025-06-04T16:10:34Z",
          "comments": [
            {
              "originalPosition": 375,
              "body": "fair enough",
              "createdAt": "2025-06-04T16:10:34Z",
              "updatedAt": "2025-06-04T16:10:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ssf0a",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T16:11:18Z",
          "updatedAt": "2025-06-04T16:11:18Z",
          "comments": [
            {
              "originalPosition": 355,
              "body": "Not defined",
              "createdAt": "2025-06-04T16:11:18Z",
              "updatedAt": "2025-06-04T16:11:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ssgEw",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T16:11:37Z",
          "updatedAt": "2025-06-04T16:11:37Z",
          "comments": [
            {
              "originalPosition": 378,
              "body": "Not defined",
              "createdAt": "2025-06-04T16:11:37Z",
              "updatedAt": "2025-06-04T16:11:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ssidx",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T16:14:42Z",
          "updatedAt": "2025-06-04T16:14:42Z",
          "comments": [
            {
              "originalPosition": 554,
              "body": "Yes leaving it the existing document names as-is seems fine (QSF)",
              "createdAt": "2025-06-04T16:14:42Z",
              "updatedAt": "2025-06-04T16:14:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sss9Z",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T16:31:08Z",
          "updatedAt": "2025-06-04T16:31:09Z",
          "comments": [
            {
              "originalPosition": 539,
              "body": "QSF (or rather the X-Wing style of QSF) specifically uses an XOF, skewing away seems fraught because of inputs and outputs sizes re: security levels, skewing away from proven schemes and established reviewed designs seems fraught",
              "createdAt": "2025-06-04T16:31:09Z",
              "updatedAt": "2025-06-04T16:32:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ss2Mj",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T16:46:00Z",
          "updatedAt": "2025-06-04T16:46:00Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "```suggestion\r\n- Key Derivation Functions ({{kdfs}})\r\n- Extendable-Output Functions ({{xofs}})\r\n```",
              "createdAt": "2025-06-04T16:46:00Z",
              "updatedAt": "2025-06-04T16:46:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ss6gc",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T16:51:52Z",
          "updatedAt": "2025-06-04T16:51:52Z",
          "comments": [
            {
              "originalPosition": 254,
              "body": "We must include XOFs because of X-Wing at the least but also because different KEMs/ groups may need different input seed sizes and pure hash functions are not well suited for this; HKDF allows this via Expand(..., length) but X-Wing does not use HKDF\r\n\r\n```suggestion\r\n<!-- We must include XOFs because of X-Wing at the least but also because different KEMs/ groups may need different input seed sizes out the back of the function, and pure hash functions are not well suited for this; HKDF allows this via Expand(..., length) but X-Wing does not use HKDF -->\r\n\r\n## `XOF` {#xofs}\r\n\r\nExtendable-output function (XOF). A function on bit strings in which the\r\noutput can be extended to any desired length. Ought to satisfy the following\r\nproperties as long as the specified output length is sufficiently long to\r\nprevent trivial attacks:\r\n\r\n1. (One-way) It is computationally infeasible to find any input that maps to\r\n   any new pre-specified output.\r\n\r\n2. (Collision-resistant) It is computationally infeasible to find any two\r\n   distinct inputs that map to the same output.\r\n\r\nMUST provide the bit-security required to source input randomness for PQ/T\r\ncomponents from a seed that is expanded to a output length, of which a subset\r\nis passed to the component key generation algorithms.\r\n\r\n# Hybrid KEM Schemes {#schemes}\r\n```",
              "createdAt": "2025-06-04T16:51:52Z",
              "updatedAt": "2025-06-04T16:58:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ss8Jl",
          "commit": {
            "abbreviatedOid": "fed4538"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T16:54:28Z",
          "updatedAt": "2025-06-04T16:54:29Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "`.Derive()` is never used, shall we go back to `KDF(..)` ?",
              "createdAt": "2025-06-04T16:54:29Z",
              "updatedAt": "2025-06-04T16:54:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stCBy",
          "commit": {
            "abbreviatedOid": "3df988c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:03:50Z",
          "updatedAt": "2025-06-04T17:03:51Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "```suggestion\r\nWhile KDFs in the literature can typically consume and produce byte strings of\r\narbitrary length, the KDFs used in this document have a simpler form, with a fixed\r\noutput lengths:\r\n\r\n- `Nin` - The length in bytes of an input to this KDF.\r\n- `Nout` - The length in bytes of an output from this KDF.\r\n- `KDF(input) -> output`: Produce a byte string of length `Nout` from an input\r\n  byte string.\r\n\r\nThe fixed sizes are for both security and simplicity. \r\n\r\nFor instances of the `Extract()`/`Expand()` KDF paradigm such as `HKDF`, we fix the salt s and sizes to fit this form.\r\n```",
              "createdAt": "2025-06-04T17:03:50Z",
              "updatedAt": "2025-06-04T17:03:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stCyY",
          "commit": {
            "abbreviatedOid": "06b4ae4"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:05:03Z",
          "updatedAt": "2025-06-04T17:05:04Z",
          "comments": [
            {
              "originalPosition": 213,
              "body": "Do we need to even say this?",
              "createdAt": "2025-06-04T17:05:03Z",
              "updatedAt": "2025-06-04T17:05:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stP9Y",
          "commit": {
            "abbreviatedOid": "689f696"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:27:01Z",
          "updatedAt": "2025-06-04T17:27:02Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "This is incorrect, nominal groups do not align with finite fields especially regarding Diffie-Hellman - finite fields have other algebraic structure that ofc make them weaker to instantiate DH over than groups.\r\n\r\n```suggestion\r\n<!-- Yes we need to be able to model the group as a nominal group to make the proofs work, but we have proofs for the NIST curves and the Montgomery curves, I wouldn't be surprised if a nice prime order group like Ristretto or DoubleOdd could also be shown to be a nominal group; thoughts on putting the 'nominal' requirements in the bit at the bottom of the doc, and just leave this as 'Groups'? --> \r\n\r\nNominal groups are an abstract model of elliptic curve groups, over which we\r\ninstantiate Diffie-Hellman key agreement {{ABH+21}}.  A nominal group comprises\r\na set `G` together with a distinguished basis element `g`, an \"exponentiation\"\r\nmap, and some auxiliary functions:\r\n```",
              "createdAt": "2025-06-04T17:27:01Z",
              "updatedAt": "2025-06-04T17:29:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stSgS",
          "commit": {
            "abbreviatedOid": "877df2d"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:30:30Z",
          "updatedAt": "2025-06-04T17:30:31Z",
          "comments": [
            {
              "originalPosition": 190,
              "body": "```suggestion\r\n<!-- Yes we need to be able to model the group as a nominal group to make the\r\nproofs work, but we have proofs for the NIST curves and the Montgomery curves,\r\nI wouldn't be surprised if a nice prime order group like Ristretto or DoubleOdd\r\ncould also be shown to be a nominal group; thoughts on putting the 'nominal'\r\nrequirements in the security bits at the bottom of the doc, and just leave this as\r\n'Groups'? --> \r\n\r\nNominal groups are an abstract model of elliptic curve groups, over which we\r\ninstantiate Diffie-Hellman key agreement {{ABH+21}}.  A nominal group comprises\r\na set `G` together with a distinguished basis element `g`, an \"exponentiation\"\r\nmap, and some auxiliary functions:\r\n```",
              "createdAt": "2025-06-04T17:30:30Z",
              "updatedAt": "2025-06-04T17:30:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stTrg",
          "commit": {
            "abbreviatedOid": "c3bc748"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:32:02Z",
          "updatedAt": "2025-06-04T17:32:03Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "```suggestion\r\nA Key Derivation Function (KDF) is a function that a function that produces\r\nkeying material based on an input secret and other information.\r\n\r\nWhile KDFs in the literature can typically consume and produce byte strings of\r\narbitrary length, the KDFs used in this document have a simpler form, with a fixed\r\noutput lengths:\r\n\r\n- `Nin` - The length in bytes of an input to this KDF.\r\n- `Nout` - The length in bytes of an output from this KDF.\r\n- `KDF(input) -> output`: Produce a byte string of length `Nout` from an input\r\n  byte string.\r\n\r\nThe fixed sizes are for both security and simplicity. \r\n\r\nFor instances of the `Extract()`/`Expand()` KDF paradigm such as `HKDF`, we fix\r\nthe salt and sizes to fit this form.\r\n\r\nThe security requirements for KDFs used with the schemes in this document are\r\nlaid out in {{security-requirements}}.\r\n\r\n<!-- We must include XOFs because of X-Wing at the least but also because\r\ndifferent KEMs/ groups may need different input seed sizes out the back of\r\nthe function, and pure hash functions are not well suited for this; HKDF\r\nallows this via Expand(..., length) but X-Wing does not use HKDF -->\r\n```",
              "createdAt": "2025-06-04T17:32:03Z",
              "updatedAt": "2025-06-04T17:32:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stTxx",
          "commit": {
            "abbreviatedOid": "c3bc748"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:32:13Z",
          "updatedAt": "2025-06-04T17:32:14Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "Line wrap",
              "createdAt": "2025-06-04T17:32:14Z",
              "updatedAt": "2025-06-04T17:32:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stUsR",
          "commit": {
            "abbreviatedOid": "503cf12"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:33:29Z",
          "updatedAt": "2025-06-04T17:33:29Z",
          "comments": [
            {
              "originalPosition": 283,
              "body": "```suggestion\r\nIn this section, we define several generic constructions for hybrid KEMs. These\r\nconstructions share a common overall structure, differing mainly in how they\r\ncompute the final shared secret and the security requirements of their components.\r\n```",
              "createdAt": "2025-06-04T17:33:29Z",
              "updatedAt": "2025-06-04T17:33:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stVe8",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:34:41Z",
          "updatedAt": "2025-06-04T17:34:41Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "```suggestion\r\n* `XOF`: An XOF producing byte strings of length `KEM_T.Nseed + KEM_PQ.Nseed`\r\n  (`XOF.Nout == KEM_T.Nseed + KEM_PQ.Nseed`)\r\n* `KDF`: A KDF producing byte strings of length `KEM_H.Nss` (`KDF.Nout\r\n  == KEM_H.Nss`)\r\n```",
              "createdAt": "2025-06-04T17:34:41Z",
              "updatedAt": "2025-06-04T17:34:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stW_J",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:36:37Z",
          "updatedAt": "2025-06-04T17:36:37Z",
          "comments": [
            {
              "originalPosition": 311,
              "body": "```suggestion\r\nThe KEMs, groups, KDFs, and XOFs MSUT meet the security requirements in {{#security-requirements}}.\r\n```",
              "createdAt": "2025-06-04T17:36:37Z",
              "updatedAt": "2025-06-04T17:36:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stXpP",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:37:24Z",
          "updatedAt": "2025-06-04T17:37:26Z",
          "comments": [
            {
              "originalPosition": 348,
              "body": "@bwesterb @br-hale @pag-crypto \r\n\r\nI feel like there's a little bit more to this than mix/max'ing but I'm not sure",
              "createdAt": "2025-06-04T17:37:24Z",
              "updatedAt": "2025-06-04T17:37:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stX2J",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:37:45Z",
          "updatedAt": "2025-06-04T17:37:45Z",
          "comments": [
            {
              "originalPosition": 365,
              "body": "```suggestion\r\n    seed_full = XOF(seed)\r\n```",
              "createdAt": "2025-06-04T17:37:45Z",
              "updatedAt": "2025-06-04T17:37:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stYHY",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:38:14Z",
          "updatedAt": "2025-06-04T17:38:14Z",
          "comments": [
            {
              "originalPosition": 388,
              "body": "```suggestion\r\n    ss_H = KDF(concat(ss_PQ, ss_T, ct_PQ, ct_T, ek_PQ, ek_T, label))\r\n```",
              "createdAt": "2025-06-04T17:38:14Z",
              "updatedAt": "2025-06-04T17:38:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stYXN",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:38:39Z",
          "updatedAt": "2025-06-04T17:38:39Z",
          "comments": [
            {
              "originalPosition": 401,
              "body": "```suggestion\r\n    ss_H = KDF(concat(ss_PQ, ss_T, ct_PQ, ct_T, ek_PQ, ek_T, label))\r\n```",
              "createdAt": "2025-06-04T17:38:39Z",
              "updatedAt": "2025-06-04T17:38:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stZTe",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:40:22Z",
          "updatedAt": "2025-06-04T17:40:23Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "can `split()` be `split(x, N1, N2)`? Why are the input byte to be split last?",
              "createdAt": "2025-06-04T17:40:22Z",
              "updatedAt": "2025-06-04T17:40:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6staUT",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:42:09Z",
          "updatedAt": "2025-06-04T17:42:10Z",
          "comments": [
            {
              "originalPosition": 492,
              "body": "`KeyHash` does not have to have the same requirements of a KDF, it probably only needs collision resistance (but I'm not sure because we don't have a proof! @pag-crypto )",
              "createdAt": "2025-06-04T17:42:10Z",
              "updatedAt": "2025-06-04T17:42:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6steoA",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:49:18Z",
          "updatedAt": "2025-06-04T17:49:19Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "```suggestion\r\nWe don't actually know the requirements of _this_ function, we don't have a proof or \r\nrequirements laid out; the only example from Chempat is SHA3-256.\r\n\r\n* `KeyHash`: A KDF producing byte strings of length `KEM_H.Nss` (`KeyHash.Nout\r\n  == KEM_H.Nss`)\r\n```",
              "createdAt": "2025-06-04T17:49:19Z",
              "updatedAt": "2025-06-04T17:49:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ste1Q",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:49:36Z",
          "updatedAt": "2025-06-04T17:49:37Z",
          "comments": [
            {
              "originalPosition": 510,
              "body": "```suggestion\r\n    ss_H = KDF(concat(ss_PQ, ss_T, ct_PQ, ct_T, ekh, label))\r\n```",
              "createdAt": "2025-06-04T17:49:37Z",
              "updatedAt": "2025-06-04T17:49:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ste9B",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:49:50Z",
          "updatedAt": "2025-06-04T17:49:50Z",
          "comments": [
            {
              "originalPosition": 536,
              "body": "```suggestion\r\n    ss_H = KDF(concat(ss_PQ, ss_T, ct_PQ, ct_T, ekh, label))\r\n```",
              "createdAt": "2025-06-04T17:49:50Z",
              "updatedAt": "2025-06-04T17:49:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stfLJ",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:50:14Z",
          "updatedAt": "2025-06-04T17:50:15Z",
          "comments": [
            {
              "originalPosition": 554,
              "body": "```suggestion\r\n* `XOF`: A XOF producing byte strings of length `Group_T.Nseed +\r\n  KEM_PQ.Nseed` (`Expand.Nout == Group_T.Nseed + KEM_PQ.Nseed`)\r\n```",
              "createdAt": "2025-06-04T17:50:14Z",
              "updatedAt": "2025-06-04T17:50:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stfar",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:50:39Z",
          "updatedAt": "2025-06-04T17:50:39Z",
          "comments": [
            {
              "originalPosition": 608,
              "body": "```suggestion\r\n    seed_full = XOF(seed)\r\n```",
              "createdAt": "2025-06-04T17:50:39Z",
              "updatedAt": "2025-06-04T17:50:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stfqU",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:51:05Z",
          "updatedAt": "2025-06-04T17:51:05Z",
          "comments": [
            {
              "originalPosition": 636,
              "body": "```suggestion\r\n    ss_H = KDF(concat(ss_PQ, ss_T, ct_T, ek_T, Label))\r\n```",
              "createdAt": "2025-06-04T17:51:05Z",
              "updatedAt": "2025-06-04T17:51:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6stfxV",
          "commit": {
            "abbreviatedOid": "f0c20d5"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T17:51:16Z",
          "updatedAt": "2025-06-04T17:51:16Z",
          "comments": [
            {
              "originalPosition": 650,
              "body": "```suggestion\r\n    ss_H = KDF(concat(ss_PQ, ss_T, ct_T, ek_T, Label))\r\n```",
              "createdAt": "2025-06-04T17:51:16Z",
              "updatedAt": "2025-06-04T17:51:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sudvy",
          "commit": {
            "abbreviatedOid": "09473a3"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:25:55Z",
          "updatedAt": "2025-06-04T19:25:55Z",
          "comments": [
            {
              "originalPosition": 726,
              "body": "```suggestion\r\n> TODO: We need to provide more thorough description, and verify that\r\n> these requirements align with the requirements of the security proofs in the\r\n> literature, especially {{GHP2018}} and {{XWING}}.\r\n\r\n### Security Requirements for KEMs\r\n\r\nComponent KEMs MUST be IND-CCA-secure {{GHP2018}} {{XWING}}.\r\n\r\nFor instances of QSF, the component KEM MUST also be ciphertext second\r\npreimage resistant (C2PRI) {{XWING}}: this allows the component KEM\r\nencapsulation key and ciphertext to be left out from the KDF input. \r\n\r\n### Security Requirements for Groups\r\n\r\nThe groups MUST be modelable as nominal groups in which the strong\r\nDiffie-Hellman problem holds {{ABH+21}} {{XWING}}.\r\n\r\nThe Montgomery curves Curve25519 and Curve448 have been shown to be\r\nmodelable as nominal groups in {{ABH+21}} as well as showing the \r\n`X25519()` and `X448()` functions respectively pertain to the nominal\r\ngroup `exp(X, y)` function, specifically clamping secret keys when\r\nthey are generated, instead of clamping secret keys together with\r\nexponentiation.\r\n\r\n<!-- The short Weierstrass NIST curves have also been shown to be\r\nmodelable as nominal groups but I can't find the reference --> \r\n\r\n### Security Requirements for KDFs\r\n\r\nKDFs MUST be secure pseudorandom functions (PRFs) when keyed with\r\nthe shared secret output from the post-quantum IND-CCA-secure\r\nKEM component algorithm in QSF {{XWING}} or any of the component\r\nIND-CCA-secure KEMs when used in KitchenSink {{GHP2018}} or\r\nPreHash.\r\n\r\nKDFs must be secure instances of random oracles in the ROM and\r\nQROM {{GHP2018}} {{XWING}}. Proofs of indifferentiability from\r\nrandom oracles {{MRH03 https://eprint.iacr.org/2003/161.pdf}}\r\ngive good confidence here, as any function proven indifferentiable\r\nfrom a random oracle is resistant against collision, first, and\r\nsecond preimage attacks {{need a good cite here}}. An indifferentiability\r\nbound guarantees security against specific attacks. Although\r\nindifferentiability does not capture all properties of a random\r\noracle {{RSS11 https://eprint.iacr.org/2011/339.pdf}}, indifferentiability\r\nstill remains the best way to rule out structural attacks.\r\n\r\nSponge-based constructions such as SHA-3 have been shown to be\r\nindifferentiable against classical {{BDP+08 https://www.iacr.org/archive/eurocrypt2008/49650180/49650180.pdf}}\r\nas well as quantum adversaries \r\n{{ACM+25 https://eprint.iacr.org/2025/731.pdf}}. \r\n\r\nHKDF has been shown to be indifferentiable from a random oracle under\r\nspecific constraints {{LBB20 https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8806752}}: \r\n\r\n- that HMAC is indifferentiable from a random oracle,\r\nwhich for HMAC-SHA-256 has been shown in {{}} {{DRS+13 https://eprint.iacr.org/2013/382.pdf}}, assuming the\r\ncompression function underlying SHA-256 is a random oracle,\r\nwhich it is indifferentiably when used prefix-free.\r\n\r\n- the values of `HKDF`'s `IKM` input do not collide with\r\nvalues of `info` `||` `0x01`. This MUST be enforced by the\r\nconcrete instantiations that use `HKDF` as its KDF. \r\n\r\nThe choice of the KDF security level SHOULD be made based on the\r\nsecurity level provided by the constituent KEMs. The KDF SHOULD\r\nat least have the security level of the strongest constituent KEM.\r\n\r\n### Security Requirements for XOFs\r\n\r\nXOFs accept arbitrary bitstrings as input, and produce\r\na caller-chosen-length prefix of an infinite bitstream\r\ndeterministically defined by the input.\r\n\r\n<!-- requirements: secure PRF, bc key material? -->\r\n\r\n```",
              "createdAt": "2025-06-04T19:25:55Z",
              "updatedAt": "2025-06-04T19:25:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6suev0",
          "commit": {
            "abbreviatedOid": "75615b1"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:27:17Z",
          "updatedAt": "2025-06-04T19:27:18Z",
          "comments": [
            {
              "originalPosition": 785,
              "body": "@br-hale @pag-crypto @bwesterb ",
              "createdAt": "2025-06-04T19:27:17Z",
              "updatedAt": "2025-06-04T19:27:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sufDd",
          "commit": {
            "abbreviatedOid": "75615b1"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:27:48Z",
          "updatedAt": "2025-06-04T19:27:49Z",
          "comments": [
            {
              "originalPosition": 678,
              "body": "```suggestion\r\n### Ciphertext Second Preimage Resistant (C2PRI) Security\r\n\r\nAlso known in the literature as ciphertext collision resistance (CCR).\r\n```",
              "createdAt": "2025-06-04T19:27:49Z",
              "updatedAt": "2025-06-04T19:27:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sufv2",
          "commit": {
            "abbreviatedOid": "5681b6f"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:29:02Z",
          "updatedAt": "2025-06-04T19:29:02Z",
          "comments": [
            {
              "originalPosition": 716,
              "body": "```suggestion\r\n### Security Requirements for KEMs {#security-kems}\r\n```",
              "createdAt": "2025-06-04T19:29:02Z",
              "updatedAt": "2025-06-04T19:29:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6suf0m",
          "commit": {
            "abbreviatedOid": "5681b6f"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:29:11Z",
          "updatedAt": "2025-06-04T19:29:12Z",
          "comments": [
            {
              "originalPosition": 724,
              "body": "```suggestion\r\n### Security Requirements for Groups {#security-groups}\r\n```",
              "createdAt": "2025-06-04T19:29:11Z",
              "updatedAt": "2025-06-04T19:29:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6suf6P",
          "commit": {
            "abbreviatedOid": "5681b6f"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:29:20Z",
          "updatedAt": "2025-06-04T19:29:21Z",
          "comments": [
            {
              "originalPosition": 739,
              "body": "```suggestion\r\n### Security Requirements for KDFs {#security-kdfs}\r\n```",
              "createdAt": "2025-06-04T19:29:20Z",
              "updatedAt": "2025-06-04T19:29:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sugA0",
          "commit": {
            "abbreviatedOid": "5681b6f"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:29:33Z",
          "updatedAt": "2025-06-04T19:29:33Z",
          "comments": [
            {
              "originalPosition": 779,
              "body": "```suggestion\r\n### Security Requirements for XOFs {#security-xofs}\r\n```",
              "createdAt": "2025-06-04T19:29:33Z",
              "updatedAt": "2025-06-04T19:29:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sui11",
          "commit": {
            "abbreviatedOid": "2d3ea4f"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:34:05Z",
          "updatedAt": "2025-06-04T19:34:05Z",
          "comments": [
            {
              "originalPosition": 792,
              "body": "```suggestion\r\n## Security Properties of Hybrid KEMs\r\n\r\n[[ TODO: Define which properties are provided by the hybrid KEMs in this\r\ndocument, and citations to the papers with the corresponding proofs. ]]\r\n\r\nAll generic constructions in this document produce IND-CCA-secure KEMs \r\nwhen correctly instantiated concretely with cryptographic components that\r\nmeet the respective security requirements. Any changes to the routines,\r\nincluding key generation/derivation, are not guaranteed to produce\r\nsecure results.\r\n\r\n```",
              "createdAt": "2025-06-04T19:34:05Z",
              "updatedAt": "2025-06-04T19:34:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sujmc",
          "commit": {
            "abbreviatedOid": "6b0cc87"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:35:12Z",
          "updatedAt": "2025-06-04T19:35:12Z",
          "comments": [
            {
              "originalPosition": 665,
              "body": "```suggestion\r\n## Security Properties {#security-properties}\r\n```",
              "createdAt": "2025-06-04T19:35:12Z",
              "updatedAt": "2025-06-04T19:35:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sujsA",
          "commit": {
            "abbreviatedOid": "6b0cc87"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:35:23Z",
          "updatedAt": "2025-06-04T19:35:23Z",
          "comments": [
            {
              "originalPosition": 667,
              "body": "```suggestion\r\n### IND-CCA Security {#ind-cca}\r\n```",
              "createdAt": "2025-06-04T19:35:23Z",
              "updatedAt": "2025-06-04T19:35:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sujzS",
          "commit": {
            "abbreviatedOid": "6b0cc87"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:35:36Z",
          "updatedAt": "2025-06-04T19:35:36Z",
          "comments": [
            {
              "originalPosition": 676,
              "body": "```suggestion\r\n### Ciphertext Second Preimage Resistant (C2PRI) Security {#c2pri}\r\n```",
              "createdAt": "2025-06-04T19:35:36Z",
              "updatedAt": "2025-06-04T19:35:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6suj6V",
          "commit": {
            "abbreviatedOid": "6b0cc87"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:35:48Z",
          "updatedAt": "2025-06-04T19:35:48Z",
          "comments": [
            {
              "originalPosition": 687,
              "body": "```suggestion\r\n## Binding Properties {#binding-properties}\r\n```",
              "createdAt": "2025-06-04T19:35:48Z",
              "updatedAt": "2025-06-04T19:35:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6sum1u",
          "commit": {
            "abbreviatedOid": "bbad377"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:40:50Z",
          "updatedAt": "2025-06-04T19:40:51Z",
          "comments": [
            {
              "originalPosition": 276,
              "body": "Concrete suggestions:\r\n\r\nGHP - named after GHP2018 which is the foundation of all other combiners basically\r\nPRE - prehash\r\nQSF - same as QSF in X-Wing\r\n\r\nShort, mostly meaningful, done.\r\n\r\n```suggestion\r\n* GHP - A generic construction that is suitable for use with any choice\r\n  of traditional and PQ KEMs, with minimal security assumptions on the\r\n  constituent KEMs\r\n* PRE - A performance optimization of HashEverything for the case\r\n  where encapsulation keys are large and frequently reused\r\n* QSF - An optimized generic construction for the case where the traditional\r\n  component is a nominal group and the PQ component has strong binding\r\n  properties\r\n```\r\n\r\n@bifurcation @br-hale @bwesterb @pag-crypto ",
              "createdAt": "2025-06-04T19:40:50Z",
              "updatedAt": "2025-06-04T19:40:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6suwT4",
          "commit": {
            "abbreviatedOid": "bbad377"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-04T19:54:44Z",
          "updatedAt": "2025-06-04T19:54:44Z",
          "comments": [
            {
              "originalPosition": 310,
              "body": "```suggestion\r\nThe KEMs, groups, KDFs, and XOFs MUST meet the security requirements in {{#security-requirements}}.\r\n```",
              "createdAt": "2025-06-04T19:54:44Z",
              "updatedAt": "2025-06-04T19:54:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6tK6lh",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-06T15:43:39Z",
          "updatedAt": "2025-06-06T15:43:39Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "Done",
              "createdAt": "2025-06-06T15:43:39Z",
              "updatedAt": "2025-06-06T15:43:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 31,
      "id": "PR_kwDOMmhxws6ZaT7W",
      "title": "#22 with changes on top",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/31",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-06T15:39:59Z",
      "updatedAt": "2025-06-06T19:08:29Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "9e85013a9da7226a2e54c098de0ab5043034a158",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "target-kem-vs-curve",
      "headRefOid": "c43bc983d6a4cae8d0d499d8928c8931143cb163",
      "closedAt": "2025-06-06T19:08:28Z",
      "mergedAt": "2025-06-06T19:08:28Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "c43bc983d6a4cae8d0d499d8928c8931143cb163"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 32,
      "id": "PR_kwDOMmhxws6Z6wsX",
      "title": "Light edits and comments",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/32",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-10T19:34:28Z",
      "updatedAt": "2025-06-12T14:44:48Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "c43bc983d6a4cae8d0d499d8928c8931143cb163",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "light-edit",
      "headRefOid": "b82ec08aeff02fe73582d7bf938d26c0cb009d39",
      "closedAt": "2025-06-12T14:44:38Z",
      "mergedAt": "2025-06-12T14:44:38Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "b97199aeb9977f9b525eaba9d7f46c080a9c27c3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6t6kxT",
          "commit": {
            "abbreviatedOid": "b82ec08"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T15:54:45Z",
          "updatedAt": "2025-06-11T15:54:45Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "\ud83d\udc4d",
              "createdAt": "2025-06-11T15:54:45Z",
              "updatedAt": "2025-06-11T15:54:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6t6lP7",
          "commit": {
            "abbreviatedOid": "b82ec08"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T15:55:08Z",
          "updatedAt": "2025-06-11T15:55:08Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "\ud83d\udc4d",
              "createdAt": "2025-06-11T15:55:08Z",
              "updatedAt": "2025-06-11T15:55:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6t6lch",
          "commit": {
            "abbreviatedOid": "b82ec08"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T15:55:23Z",
          "updatedAt": "2025-06-11T15:55:23Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "\ud83d\udc4d",
              "createdAt": "2025-06-11T15:55:23Z",
              "updatedAt": "2025-06-11T15:55:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6t6ll9",
          "commit": {
            "abbreviatedOid": "b82ec08"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T15:55:35Z",
          "updatedAt": "2025-06-11T15:55:35Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "ok",
              "createdAt": "2025-06-11T15:55:35Z",
              "updatedAt": "2025-06-11T15:55:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6t6nM2",
          "commit": {
            "abbreviatedOid": "b82ec08"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T15:57:48Z",
          "updatedAt": "2025-06-11T15:57:49Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Unfortunately no straightforward name from GHP18, and similarly no real equivalent name in the close one in NIST SP 800-227 # (15), which is kind of why there's no one naming rubric",
              "createdAt": "2025-06-11T15:57:49Z",
              "updatedAt": "2025-06-11T15:57:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6t6obH",
          "commit": {
            "abbreviatedOid": "b82ec08"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T15:59:32Z",
          "updatedAt": "2025-06-11T15:59:32Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "\ud83d\udc4d",
              "createdAt": "2025-06-11T15:59:32Z",
              "updatedAt": "2025-06-11T15:59:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6uIwdV",
          "commit": {
            "abbreviatedOid": "b82ec08"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-12T14:44:32Z",
          "updatedAt": "2025-06-12T14:44:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 33,
      "id": "PR_kwDOMmhxws6aHPHm",
      "title": "Add a reference implementation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/33",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds a reference implementation of the hybrid KEMs.  There are traits for the constituent parts, and then the hybrid KEMs are defined generically over types that implement the constituent parts.\r\n\r\nMy first experiment with Claude Code.  All of the code is Claude-written, I did not open any of the files in an editor.  I have not reviewed, will review as part of this PR.\r\n\r\nFull transcript:\r\n\r\n* Can you read files from the parent directory?\r\n* Make a new Cargo/Rust project in this directory.  it should be in a directory called reference-implementation, and the name of the module should be \r\n* Change directory into reference-implementation\r\n* Add a trait for the KEM interface described in ../draft-irtf-cfrg-hybrid-kems.md\r\n* Give the constants more descriptive names\r\n* Add traits for the KDF and PRG interfaces described in ../draft-irtf-cfrg-hybrid-kems.md\r\n* Rename kem.rs to something more appropriate\r\n* Now write an implementation of the GHP hybrid KEM.  The hybrid KEM should be generic over its constituents, using the traits to bound the generic \r\n* Please add real implementations for the placeholders.  You can assume that the keys, ciphertexts, and shared secrets serialize to fixed-length byte \r\n* Instead of to_bytes / from_bytes, I would use serialize and deserialize.  WHen you serialize, use slices instead of Vec.\r\n* Go back to traits.rs.  Don't use a mutable reference argument, return a reference.  And the serialize methods don't need to be fallible.\r\n* For the hybrid serialization, make the same assumption that the deserialization methods make, namely that the T and PQ serializations are \r\n* In order to make serialization and deserialization easier, change the hybrid keys and ciphertexts just to hold a byte string.\r\n* The generate_key_pair method on GHP needs to actually use random data.  You should take a randomness source as input and use it.  Update the KEM \r\n* Use the CryptoRng trait instead of Rng\r\n* Don't use Rng, just CryptoRng\r\n* Use the latest version\r\n* Don't use RngCore\r\n* Don't use Rng.  Just CryptoRng.\r\n* Thanks, great work.  Now take the GHP implementation, and use it to generate implementations of the PRE and QSF hybrid KEMs\r\n* Move the NominalGroup trait to traits.rs\r\n* Have all of the hybrid KEMs use the same error type.  Split it out into error.rs if you think that's appropriate.\r\n* Are there any placeholders left in the codebase?\r\n* Replace the placeholder in qsf.rs with real randomness\r\n* Instead of using thread_rng, encaps should take an rng argument\r\n* Don't update the trait, remove it from the qsf.rs file.\r\n* Convert this crate from a binary crate to a library crate\r\n* commit the current state to a new branch called vibe-code\r\n* Create test implementations of the traits in traits.rs.  These implementations should fulfill the API in the simplest way possible, without being \r\n* Factor out the test functions so that they can be reused with other implementations.  But keep the tests.\r\n* Now add tests for each of the hybrid KEMs.  You should be able to reuse the KEM tests you already created.\r\n* Commit the tests\r\n* /exit \r\n\r\n",
      "createdAt": "2025-06-11T22:54:14Z",
      "updatedAt": "2025-07-16T21:47:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "bbd7ed2497a7ead6c0a3a7f9dc735995fa56f283",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "vibe-code",
      "headRefOid": "487f991671e27ad76d6b2b11b005e6be4f96a9ef",
      "closedAt": "2025-07-16T21:47:20Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "* Add a github actions workflow that runs \"cargo test\" on the reference implementation\r\n* Change the name of the workflow to \"Test reference implementation\".  Only run if something in the reference implementation has changed.\r\n* Commit and push the change\r\n* /exit",
          "createdAt": "2025-06-11T23:02:54Z",
          "updatedAt": "2025-06-11T23:02:54Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "Is this one defunct in favor of https://github.com/cfrg/draft-irtf-cfrg-concrete-hybrid-kems/pull/8 now? ",
          "createdAt": "2025-06-30T07:47:47Z",
          "updatedAt": "2025-06-30T07:47:47Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of https://github.com/cfrg/draft-irtf-cfrg-concrete-hybrid-kems/pull/8",
          "createdAt": "2025-07-01T18:14:14Z",
          "updatedAt": "2025-07-01T18:14:14Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't think we should have an implementation of generic hybrid KEM frameworks. This would be like having a reference implementation of Fiat-Shamir, or an FO transform\u2014 these are abstract recipes used to construct _concrete_ schemes. The code in this branch can be moved over into [cfrg/draft-irtf-cfrg-concrete-hybrid-kems#8](https://github.com/cfrg/draft-irtf-cfrg-concrete-hybrid-kems/pull/8) as an internal abstraction if you wish, I do not think it belongs here as a software artifact, that is not a good idea IMO\u2014 the final concrete KEMs that use this stuff as an internal detail are the artifacts. As the framework implementations cannot do any cryptographic assertions that the components slotted in fulfill the security requirements of each framework, this should not be a composable artifact.\r\n\r\n@bwesterb since this is a cryptographic software / abstraction opinion, what do you think? Am I being too cautious?",
          "createdAt": "2025-07-01T20:50:46Z",
          "updatedAt": "2025-07-01T20:50:46Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't have a strong opinion here.  On the one hand, the Rust type system is nice enough that it can capture these abstractions.  On the other hand, we're not going to do anything with it in this repo (like generate test vectors) and since the Rust doesn't check security properties, I can see understand some concern about people making inappropriate combos.\r\n\r\nI went ahead and moved this code over to the concrete hybrid KEMs PR, https://github.com/cfrg/draft-irtf-cfrg-concrete-hybrid-kems/pull/8.",
          "createdAt": "2025-07-16T21:47:20Z",
          "updatedAt": "2025-07-16T21:47:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6uLTW4",
          "commit": {
            "abbreviatedOid": "68e63ed"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Partial review; going to fix up the traits and try again.",
          "createdAt": "2025-06-12T18:16:19Z",
          "updatedAt": "2025-06-12T18:49:56Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Should have newlines at the end of files.",
              "createdAt": "2025-06-12T18:16:20Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 7,
              "body": "@dconnolly - Note that you are listed here, presumably based on the spec editor list.  LMK if you'd like to be removed.",
              "createdAt": "2025-06-12T18:17:54Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 6,
              "body": "It would be good for this type to implement Error.",
              "createdAt": "2025-06-12T18:19:21Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 6,
              "body": "The default type for KeyHashError should be `()`.",
              "createdAt": "2025-06-12T18:19:57Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 16,
              "body": "This type is unused, and should be deleted.",
              "createdAt": "2025-06-12T18:21:17Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 26,
              "body": "This should just be `default()`.",
              "createdAt": "2025-06-12T18:29:22Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 153,
              "body": "These `bytes` variables can just be inlined.",
              "createdAt": "2025-06-12T18:33:14Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 160,
              "body": "This is a major deficiency.  What we should do here is:\r\n* Define a trait `Label` that has an associated const `LABEL`\r\n* Make this trait implementation conditional on the hybrid KEM implementing the `Label` trait\r\n* Likewise for the PRE and QSF KEMs",
              "createdAt": "2025-06-12T18:34:45Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 92,
              "body": "This method should go in another trait that is dependent on this trait.",
              "createdAt": "2025-06-12T18:41:13Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 95,
              "body": "Instead of requiring all of these methods, we should just bound the EncapsulationKey / DecapsulationKey / Ciphertext types with `TryFrom<&[u8]> + AsRef<[u8]>`.",
              "createdAt": "2025-06-12T18:43:28Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 119,
              "body": "Instead of this method, we should just bound DecapsulationKey with `AsRef<Self::EncapsulationKey>`.",
              "createdAt": "2025-06-12T18:45:21Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            },
            {
              "originalPosition": 161,
              "body": "As with the KEM interface types, we should just make the Scalar and Element types serializable.",
              "createdAt": "2025-06-12T18:49:33Z",
              "updatedAt": "2025-06-12T18:49:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xampO",
          "commit": {
            "abbreviatedOid": "487f991"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I don't think we should have an implementation of generic hybrid KEM frameworks. This would be like having a reference implementation of Fiat-Shamir, or an FO transform\u2014 these are abstract recipes used to construct _concrete_ schemes. The code in this branch can be moved over into https://github.com/cfrg/draft-irtf-cfrg-concrete-hybrid-kems/pull/8 as an internal abstraction if you wish, I do not think it belongs here as a software artifact, that is not a good idea IMO\u2014 the final concrete KEMs that use this stuff as an internal detail are the artifacts. As the framework implementations cannot do any cryptographic assertions that the components slotted in fulfill the security requirements of each framework, this should not be a composable artifact.",
          "createdAt": "2025-07-01T18:17:34Z",
          "updatedAt": "2025-07-01T18:21:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 34,
      "id": "PR_kwDOMmhxws6aO4kQ",
      "title": "Remove mention of SHA3 as a PRG",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/34",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It's fine and secure but it's a little confusing as an interface mismatch",
      "createdAt": "2025-06-12T14:32:36Z",
      "updatedAt": "2025-06-12T16:40:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "6ae56af64bc8fa78a2d0565f29a3742603a854fd",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "dconnolly-patch-1",
      "headRefOid": "5f4296b86e19d67f997caadaf5737aa36809bb12",
      "closedAt": "2025-06-12T16:40:20Z",
      "mergedAt": "2025-06-12T16:40:20Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "111a9143fcff1146d73b4c3c74c7cdcca170c77a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 39,
      "id": "PR_kwDOMmhxws6beEpT",
      "title": "draft-04, Release candidate 1",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/39",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR represents my pre-flight review of the generic doc.  Only a few changes of note:\r\n\r\n* Changed \"construction\" to \"scheme\" basically everywhere, to avoid the idea that we are defining concrete constructions\r\n* Addressed and deleted comments\r\n* Moved the EncapsDerand interface to an appendix, since it is only used for test vectors\r\n* Moved the TODOs to issues and deleted the notes in the doc.",
      "createdAt": "2025-06-20T20:15:01Z",
      "updatedAt": "2025-06-24T17:14:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "111a9143fcff1146d73b4c3c74c7cdcca170c77a",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "rc1",
      "headRefOid": "991bacfa7b81db84469f961347af16ec276e26a0",
      "closedAt": "2025-06-24T17:14:38Z",
      "mergedAt": "2025-06-24T17:14:38Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "64643b80c2b91d502e26e7527f47268c22898ff4"
      },
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "_hello welcome to the bikeshed paint shop_\n\nI'm cool with replacing 'construction' everywhere, but I'm not sure about 'scheme', which tends to be used in literature for concrete designs etc. 'Framework' is used in the X-Wing paper about QSF and in other papers as in 'generic frameworks'...",
          "createdAt": "2025-06-20T22:40:27Z",
          "updatedAt": "2025-06-20T22:40:27Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I 100% do not care what word we use.  \ud83d\udeb2\ud83c\udfe0\ud83d\udd8c\ufe0f\r\n",
          "createdAt": "2025-06-22T18:25:18Z",
          "updatedAt": "2025-06-22T18:25:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6vrXr1",
          "commit": {
            "abbreviatedOid": "b4613b4"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-20T22:36:59Z",
          "updatedAt": "2025-06-20T22:47:31Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\nschemes provide strong security properties as long as the undelying\n```\n",
              "createdAt": "2025-06-20T22:37:00Z",
              "updatedAt": "2025-06-20T22:47:31Z"
            },
            {
              "originalPosition": 53,
              "body": "\ud83d\udc4d",
              "createdAt": "2025-06-20T22:45:30Z",
              "updatedAt": "2025-06-20T22:47:31Z"
            },
            {
              "originalPosition": 381,
              "body": "\ud83d\udc4d",
              "createdAt": "2025-06-20T22:47:09Z",
              "updatedAt": "2025-06-20T22:47:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6vvWdU",
          "commit": {
            "abbreviatedOid": "9440864"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-23T01:02:14Z",
          "updatedAt": "2025-06-23T01:02:14Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "\ud83c\udf89\ud83d\udeb2",
              "createdAt": "2025-06-23T01:02:14Z",
              "updatedAt": "2025-06-23T01:02:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6vvWlg",
          "commit": {
            "abbreviatedOid": "9440864"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-23T01:03:05Z",
          "updatedAt": "2025-06-23T01:03:05Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\ncombining a traditional component algorithm and a PQ KEM. Hybrid KEMs built using these\r\n```",
              "createdAt": "2025-06-23T01:03:05Z",
              "updatedAt": "2025-06-23T01:03:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6vvW2B",
          "commit": {
            "abbreviatedOid": "c558833"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-23T01:04:08Z",
          "updatedAt": "2025-06-23T01:04:08Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nframeworks for constructing hybrid Key Encapsulation Mechanisms (KEMs) based\r\non combining a traditional component algorithm and a PQ KEM. Hybrid KEMs built\r\nusing these frameworks provide strong security properties as long as the underlying\r\n```",
              "createdAt": "2025-06-23T01:04:08Z",
              "updatedAt": "2025-06-23T01:04:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6vvW-Y",
          "commit": {
            "abbreviatedOid": "bf817d6"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-23T01:05:01Z",
          "updatedAt": "2025-06-23T01:05:01Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "```suggestion\r\nThese frameworks share a common overall structure, differing mainly in how they\r\n```",
              "createdAt": "2025-06-23T01:05:01Z",
              "updatedAt": "2025-06-23T01:05:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6wG0OB",
          "commit": {
            "abbreviatedOid": "270c87e"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-24T16:34:24Z",
          "updatedAt": "2025-06-24T16:34:24Z",
          "comments": [
            {
              "originalPosition": 380,
              "body": "```suggestion\r\nBy design, the calls to `KDF` in these frameworks and usage anywhere else\r\n```",
              "createdAt": "2025-06-24T16:34:24Z",
              "updatedAt": "2025-06-24T16:34:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6wHNzE",
          "commit": {
            "abbreviatedOid": "991bacf"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-24T17:14:29Z",
          "updatedAt": "2025-06-24T17:14:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 40,
      "id": "PR_kwDOMmhxws6bmg6L",
      "title": "A few editorial contributions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/40",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The draft is in good shape otherwise.",
      "createdAt": "2025-06-23T06:32:35Z",
      "updatedAt": "2025-06-24T17:19:14Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "111a9143fcff1146d73b4c3c74c7cdcca170c77a",
      "headRepository": "martinthomson/hybrid-kems",
      "headRefName": "notation-domain",
      "headRefOid": "8a70fa36bb5bf6293fea4b66db24e47fa7e23cfc",
      "closedAt": "2025-06-24T17:19:13Z",
      "mergedAt": "2025-06-24T17:19:13Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "b2b13d6afe972a9019217f68cdbb3163e3b8d9f3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6wHQvs",
          "commit": {
            "abbreviatedOid": "226e617"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-24T17:18:20Z",
          "updatedAt": "2025-06-24T17:18:21Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nA set is denoted by listing values in braces: `{a,b,c}`.\r\n\r\nA vector of set elements of length `n` is denoted with exponentiation,\r\nsuch as for the `n`-bit value: {0,1}<sup>n</sup>.\r\n\r\nDrawing uniformly at random from an `n`-bit vector into a value `x`\r\nis denoted: x $\u2190 {0,1}<sup>n</sup>.\r\n\r\nA function `f` that maps from one domain to another is denoted\r\nusing a right arrow to separate inputs from outputs: f : inputs \u2192 outputs.\r\n```",
              "createdAt": "2025-06-24T17:18:20Z",
              "updatedAt": "2025-06-24T17:18:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6wHRLC",
          "commit": {
            "abbreviatedOid": "8a70fa3"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-24T17:19:04Z",
          "updatedAt": "2025-06-24T17:19:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 41,
      "id": "PR_kwDOMmhxws6bmp_E",
      "title": "Remove duplicate CCR mention",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/41",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This pull request needs a Big Lebowski quote.",
      "createdAt": "2025-06-23T06:49:20Z",
      "updatedAt": "2025-06-24T17:19:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "111a9143fcff1146d73b4c3c74c7cdcca170c77a",
      "headRepository": "martinthomson/hybrid-kems",
      "headRefName": "say-it-twice",
      "headRefOid": "6b230801f46160df979219e34a6e4fc47009164c",
      "closedAt": "2025-06-24T17:19:52Z",
      "mergedAt": "2025-06-24T17:19:52Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "1771cce6e26a225c701a727917a43454a034ea29"
      },
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> And was there anything of value in the pull request?\n\n> Oh, yeah. A tape deck, some [CCR] tapes, and there was a, uh, my briefcase",
          "createdAt": "2025-06-23T07:48:39Z",
          "updatedAt": "2025-06-23T07:48:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6wHRlW",
          "commit": {
            "abbreviatedOid": "6b23080"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-24T17:19:42Z",
          "updatedAt": "2025-06-24T17:19:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 42,
      "id": "PR_kwDOMmhxws6bmt-w",
      "title": "Correct some variable names",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/42",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I didn't check thoroughly, but these stood out.",
      "createdAt": "2025-06-23T06:56:17Z",
      "updatedAt": "2025-06-25T05:18:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "111a9143fcff1146d73b4c3c74c7cdcca170c77a",
      "headRepository": "martinthomson/hybrid-kems",
      "headRefName": "ghp-seed_full",
      "headRefOid": "595d63629d3e5a346fa9cbab8b39fb20554b935e",
      "closedAt": "2025-06-24T17:20:52Z",
      "mergedAt": "2025-06-24T17:20:51Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "9102c7275d46a889aae881d3c4bb7cfcedb4017b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6wHSLP",
          "commit": {
            "abbreviatedOid": "595d636"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-24T17:20:45Z",
          "updatedAt": "2025-06-24T17:20:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 43,
      "id": "PR_kwDOMmhxws6bm0ez",
      "title": "Some abstract editing",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/43",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This was originally just a typo fix for a missing 'r'.  But then you had a \"we\", that was unnecessary.\r\n\r\nI split this into two paragraphs, but I'm going to suggest that you delete the first one entirely.  Everything that is needed is in the second.",
      "createdAt": "2025-06-23T07:08:42Z",
      "updatedAt": "2025-06-24T22:32:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "9102c7275d46a889aae881d3c4bb7cfcedb4017b",
      "headRepository": "martinthomson/hybrid-kems",
      "headRefName": "abstract-typo",
      "headRefOid": "05659e673c6b66e2b3d4464c74000068c34b6444",
      "closedAt": "2025-06-24T22:32:42Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation wdyt",
          "createdAt": "2025-06-24T17:47:34Z",
          "updatedAt": "2025-06-24T17:47:34Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm good either way.  Slight preference for removing the first paragraph, but also happy to keep it if people like context.",
          "createdAt": "2025-06-24T21:31:26Z",
          "updatedAt": "2025-06-24T21:31:26Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 45,
      "id": "PR_kwDOMmhxws6b8mCN",
      "title": "Abstract",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/45",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "there was a git booboo",
      "createdAt": "2025-06-24T22:32:11Z",
      "updatedAt": "2025-06-24T22:32:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "9102c7275d46a889aae881d3c4bb7cfcedb4017b",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "abstract",
      "headRefOid": "7b270cc80ece59ccce06694733e4587374113526",
      "closedAt": "2025-06-24T22:32:40Z",
      "mergedAt": "2025-06-24T22:32:40Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "791528bf542ac7538b43bcd801a578f71c0731e8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 46,
      "id": "PR_kwDOMmhxws6b-UBe",
      "title": "Cite how prime order groups like p256 etc are examples of nominal groups",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/46",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #37",
      "createdAt": "2025-06-25T03:44:15Z",
      "updatedAt": "2025-06-25T03:44:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "791528bf542ac7538b43bcd801a578f71c0731e8",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "nominal",
      "headRefOid": "6baf8bf8a82dd67cd67acb5144fc030aa6dd7b4b",
      "closedAt": "2025-06-25T03:44:38Z",
      "mergedAt": "2025-06-25T03:44:38Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "bbd7ed2497a7ead6c0a3a7f9dc735995fa56f283"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 50,
      "id": "PR_kwDOMmhxws6cJCaQ",
      "title": "A stab at 'why these generic frameworks' section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/50",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #48",
      "createdAt": "2025-06-26T00:00:08Z",
      "updatedAt": "2025-07-07T23:23:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "6183080e4c32287080e8de6b9ba16cac6bf547c3",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "expand-on-framework-choices",
      "headRefOid": "3582bb35ec74368ca1ccc1bd99677bf9bbbfc7cf",
      "closedAt": "2025-07-07T23:23:40Z",
      "mergedAt": "2025-07-07T23:23:40Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "cec4902d0f359034077ca2eadc89ec4295bd41b8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 51,
      "id": "PR_kwDOMmhxws6cJHRy",
      "title": "Add appendix with QSF BIND proof sketches written  by Bas Westerbaan",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/51",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@bwesterb \r\n\r\nResolves https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/52",
      "createdAt": "2025-06-26T00:20:25Z",
      "updatedAt": "2025-10-20T21:45:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "bbd7ed2497a7ead6c0a3a7f9dc735995fa56f283",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "sketch-of-qsf-bind-proofs",
      "headRefOid": "97b93ab05bfe4211178e4a039018fb2917279ba3",
      "closedAt": "2025-10-20T21:45:11Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 57,
      "id": "PR_kwDOMmhxws6ce8jC",
      "title": "DRAFT: started rewrite of security properties subsection. added some proof sketches",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/57",
      "state": "MERGED",
      "author": "pag-crypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "WRiteup is still work in progress, but i thought people would like to see what i'm working on, to give feedback. STill TODO is fleshing out proofs for leak-bind. \r\n\r\nResolves #47",
      "createdAt": "2025-06-27T20:13:49Z",
      "updatedAt": "2025-07-03T19:37:24Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "bbd7ed2497a7ead6c0a3a7f9dc735995fa56f283",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "sec-props",
      "headRefOid": "a23aadda8347ae7a4f2ba93174ca7fe6499ea84d",
      "closedAt": "2025-07-03T19:37:23Z",
      "mergedAt": "2025-07-03T19:37:23Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "6183080e4c32287080e8de6b9ba16cac6bf547c3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6xCDGr",
          "commit": {
            "abbreviatedOid": "694d555"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T06:54:30Z",
          "updatedAt": "2025-06-30T06:54:30Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n## Cryptographic Security Goals for Hybrid KEMs {#security-properties}\r\n```",
              "createdAt": "2025-06-30T06:54:30Z",
              "updatedAt": "2025-06-30T06:54:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCFj5",
          "commit": {
            "abbreviatedOid": "09afb00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T06:58:44Z",
          "updatedAt": "2025-06-30T06:58:44Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "For KEMs with uniform messages IND-CCA1 and IND-CCA2 are [equivalent](https://eprint.iacr.org/2007/036.pdf#section.C) anyway, most of the literature just calls it (~IND-CCA2) IND-CCA now including NIST ",
              "createdAt": "2025-06-30T06:58:44Z",
              "updatedAt": "2025-06-30T07:30:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCLwB",
          "commit": {
            "abbreviatedOid": "09afb00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:09:33Z",
          "updatedAt": "2025-06-30T07:09:34Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "SHOULD is normative language and since we haven't targeted MAL-BIND and aren't giving our reader explicitly MAL-BIND options in this document (some of the concrete instances in the other document may be) we should probably take this out",
              "createdAt": "2025-06-30T07:09:33Z",
              "updatedAt": "2025-06-30T07:09:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCMlZ",
          "commit": {
            "abbreviatedOid": "09afb00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:10:55Z",
          "updatedAt": "2025-06-30T07:10:55Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "todo: distinguish key binding from the things we call X-BIND-K-[CT/PK] above but haven't explained yet",
              "createdAt": "2025-06-30T07:10:55Z",
              "updatedAt": "2025-06-30T07:10:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCaYu",
          "commit": {
            "abbreviatedOid": "09afb00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:32:51Z",
          "updatedAt": "2025-06-30T07:32:52Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "```suggestion\r\nThe KDF MUST be indifferentiable from a random oracle (RO) {{MRH03}}, even to a quantum attacker {{QROM}}.\r\n```",
              "createdAt": "2025-06-30T07:32:52Z",
              "updatedAt": "2025-06-30T07:32:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCcCx",
          "commit": {
            "abbreviatedOid": "3fd6fe6"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:35:29Z",
          "updatedAt": "2025-06-30T07:35:30Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "```suggestion\r\n### Security Properties of PRE {#security-pre}\r\n```",
              "createdAt": "2025-06-30T07:35:30Z",
              "updatedAt": "2025-06-30T07:35:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCc3G",
          "commit": {
            "abbreviatedOid": "fc8fc80"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:36:45Z",
          "updatedAt": "2025-06-30T07:36:45Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "```suggestion\r\nThe PRE hybrid KEM framework uses a function KeyHash to generate a short digest of the encapsulation keys.\r\nFor IND-CCA2 of PRE, this function must be collision-resistant.\r\n```",
              "createdAt": "2025-06-30T07:36:45Z",
              "updatedAt": "2025-06-30T07:36:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCdJ7",
          "commit": {
            "abbreviatedOid": "fc8fc80"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:37:11Z",
          "updatedAt": "2025-06-30T07:37:12Z",
          "comments": [
            {
              "originalPosition": 154,
              "body": "```suggestion\r\n## Security Properties of Hybrid KEMs Frameworks\r\n```",
              "createdAt": "2025-06-30T07:37:11Z",
              "updatedAt": "2025-06-30T07:37:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCddG",
          "commit": {
            "abbreviatedOid": "fc8fc80"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:37:40Z",
          "updatedAt": "2025-06-30T07:37:40Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "todo: define broken",
              "createdAt": "2025-06-30T07:37:40Z",
              "updatedAt": "2025-06-30T07:37:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCgWY",
          "commit": {
            "abbreviatedOid": "fc8fc80"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:42:07Z",
          "updatedAt": "2025-06-30T07:42:07Z",
          "comments": [
            {
              "originalPosition": 164,
              "body": "```suggestion\r\nThis document's exact GHP and PRE constructions do not have IND-CCA2 analyses; the GHP paper gives a slightly different version, namely they do not include the public keys in the KDF. However, we argue that the proof goes through with trivial modifications if the public keys are included in the KDF. The relevant step is claim 3 of Theorem 1, which reduces to the split-key pseudorandomness of the KDF. (GHP call the KDF a \"core\" function, and denote it as W.) We observe that adding the public keys to the inputs only changes the concrete contents of the reduction's queries to its oracle. Since the reduction chooses the public keys itself, they can be added to the oracle inputs, and the remainder of the proof goes through unmodified.\r\n```",
              "createdAt": "2025-06-30T07:42:07Z",
              "updatedAt": "2025-06-30T07:42:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCiYX",
          "commit": {
            "abbreviatedOid": "8fa0ae0"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:45:16Z",
          "updatedAt": "2025-06-30T07:45:16Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "```suggestion\r\nWe also argue that this extension applies again with trivial modifications to prove security of PRE. Observe that the only difference between GHP and PRE is prehashing of the encapsulation keys. As long as the hash function is collision-resistant, any event that happens in the IND-CCA2 game of GHP happens only with negligible probability in the IND-CCA2 game of PRE.\r\n\r\nWe reiterate that modulo some low-level technical details, our requirement that the KDF is indifferentiable from an RO implies that, in the random oracle model (ROM), the KDF used in GHP and PRE meets the split-key pseudorandomness property used in GHP's analysis.\r\n```",
              "createdAt": "2025-06-30T07:45:16Z",
              "updatedAt": "2025-06-30T07:45:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xCjIt",
          "commit": {
            "abbreviatedOid": "8fa0ae0"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T07:46:26Z",
          "updatedAt": "2025-06-30T07:46:26Z",
          "comments": [
            {
              "originalPosition": 174,
              "body": "```suggestion\r\nTherefore all three hybrid KEMs in this document are IND-CCA2 when instantiated with\r\ncryptographic components that meet the security requirements described above. Any\r\nchanges to the algorithms, including key generation/derivation, are not guaranteed\r\nto produce secure results.\r\n```",
              "createdAt": "2025-06-30T07:46:26Z",
              "updatedAt": "2025-06-30T07:46:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xF58l",
          "commit": {
            "abbreviatedOid": "09afb00"
          },
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T12:52:44Z",
          "updatedAt": "2025-06-30T12:52:45Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Ah thanks for pointing this out - let's just use IND-CCA then",
              "createdAt": "2025-06-30T12:52:44Z",
              "updatedAt": "2025-06-30T12:52:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xF85F",
          "commit": {
            "abbreviatedOid": "8fa0ae0"
          },
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-30T12:56:22Z",
          "updatedAt": "2025-06-30T12:56:22Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Oops I just realized this text is not correct - I didn't complete the thought. The statement about \"negligible probability\" is obviously false. It should say \"happens with only negligibly different probability\". ",
              "createdAt": "2025-06-30T12:56:22Z",
              "updatedAt": "2025-06-30T12:56:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xW_xf",
          "commit": {
            "abbreviatedOid": "09afb00"
          },
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-01T14:03:25Z",
          "updatedAt": "2025-07-01T14:03:25Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I'm ok taking it out - i wasn't sure the capital \"SHOULD\" was appropriate anyway; i just wanted to make sure readers will see it.",
              "createdAt": "2025-07-01T14:03:25Z",
              "updatedAt": "2025-07-01T14:03:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xZZZA",
          "commit": {
            "abbreviatedOid": "192b6ef"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-01T16:54:20Z",
          "updatedAt": "2025-07-01T16:54:20Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-07-01T16:54:20Z",
              "updatedAt": "2025-07-01T16:54:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xpuDL",
          "commit": {
            "abbreviatedOid": "eae6869"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T20:13:30Z",
          "updatedAt": "2025-07-02T20:13:30Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "@bwesterb @pag-crypto I added this paragraph, wdyt",
              "createdAt": "2025-07-02T20:13:30Z",
              "updatedAt": "2025-07-02T20:13:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xpwT_",
          "commit": {
            "abbreviatedOid": "eae6869"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T20:16:28Z",
          "updatedAt": "2025-07-02T20:16:28Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "@pag-crypto this is my cite for 'the KDF must be indiff. in the ROM and the QROM'",
              "createdAt": "2025-07-02T20:16:28Z",
              "updatedAt": "2025-07-02T20:16:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xpyk7",
          "commit": {
            "abbreviatedOid": "eae6869"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T20:19:50Z",
          "updatedAt": "2025-07-02T20:19:50Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "@pag-crypto @br-hale @bwesterb I wrote this to motivate why BIND-K-CT and BIND-K-PK specifically, thoughts?",
              "createdAt": "2025-07-02T20:19:50Z",
              "updatedAt": "2025-07-02T20:19:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xp0Ro",
          "commit": {
            "abbreviatedOid": "eae6869"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T20:23:08Z",
          "updatedAt": "2025-07-02T20:23:08Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "```suggestion\ndistinguish whether it is given the \"real\" secret output from `Encaps()`, or a\n```",
              "createdAt": "2025-07-02T20:23:08Z",
              "updatedAt": "2025-07-02T20:23:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xp096",
          "commit": {
            "abbreviatedOid": "5e441f4"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T20:24:32Z",
          "updatedAt": "2025-07-02T20:24:33Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "```suggestion\nFor KEMs, IND-CCA requires that no efficient adversary, given a ciphertext\nobtained by running `Encaps()` with an honestly-generated public key, can\ndistinguish whether it is given the \"real\" secret output from `Encaps()`, or a\nrandom string unrelated to the `Encaps()` call that created that\nciphertext. (Readers should note that this definition is slightly different\nthan the corresponding one for public-key encryption {{RS92}}.)\n```",
              "createdAt": "2025-07-02T20:24:32Z",
              "updatedAt": "2025-07-02T20:24:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xp1Oo",
          "commit": {
            "abbreviatedOid": "5e441f4"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T20:25:03Z",
          "updatedAt": "2025-07-02T20:25:04Z",
          "comments": [
            {
              "originalPosition": 196,
              "body": "```suggestion\nThe LEAK-BIND-K-PK and LEAK-BIND-K-CT properties independently allow using\n```",
              "createdAt": "2025-07-02T20:25:04Z",
              "updatedAt": "2025-07-02T20:25:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xp10K",
          "commit": {
            "abbreviatedOid": "5e441f4"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T20:26:13Z",
          "updatedAt": "2025-07-02T20:26:13Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "```suggestion\r\na KEM shared secret such that the likelihood of finding a colliding value with the\r\nencapsulation key used in its computation or the ciphertext used in its\r\ncomputation is negligible. Such properties are attractive when integrating\r\n```",
              "createdAt": "2025-07-02T20:26:13Z",
              "updatedAt": "2025-07-02T20:26:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xp2Bb",
          "commit": {
            "abbreviatedOid": "5e441f4"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T20:26:37Z",
          "updatedAt": "2025-07-02T20:26:37Z",
          "comments": [
            {
              "originalPosition": 202,
              "body": "```suggestion\r\ninput to a protocol key schedule for example, without necessarily also needing\r\n```",
              "createdAt": "2025-07-02T20:26:37Z",
              "updatedAt": "2025-07-02T20:26:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xp2Ho",
          "commit": {
            "abbreviatedOid": "5e441f4"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T20:26:48Z",
          "updatedAt": "2025-07-02T20:26:49Z",
          "comments": [
            {
              "originalPosition": 203,
              "body": "```suggestion\r\nto include the much larger ciphertext or the encapsulation key to be\r\n```",
              "createdAt": "2025-07-02T20:26:48Z",
              "updatedAt": "2025-07-02T20:26:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xp2ey",
          "commit": {
            "abbreviatedOid": "5e441f4"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T20:27:31Z",
          "updatedAt": "2025-07-02T20:27:32Z",
          "comments": [
            {
              "originalPosition": 219,
              "body": "```suggestion\r\nSecurity properties that were considered and not included in these designs:\r\n```",
              "createdAt": "2025-07-02T20:27:31Z",
              "updatedAt": "2025-07-02T20:27:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xp1Ei",
          "commit": {
            "abbreviatedOid": "eae6869"
          },
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T20:24:45Z",
          "updatedAt": "2025-07-02T20:28:36Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Yes, I think this is a good cite, though I'm not very familiar with work on the QROM. You can also cite the original QROM paper: https://eprint.iacr.org/2010/428.pdf",
              "createdAt": "2025-07-02T20:24:45Z",
              "updatedAt": "2025-07-02T20:28:36Z"
            },
            {
              "originalPosition": 208,
              "body": "I like this, though I think we should anticipate some pushback on this point. ",
              "createdAt": "2025-07-02T20:28:27Z",
              "updatedAt": "2025-07-02T20:28:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xp5vc",
          "commit": {
            "abbreviatedOid": "5e441f4"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T20:33:35Z",
          "updatedAt": "2025-07-02T20:33:35Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\n    target: https://www.usenix.org/system/files/usenixsecurity24-bhargavan.pdf\r\n  CAMPBELL25:\r\n    date: 2025\r\n    target: https://mailarchive.ietf.org/arch/msg/cfrg/qp_YxofDEl5fN6W7Xyab-juwaCc/\r\n```",
              "createdAt": "2025-07-02T20:33:35Z",
              "updatedAt": "2025-07-02T20:33:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xp7nr",
          "commit": {
            "abbreviatedOid": "3ff8219"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T20:37:10Z",
          "updatedAt": "2025-07-02T20:37:10Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "```suggestion\r\nRoughly, C2PRI {{XWING}} says that an adversary given an honestly-generated\r\nkey pair (sk, pk) and the result of an *honest* Encaps(pk) - call it k, c -\r\ncannot find a _distinct_ c' such that Decaps(sk, c') = k. A related notion has\r\nalso been described as chosen-ciphertext resistance (CCR) {{CDM23}}. C2PRI targets preimage-resistance, whereas CCR targets collision-resistance {{CAMPBELL25}}.\r\n```",
              "createdAt": "2025-07-02T20:37:10Z",
              "updatedAt": "2025-07-02T20:37:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xp77s",
          "commit": {
            "abbreviatedOid": "d937289"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T20:37:46Z",
          "updatedAt": "2025-07-02T20:37:47Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "```suggestion\r\nRoughly, C2PRI {{XWING}} says that an adversary given an honestly-generated\r\nkey pair (sk, pk) and the result of an *honest* Encaps(pk) - call it k, c -\r\ncannot find a _distinct_ c' such that Decaps(sk, c') = k. A related notion has\r\nalso been described as chosen-ciphertext resistance (CCR) {{CDM23}}. C2PRI targets\r\npreimage-resistance, whereas CCR targets collision-resistance {{CAMPBELL25}}.\r\n```",
              "createdAt": "2025-07-02T20:37:46Z",
              "updatedAt": "2025-07-02T20:37:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6xqCVb",
          "commit": {
            "abbreviatedOid": "dd11148"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T20:49:30Z",
          "updatedAt": "2025-07-02T20:49:30Z",
          "comments": [
            {
              "originalPosition": 327,
              "body": "```suggestion\r\ndigest of the encapsulation keys.  This function MUST be collision-resistant.\r\n```",
              "createdAt": "2025-07-02T20:49:30Z",
              "updatedAt": "2025-07-02T20:49:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6x4y85",
          "commit": {
            "abbreviatedOid": "a23aadd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-03T19:36:34Z",
          "updatedAt": "2025-07-03T19:36:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 59,
      "id": "PR_kwDOMmhxws6c9Lro",
      "title": "Restore seeds including expandDecapsulationKey() as a private common algorithm",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/59",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #58 ",
      "createdAt": "2025-07-01T18:12:55Z",
      "updatedAt": "2025-07-01T19:25:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "bbd7ed2497a7ead6c0a3a7f9dc735995fa56f283",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "restore-seeds",
      "headRefOid": "156f15b255ca60dfb19ff39011459df015180637",
      "closedAt": "2025-07-01T19:25:57Z",
      "mergedAt": "2025-07-01T19:25:57Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "d858664bd83f4bd52ae74b06c729e319f162e774"
      },
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "@bwesterb ",
          "createdAt": "2025-07-01T18:13:08Z",
          "updatedAt": "2025-07-01T18:13:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6xbNHE",
          "commit": {
            "abbreviatedOid": "156f15b"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-01T19:22:37Z",
          "updatedAt": "2025-07-01T19:22:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 61,
      "id": "PR_kwDOMmhxws6d1vcL",
      "title": "Names of sections on in-scope frameworks",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/61",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-07T23:30:10Z",
      "updatedAt": "2025-07-07T23:30:50Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "cec4902d0f359034077ca2eadc89ec4295bd41b8",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "sections",
      "headRefOid": "ffb72d9da3aab63410b4987ffae97527df13d717",
      "closedAt": "2025-07-07T23:30:48Z",
      "mergedAt": "2025-07-07T23:30:48Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "14201a23e2095accd453b0424c6f9d00181a66b9"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 62,
      "id": "PR_kwDOMmhxws6d3JO0",
      "title": "Some more tpos",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/62",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-08T04:02:25Z",
      "updatedAt": "2025-07-08T04:03:31Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "14201a23e2095accd453b0424c6f9d00181a66b9",
      "headRepository": "martinthomson/hybrid-kems",
      "headRefName": "typos",
      "headRefOid": "abcb1da80b9dc73721907526b85f3c40de72295c",
      "closedAt": "2025-07-08T04:03:31Z",
      "mergedAt": "2025-07-08T04:03:31Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "dfd2c7d5d6ad253fccc642d0f30597178a176a39"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6ykdbn",
          "commit": {
            "abbreviatedOid": "abcb1da"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-08T04:03:27Z",
          "updatedAt": "2025-07-08T04:03:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 63,
      "id": "PR_kwDOMmhxws6d3O0l",
      "title": "I was going to do more of this,",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/63",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "but there are too many.\r\n\r\nYou might consider removing the \".pdf\" extension from the URLs, so that people can hit the ePrint landing page instead.",
      "createdAt": "2025-07-08T04:20:00Z",
      "updatedAt": "2025-07-21T00:32:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "dfd2c7d5d6ad253fccc642d0f30597178a176a39",
      "headRepository": "martinthomson/hybrid-kems",
      "headRefName": "ghp-citation",
      "headRefOid": "43451fac5e35f95a7f22e3fc6f850466d7a31962",
      "closedAt": "2025-07-21T00:32:03Z",
      "mergedAt": "2025-07-21T00:32:03Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "429398e84b7919cc5b29d7d7d22e66c64253d3a5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws60-ZeF",
          "commit": {
            "abbreviatedOid": "43451fa"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-21T00:31:57Z",
          "updatedAt": "2025-07-21T00:31:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 65,
      "id": "PR_kwDOMmhxws6eGr0N",
      "title": "fix typos",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/65",
      "state": "MERGED",
      "author": "tomato42",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix few typos in the document",
      "createdAt": "2025-07-09T11:09:45Z",
      "updatedAt": "2025-07-21T00:33:25Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "dfd2c7d5d6ad253fccc642d0f30597178a176a39",
      "headRepository": "tomato42/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "fix-typo",
      "headRefOid": "3512bf8f39b79a9d4a9082e3262ef699f00341bd",
      "closedAt": "2025-07-21T00:33:25Z",
      "mergedAt": "2025-07-21T00:33:25Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "c2864600b5cbc8a59eb59a1893efcfb5c2117793"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws60-ZqP",
          "commit": {
            "abbreviatedOid": "f45a0d1"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-21T00:32:51Z",
          "updatedAt": "2025-07-21T00:32:51Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nduplicating the 'label' per concrete instance with fixed parameters. This\r\njustifies modeling them as independent functions even if instantiated by the\r\n```",
              "createdAt": "2025-07-21T00:32:51Z",
              "updatedAt": "2025-07-21T00:32:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws60-Zs_",
          "commit": {
            "abbreviatedOid": "3512bf8"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-21T00:33:13Z",
          "updatedAt": "2025-07-21T00:33:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 68,
      "id": "PR_kwDOMmhxws6fRCID",
      "title": "Align constant definitions with seed format for hybrid decapsulation key",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/68",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The pseudocode for the schemes uses the seed format for the hybrid decapsulation key, but the description of `Ndk` for the hybrid KEMs still says that is is the sum of the constituents.  It should instead say `Ndk = Nseed`.  This PR makes this change, and in general, rearranges the constant definitions to be a little nicer.",
      "createdAt": "2025-07-16T21:44:52Z",
      "updatedAt": "2025-07-21T00:31:29Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "dfd2c7d5d6ad253fccc642d0f30597178a176a39",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "ndk",
      "headRefOid": "0746501964913963b93075946965a4a767f1fb6d",
      "closedAt": "2025-07-21T00:31:27Z",
      "mergedAt": "2025-07-21T00:31:27Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "4bf5f7131ba5a4b50b1058681c704dcf9f8ba38d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws60bJzK",
          "commit": {
            "abbreviatedOid": "0746501"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-16T21:55:00Z",
          "updatedAt": "2025-07-16T21:55:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws60ex-w",
          "commit": {
            "abbreviatedOid": "0746501"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-17T05:43:15Z",
          "updatedAt": "2025-07-17T05:43:15Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws60-Zak",
          "commit": {
            "abbreviatedOid": "0746501"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-21T00:31:23Z",
          "updatedAt": "2025-07-21T00:31:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 69,
      "id": "PR_kwDOMmhxws6fREFG",
      "title": "Add Paul Grubbs as co-author",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/69",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Major omission from the latest draft.\r\n\r\n@pag-crypto - What email address would you like to put on this? \n\nResolves #66",
      "createdAt": "2025-07-16T21:49:48Z",
      "updatedAt": "2025-07-21T00:30:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "dfd2c7d5d6ad253fccc642d0f30597178a176a39",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "grubbs",
      "headRefOid": "6a8a0829d9f0a54592e04a673d7b6cbb23c4093f",
      "closedAt": "2025-07-21T00:30:52Z",
      "mergedAt": "2025-07-21T00:30:52Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "f3c7a8623becf0ef4c79aa2bbebc9d540f394f43"
      },
      "comments": [
        {
          "author": "pag-crypto",
          "authorAssociation": "COLLABORATOR",
          "body": "paulgrubbs12@gmail.com",
          "createdAt": "2025-07-17T00:40:29Z",
          "updatedAt": "2025-07-17T00:40:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws60-ZU6",
          "commit": {
            "abbreviatedOid": "6a8a082"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-21T00:30:29Z",
          "updatedAt": "2025-07-21T00:30:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 70,
      "id": "PR_kwDOMmhxws6irR9-",
      "title": "Always use (PQ, T) order",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/70",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #67 ",
      "createdAt": "2025-08-08T00:12:05Z",
      "updatedAt": "2025-08-28T15:23:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "c2864600b5cbc8a59eb59a1893efcfb5c2117793",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "pqt",
      "headRefOid": "2f4e3913f31591b8a7bb5930f3a87723349cd6a8",
      "closedAt": "2025-08-28T15:23:09Z",
      "mergedAt": "2025-08-28T15:23:09Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "1267d644b60904bdfe7f32b268883cadf3e2ddac"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws66eq0i",
          "commit": {
            "abbreviatedOid": "2f4e391"
          },
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-18T14:21:49Z",
          "updatedAt": "2025-08-18T14:21:50Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "The new formulation is interoperable with X-Wing \ud83d\udc4d ",
              "createdAt": "2025-08-18T14:21:50Z",
              "updatedAt": "2025-08-18T14:21:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws68rB8q",
          "commit": {
            "abbreviatedOid": "2f4e391"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-08-28T15:23:02Z",
          "updatedAt": "2025-08-28T15:23:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 71,
      "id": "PR_kwDOMmhxws6l3Ry1",
      "title": "Remove PRE",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/71",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Feedback at the CFRG meeting at IETF 123 was that it was important to folks to have a single target, and folks did not care about the optimization that pre-hashing provides.",
      "createdAt": "2025-08-28T19:12:48Z",
      "updatedAt": "2025-08-28T19:54:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "1267d644b60904bdfe7f32b268883cadf3e2ddac",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "no-pre",
      "headRefOid": "84adafc60d914e44a58303f4101fa4256411a958",
      "closedAt": "2025-08-28T19:54:01Z",
      "mergedAt": "2025-08-28T19:54:01Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "16df319bd90bc10540c4e109ec7de020bb7e8f5d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws68ueCj",
          "commit": {
            "abbreviatedOid": "84adafc"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-08-28T19:53:30Z",
          "updatedAt": "2025-08-28T19:53:30Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws68ueRm",
          "commit": {
            "abbreviatedOid": "84adafc"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-08-28T19:53:48Z",
          "updatedAt": "2025-08-28T19:53:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 72,
      "id": "PR_kwDOMmhxws6l3yfG",
      "title": "Uniform API",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/72",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It has become clear in CFRG discussions that the limitation of GHP to only KEM+KEM and QSF to only KEM+Group is insufficient.  Folks want to instantiate QSF with RSA (see, e.g., [LAMPS](https://www.ietf.org/archive/id/draft-ietf-lamps-pq-composite-kem-07.html)), and folks being conservative about C2PRI want to instantiate GHP with ECDH groups in the T component.\r\n\r\nWe thus end up with four combinations to consider:\r\n1. PQ(IND-CCA + C2PRI) + T(Group) = QSF\r\n2. PQ(IND-CCA + C2PRI) + T(KEM)\r\n3. PQ(IND-CCA only) + T(Group)\r\n4. PQ(IND-CCA only) + T(KEM) = GHP\r\n\r\nThis PR attempts to present these options in a unified framework, with two binary choices: KEM vs. group, and C2PRI or not.  This PR does not make the corresponding changes to the Security Considerations, which will need to be updated to match if we adopt this approach.\r\n\r\nThe framework here could be simpler if we defined a DH-based thing that satisfied the KEM interface.  This would be problematic, however, because the resulting \"KEM\" would not be IND-CCA.  Given this fact, and the fact that defining such a \"KEM\" would take up about the same amount of space as the repetition we currently have, I think the current approach of keeping these separate is the right one.",
      "createdAt": "2025-08-28T20:12:10Z",
      "updatedAt": "2025-10-16T15:54:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "f048e2bf9b36857dc10fa10e8023df77518d95f5",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "uniform-api",
      "headRefOid": "56f58b1a12d1069eeea1b31ea9f806b025a52a9d",
      "closedAt": "2025-10-16T15:54:39Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws7AYMxW",
          "commit": {
            "abbreviatedOid": "1e70a84"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T06:10:31Z",
          "updatedAt": "2025-09-16T06:10:31Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I do not think this simplification / uniform API helps us much and seems squishier and more unclear than explicit generic frameworks; we can explicitly write them all (4?) down and that's it",
              "createdAt": "2025-09-16T06:10:31Z",
              "updatedAt": "2025-09-16T06:10:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7AYQ9C",
          "commit": {
            "abbreviatedOid": "1e70a84"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T06:13:17Z",
          "updatedAt": "2025-09-16T06:13:17Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "I definitely think removing the names is a step back, names help",
              "createdAt": "2025-09-16T06:13:17Z",
              "updatedAt": "2025-09-16T06:13:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7AYTCc",
          "commit": {
            "abbreviatedOid": "1e70a84"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T06:14:42Z",
          "updatedAt": "2025-09-16T06:14:42Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Neither if these functions are explicitly called?",
              "createdAt": "2025-09-16T06:14:42Z",
              "updatedAt": "2025-09-16T06:14:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7AZfnZ",
          "commit": {
            "abbreviatedOid": "1e70a84"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T07:03:41Z",
          "updatedAt": "2025-09-16T07:03:41Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "We have names, we just name the combiner functions instead of the frameworks.  There are two binary parameters to configure, (1) Group or KEM for T and (2) which combiner, and the former is clear from the T component.  So for example, X-Wing would be (ML-KEM-768, X25519, PQImplicit).",
              "createdAt": "2025-09-16T07:03:41Z",
              "updatedAt": "2025-09-16T07:03:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7AZiHu",
          "commit": {
            "abbreviatedOid": "1e70a84"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T07:05:41Z",
          "updatedAt": "2025-09-16T07:05:41Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "They're the two options for the `Combiner` component of the hybrid KEM, [as specified below](https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/72/files#diff-f4a6c39bb3f52913d3a7bc10dc3628c226ba57bf16bde130f806a1fefd38e6b8R581).",
              "createdAt": "2025-09-16T07:05:41Z",
              "updatedAt": "2025-09-16T07:05:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7AZl3l",
          "commit": {
            "abbreviatedOid": "1e70a84"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T07:08:23Z",
          "updatedAt": "2025-09-16T07:08:23Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "\"Squishier\" in what sense?\n\nRewriting all of this for 4 frameworks is a lot of duplication, especially when the only variations are (a) whether you use group or KEM names for effectively the same things and (b) what you put in the KDF.",
              "createdAt": "2025-09-16T07:08:23Z",
              "updatedAt": "2025-09-16T07:08:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7Ew7Vg",
          "commit": {
            "abbreviatedOid": "56f58b1"
          },
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-03T22:18:35Z",
          "updatedAt": "2025-10-03T22:18:35Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "```suggestion\n`KEM_PQ`, `KEM_T`, `PRG`, and `KDF` MUST meet the interfaces\n```",
              "createdAt": "2025-10-03T22:18:35Z",
              "updatedAt": "2025-10-03T22:18:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7Ew8gU",
          "commit": {
            "abbreviatedOid": "56f58b1"
          },
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-03T22:20:43Z",
          "updatedAt": "2025-10-03T22:20:43Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "Should Nss also be the max of KEM_PQ and KEM_T?",
              "createdAt": "2025-10-03T22:20:43Z",
              "updatedAt": "2025-10-03T22:20:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7Ew_f_",
          "commit": {
            "abbreviatedOid": "56f58b1"
          },
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-03T22:26:17Z",
          "updatedAt": "2025-10-03T22:26:22Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "Likely elsewhere as well.\n```suggestion\n    (ct_PQ, ss_PQ) = KEM_PQ.Encap(ek_PQ)\n```",
              "createdAt": "2025-10-03T22:26:17Z",
              "updatedAt": "2025-10-03T22:26:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 73,
      "id": "PR_kwDOMmhxws6l4FIU",
      "title": "Add a section on separate key generation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/73",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It is apparently very important to the LAMPS community to be able to deploy hybrid KEMs without the \"shared seed\" key generation that is the preferred approach here.  (In other words, to make a hybrid KEM without your HSM having to be aware of it.)  This PR adds a section that discusses this option.  The idea being: You [OUGHT TO](https://rfcs.online/rfcs/rfc6919.html#section-4) do shared seed, but if you can't, here's how you adapt and the trade-offs.\r\n\r\n@dconnolly - I would appreciate suggested text for the security aspects.\r\n\r\nDepends on #72.  Read [this commit](https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/73/commits/25efa466175c1069c9f8b91fc4db404ec42bb235) for the more focused version.",
      "createdAt": "2025-08-28T20:50:00Z",
      "updatedAt": "2025-10-16T15:53:54Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "16df319bd90bc10540c4e109ec7de020bb7e8f5d",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "keygen",
      "headRefOid": "fca53b6746f72c5b5143c7ac48d26ec6739e63fc",
      "closedAt": "2025-10-16T15:53:54Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "NONE",
          "body": "I object to this characterization of the problem:\r\n\r\n> (In other words, to make a hybrid KEM without your HSM having to be aware of it.) \r\n\r\nThe problem is that NIST has been very clear that the seed MUST be direct output of a FIPS-approved and FIPS-certified DRBG. As soon as you do a shared seed and run it through a KDF to get the ML-KEM half of the seed, then that is no longer direct output of a FIPS-approved DRBG, and therefore whatever you do after that is, by definition, not ML-KEM as defined in FIPS 203 and you will not be able to get it certified. A hybrid with a shared seed in not allowed by NIST, full stop. So yes, I would say that having crypto that's compliant with FIPS 203 and capable of being FIPS certified is \"very important to the LAMPS community\". It's also going to be very important to any other community that needs to have crypto running in FIPS mode.\r\n\r\nI believe there is a similar argument on the Traditional side: doing an ECDH key derivation from a seed will not be FIPS-certifiable either because I don't think you'll find that algorithm described in any FIPS or SP document, or test vectors for it on the CAVP website / github repo.\r\n\r\nThis is not new, I gave a PQUIP presentation about it at IETF 121 (Dublin). See Topic #2 (starting on slide 15).\r\nhttps://datatracker.ietf.org/meeting/121/materials/slides-121-pquip-fips-issues-with-deploying-ml-kem-and-ml-dsa-04.pdf",
          "createdAt": "2025-08-29T04:12:34Z",
          "updatedAt": "2025-08-29T04:29:47Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "NONE",
          "body": "I think this PR is going in the right direction. I added a few comments.",
          "createdAt": "2025-08-29T04:21:16Z",
          "updatedAt": "2025-08-29T04:21:16Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> I object to this characterization of the problem:\n> \n> > (In other words, to make a hybrid KEM without your HSM having to be aware of it.) \n> \n> The problem is that NIST has been very clear that the seed MUST be direct output of a FIPS-approved and FIPS-certified DRBG. As soon as you do a shared seed and run it through a KDF to get the ML-KEM half of the seed, then that is no longer direct output of a FIPS-approved DRBG, and therefore whatever you do after that is, by definition, not ML-KEM as defined in FIPS 203 and you will not be able to get it certified. A hybrid with a shared seed in not allowed by NIST, full stop. So yes, I would say that having crypto that's compliant with FIPS 203 and capable of being FIPS certified is \"very important to the LAMPS community\". It's also going to be very important to any other community that needs to have crypto running in FIPS mode.\n> \n> I believe there is a similar argument on the Traditional side: doing an ECDH key derivation from a seed will not be FIPS-certifiable either because I don't think you'll find that algorithm described in any FIPS or SP document, or test vectors for it on the CAVP website / github repo.\n> \n> This is not new, I gave a PQUIP presentation about it at IETF 121 (Dublin). See Topic #2 (starting on slide 15).\n> https://datatracker.ietf.org/meeting/121/materials/slides-121-pquip-fips-issues-with-deploying-ml-kem-and-ml-dsa-04.pdf\n\nNIST folks have said presently the FIPS documents don't support handing seeds to ML-KEM.Keygen() that are not directly from a FIPS-approved DRBG, but have also said [\"We are considering supporting this, but that would require revising SP 800-133](https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/2EWXvBaE-Yw/m/SVjvxw0jBQAJ).\" I can't find a public update on the matter since those threads. Since NIST has already updated other FIPSes on keygen etc that has enabled hybrid (ie the order of secrets, allowing any FIPS secret to go first left-to-right and anything else, FIPS or not, to go after) I'm still interested if this may happen (in whatever document: lots of [public comments on 800-227 IPD](https://csrc.nist.gov/files/pubs/sp/800/227/ipd/docs/sp800-227-ipd-public-comments-received.pdf) supported seeds in different fashions).\n",
          "createdAt": "2025-08-31T22:03:07Z",
          "updatedAt": "2025-08-31T22:21:14Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws68ySOe",
          "commit": {
            "abbreviatedOid": "25efa46"
          },
          "author": "ounsworth",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-08-29T04:15:46Z",
          "updatedAt": "2025-08-29T04:21:25Z",
          "comments": [
            {
              "originalPosition": 194,
              "body": "You could mention, for example, if your deployment environment requires compliance with NIST; specifically FIPS 203, SP 800-56, and/or SP 800-227.",
              "createdAt": "2025-08-29T04:15:46Z",
              "updatedAt": "2025-08-29T04:21:25Z"
            },
            {
              "originalPosition": 215,
              "body": "I assume this will talk about binding properties?\r\nI am curious to see what you say here, because personally I don't believe that MAL-BIND has all that much practical value.\r\n\r\n\"Alice walks into a bar and gets a private key from Mallory...\"\r\n\r\n... but I'll try to keep an open mind about how this security notion fits into the bigger picture.",
              "createdAt": "2025-08-29T04:18:24Z",
              "updatedAt": "2025-08-29T04:21:25Z"
            },
            {
              "originalPosition": 208,
              "body": "Probably needs a paragraph about FIPS compliance and how FIPS 203 requires the seed to be direct output of a DRBG, so it will be impossible to do a shared seed keygen in a crypto library that is required to run in FIPS mode.",
              "createdAt": "2025-08-29T04:19:46Z",
              "updatedAt": "2025-08-29T04:21:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws69Dgry",
          "commit": {
            "abbreviatedOid": "25efa46"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-31T22:05:43Z",
          "updatedAt": "2025-08-31T22:05:43Z",
          "comments": [
            {
              "originalPosition": 215,
              "body": "LEAK does matter (Signal, etc) MAL allows /manipulation/ of private key material, LEAK is leakage of honestly-generated key material ",
              "createdAt": "2025-08-31T22:05:43Z",
              "updatedAt": "2025-08-31T22:05:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6_y4_E",
          "commit": {
            "abbreviatedOid": "25efa46"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-12T16:44:27Z",
          "updatedAt": "2025-09-12T16:44:28Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "I'm not going to opine on FIPS requirements.",
              "createdAt": "2025-09-12T16:44:28Z",
              "updatedAt": "2025-09-12T16:44:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6_y54b",
          "commit": {
            "abbreviatedOid": "25efa46"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-12T16:45:40Z",
          "updatedAt": "2025-09-12T16:45:47Z",
          "comments": [
            {
              "originalPosition": 215,
              "body": "I think there's pretty broad agreement that LEAK matters.  The point @ounsworth is making is (a) the function of shared-seed keygen is to upgrade from LEAK to MAL, and (b) does MAL matter?",
              "createdAt": "2025-09-12T16:45:40Z",
              "updatedAt": "2025-09-12T16:45:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 75,
      "id": "PR_kwDOMmhxws6mJRPl",
      "title": "Miscellaneous fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/75",
      "state": "MERGED",
      "author": "bluegate010",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- s/it induces/this induces/, as there's no definitive object of the sentence.\r\n- s/a fixed output lengths/fixed output lengths/\r\n- Consistent use of colons vs dashes.\r\n- s/^MUST provide the bit-security required/^PRGs used with the frameworks in this document MUST provide the bit-security required/\r\n- Clean up dangling references to a third hybrid KEM after PRE's removal in https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/71\r\n- In Security Considerations, remove a comma in order to clarify logical operator precedence.\r\n- Insert (what I believe to be) a missing period.",
      "createdAt": "2025-08-31T07:07:46Z",
      "updatedAt": "2025-09-12T16:49:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "16df319bd90bc10540c4e109ec7de020bb7e8f5d",
      "headRepository": "bluegate010/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "patch-2",
      "headRefOid": "bcda1711fea882a926980f14484283620dd277b8",
      "closedAt": "2025-09-12T16:49:08Z",
      "mergedAt": "2025-09-12T16:49:08Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b143401ed26565bb54960f6663ce267e193485a7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws69Cizk",
          "commit": {
            "abbreviatedOid": "f32106d"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-08-31T10:36:03Z",
          "updatedAt": "2025-08-31T10:36:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6_y2Xp",
          "commit": {
            "abbreviatedOid": "bcda171"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-12T16:41:08Z",
          "updatedAt": "2025-09-12T16:41:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 76,
      "id": "PR_kwDOMmhxws6mJUDL",
      "title": "Clarify HKDF parameterization requirements.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/76",
      "state": "MERGED",
      "author": "bluegate010",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "KEM instantiations that use HKDF as their KDF are on the hook for fully specifying all inputs.\r\n\r\nAddresses https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/74",
      "createdAt": "2025-08-31T07:23:13Z",
      "updatedAt": "2025-09-12T16:48:56Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "16df319bd90bc10540c4e109ec7de020bb7e8f5d",
      "headRepository": "bluegate010/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "hkdf-fix",
      "headRefOid": "ae7679622d9731d1ddc10b8fb4a723573078686b",
      "closedAt": "2025-09-12T16:48:56Z",
      "mergedAt": "2025-09-12T16:48:56Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f000557672ab04465b629f2ce1be8d06b4f51a0e"
      },
      "comments": [
        {
          "author": "bluegate010",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As it stands, none of the KEM instantiations in draft-irtf-cfrg-concrete-hybrid-kems actually use HKDF as their KDF. I'm assuming that the editors would elect to leave guidance on HKDF in this framework document just in case, but an alternative tack would be to just scrub all mention of HKDF from this document.",
          "createdAt": "2025-08-31T07:24:45Z",
          "updatedAt": "2025-08-31T07:24:45Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I think we should leave the door open to HKDF.",
          "createdAt": "2025-09-12T16:42:51Z",
          "updatedAt": "2025-09-12T16:42:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6_y3Rm",
          "commit": {
            "abbreviatedOid": "ae76796"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-12T16:42:24Z",
          "updatedAt": "2025-09-12T16:42:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 78,
      "id": "PR_kwDOMmhxws6ov55Z",
      "title": "Reframe and extend security considerations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/78",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR does some reframing of the security considerations to make them correspond a little better to the charter we have and hopefully make them more usable by lay folks.  The revised structure is:\r\n\r\n* Prerequisites: IND-CCA, C2PRI, SDH, binding properties, RO, PRG; with examples for each\r\n* Goals for hybrid KEM: Hybrid IND-CCA, LEAK-BIND-K-PK, LEAK-BIND-K-CT",
      "createdAt": "2025-09-16T02:18:51Z",
      "updatedAt": "2025-09-16T07:36:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "b143401ed26565bb54960f6663ce267e193485a7",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "sec-prop",
      "headRefOid": "85a97207ee97438b7fcb32607174f0925cfeae2f",
      "closedAt": "2025-09-16T07:36:01Z",
      "mergedAt": "2025-09-16T07:36:01Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "f048e2bf9b36857dc10fa10e8023df77518d95f5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws7AZc7y",
          "commit": {
            "abbreviatedOid": "848daff"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T07:01:40Z",
          "updatedAt": "2025-09-16T07:01:41Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "```suggestion\r\nWhether a given KEM provides IND-CCA depends on whether the attacker is assumed\r\nto have access to quantum computing capabilities or not (assuming the scheme \r\nis without bugs and the implementation is correct).  Post-quantum KEMs are\r\nintended to provide IND-CCA security against such an attacker.  Traditional KEMs\r\nare not.\r\n```",
              "createdAt": "2025-09-16T07:01:41Z",
              "updatedAt": "2025-09-16T07:01:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7AZfz4",
          "commit": {
            "abbreviatedOid": "2d1bf80"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T07:03:50Z",
          "updatedAt": "2025-09-16T07:03:51Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-09-16T07:03:50Z",
              "updatedAt": "2025-09-16T07:03:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7AZjLB",
          "commit": {
            "abbreviatedOid": "f8cca4a"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T07:06:27Z",
          "updatedAt": "2025-09-16T07:06:27Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "```suggestion\r\nIND-CCA is the standard security notion for KEMs; most PQ KEMs were explicitly designed\r\nto achieve this type of security against both a quantum attacker and a traditional one.\r\n```",
              "createdAt": "2025-09-16T07:06:27Z",
              "updatedAt": "2025-09-16T07:06:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7AZj7T",
          "commit": {
            "abbreviatedOid": "67b4c3d"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T07:07:01Z",
          "updatedAt": "2025-09-16T07:07:02Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "```suggestion\r\nIND-CCA is the standard security notion for KEMs; most PQ KEMs were\r\nexplicitly designed to achieve this type of security against both a\r\nquantum attacker and a traditional one.\r\n\r\nFor traditional algorithms, things are less clear.  The DHKEM construction in\r\n{{?RFC9180}} is an IND-CCA KEM based on Diffie-Hellman {{ABH+21}}, but \"raw\"\r\nephemeral-static Diffie-Hellman, interpreting the ephemeral public key as the\r\nciphertext, is not IND-CCA secure.  RSA-KEM is IND-CCA secure {{ISO18033-2}},\r\nand RSA-OAEP public-key encryption can be used to construct an IND-CCA KEM, but\r\n\"classical\" RSA encryption (RSAES-PKCS1-v1_5 as defined in {{?RFC8017}}) is not\r\neven IND-CCA secure as a public-key encryption algorithm.\r\n```",
              "createdAt": "2025-09-16T07:07:01Z",
              "updatedAt": "2025-09-16T07:07:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7AZmrn",
          "commit": {
            "abbreviatedOid": "5168a15"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T07:09:02Z",
          "updatedAt": "2025-09-16T07:09:03Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "```suggestion\r\n`Decaps(dk, ct) == ss` (where `dk` is the decapsulation key corresponding to\r\n```",
              "createdAt": "2025-09-16T07:09:02Z",
              "updatedAt": "2025-09-16T07:09:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7AZv1E",
          "commit": {
            "abbreviatedOid": "d86969d"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T07:16:05Z",
          "updatedAt": "2025-09-16T07:16:06Z",
          "comments": [
            {
              "originalPosition": 302,
              "body": "```suggestion\r\nThe framework given by {{CDM23}} refers to these properties with labels of the\r\nform X-BIND-P-Q.  The first element X is the model for how the attacker can\r\naccess the decapsulation key: HON for the case where the attacker never\r\naccesses the decapsulation key, LEAK for the case where the attacker has\r\naccess to the honestly-generated decapsulation key, or MAL for the case\r\nwhere the attacker can choose or manipulate the keys used by the victim. \r\nP,Q means that given the value P, it is hard to produce another Q that\r\ncauses Decaps to succeed. For example, LEAK-BIND-K-PK means that for a\r\ngiven shared secret (K), there is a unique encapsulation key (PK) that\r\ncould have produced it, even if all of the secrets involved are given to\r\nthe adversary after the encapsulation operation is completed (LEAK).\r\n```",
              "createdAt": "2025-09-16T07:16:05Z",
              "updatedAt": "2025-09-16T07:16:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7AZwqF",
          "commit": {
            "abbreviatedOid": "4751ba6"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T07:16:41Z",
          "updatedAt": "2025-09-16T07:16:42Z",
          "comments": [
            {
              "originalPosition": 307,
              "body": "```suggestion\r\nLEAK-level binding. Classic McEliece provides MAL-BIND-K-CT, but no assurance at\r\n```",
              "createdAt": "2025-09-16T07:16:42Z",
              "updatedAt": "2025-09-16T07:16:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7AZy5K",
          "commit": {
            "abbreviatedOid": "bce20df"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T07:18:12Z",
          "updatedAt": "2025-09-16T07:18:12Z",
          "comments": [
            {
              "originalPosition": 312,
              "body": "```suggestion\r\n<!-- todo: HQB doesn't need a secure RO, only secure PRF -->\r\nThe KDF used with a hybrid KEM MUST be indifferentiable from a random oracle\r\n```",
              "createdAt": "2025-09-16T07:18:12Z",
              "updatedAt": "2025-09-16T07:18:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7AZ2KQ",
          "commit": {
            "abbreviatedOid": "a736931"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T07:20:31Z",
          "updatedAt": "2025-09-16T07:20:31Z",
          "comments": [
            {
              "originalPosition": 351,
              "body": "```suggestion\r\n    * If using `PQImplicit`: `KEM_PQ` is C2PRI <!-- todo: rename -->\r\n```",
              "createdAt": "2025-09-16T07:20:31Z",
              "updatedAt": "2025-09-16T07:20:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7AZ4DT",
          "commit": {
            "abbreviatedOid": "34e3233"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T07:21:58Z",
          "updatedAt": "2025-09-16T07:21:59Z",
          "comments": [
            {
              "originalPosition": 353,
              "body": "```suggestion\r\n    * `KDF` is indifferentiable from a random oracle <!-- todo: the PQ proofs rely on PRF not RO... -->\r\n```",
              "createdAt": "2025-09-16T07:21:58Z",
              "updatedAt": "2025-09-16T07:21:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7AZ5Xd",
          "commit": {
            "abbreviatedOid": "34e3233"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T07:23:06Z",
          "updatedAt": "2025-09-16T07:23:06Z",
          "comments": [
            {
              "originalPosition": 348,
              "body": "```suggestion\r\n    * `KDF` is indifferentiable from a random oracle <!-- todo: GHP, QSH only need PRF security here... -->\r\n```",
              "createdAt": "2025-09-16T07:23:06Z",
              "updatedAt": "2025-09-16T07:23:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7AZ6fW",
          "commit": {
            "abbreviatedOid": "7338669"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T07:24:08Z",
          "updatedAt": "2025-09-16T07:24:08Z",
          "comments": [
            {
              "originalPosition": 365,
              "body": "```suggestion\r\nso MAL is too strong an attack model to address.\r\n```",
              "createdAt": "2025-09-16T07:24:08Z",
              "updatedAt": "2025-09-16T07:24:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7AZ8Bq",
          "commit": {
            "abbreviatedOid": "aac5c89"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-16T07:25:22Z",
          "updatedAt": "2025-09-16T07:25:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws7AaFZw",
          "commit": {
            "abbreviatedOid": "1846f97"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T07:32:14Z",
          "updatedAt": "2025-09-16T07:32:15Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "```suggestion\r\nWhether a given KEM provides IND-CCA depends on whether the attacker is assumed\r\nto have access to quantum computing capabilities or not (assuming the scheme\r\nis without bugs and the implementation is correct).  Post-quantum KEMs are\r\nintended to provide IND-CCA security against such an attacker.  Traditional KEMs\r\nare not.\r\n```",
              "createdAt": "2025-09-16T07:32:14Z",
              "updatedAt": "2025-09-16T07:32:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7AaGPt",
          "commit": {
            "abbreviatedOid": "1846f97"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-16T07:33:01Z",
          "updatedAt": "2025-09-16T07:33:01Z",
          "comments": [
            {
              "originalPosition": 297,
              "body": "```suggestion\r\nwhere the attacker can choose or manipulate the keys used by the victim.\r\n```",
              "createdAt": "2025-09-16T07:33:01Z",
              "updatedAt": "2025-09-16T07:33:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 79,
      "id": "PR_kwDOMmhxws6oyINa",
      "title": "Add HQB and QSH frameworks, proofs still pending",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/79",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-09-16T06:51:46Z",
      "updatedAt": "2025-10-16T15:53:00Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "f048e2bf9b36857dc10fa10e8023df77518d95f5",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "hqb-and-qsh",
      "headRefOid": "feb21f6d9021203f4d3c4b90dbc215c83146e1da",
      "closedAt": "2025-10-16T15:53:00Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "body": "@dconnolly mind rebasing this one? Also can you tell why the document is failing to build?",
          "createdAt": "2025-10-04T00:12:31Z",
          "updatedAt": "2025-10-04T00:12:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 82,
      "id": "PR_kwDOMmhxws6pJ2KM",
      "title": "Add an IANA registry of labels",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/82",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #81 ",
      "createdAt": "2025-09-17T20:50:27Z",
      "updatedAt": "2025-09-29T18:50:13Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "f048e2bf9b36857dc10fa10e8023df77518d95f5",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "iana",
      "headRefOid": "d0c382b0e1758592b58bd49c2474d5c4d874f183",
      "closedAt": "2025-09-29T18:50:12Z",
      "mergedAt": "2025-09-29T18:50:12Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "bc25ae8254fd60325580e9271fa74b4a63a198df"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws7Dj276",
          "commit": {
            "abbreviatedOid": "d0c382b"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Show of hands at the interim supported this",
          "createdAt": "2025-09-29T17:35:33Z",
          "updatedAt": "2025-09-29T17:35:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 85,
      "id": "PR_kwDOMmhxws6s9so8",
      "title": "Name individual frameworks, but call out subroutines",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/85",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR attempts a middle ground between #72 and #79, reflecting a few points of feedback from the 2026-09-25 CFRG interim:\r\n\r\n* Having names and section titles for specific frameworks helps implementors zero in on the right parts\r\n* But we should also minimize duplication across these sections\r\n\r\nTo do this, I made a section for each specific framework (using the \"two letter\" naming scheme), but having a section full of subroutines to capture the common structure.\r\n\r\nThis PR also:\r\n\r\n* Replaces #73 by addressing key generation and its variations.  \r\n* Adds a note about C2PRI to the introduction, reflecting mailing list feedback that an earlier mention was needed",
      "createdAt": "2025-10-09T19:53:14Z",
      "updatedAt": "2025-10-16T21:07:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "bc25ae8254fd60325580e9271fa74b4a63a198df",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "mid-72-79",
      "headRefOid": "470874d170df53cda4838330e86a34214c298cdf",
      "closedAt": "2025-10-16T21:07:37Z",
      "mergedAt": "2025-10-16T21:07:37Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "35b8534bf6f25878f1ade8f7d7da29530b2a5a74"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the thorough review @dconnolly.  I accepted most of your suggestions, and filed a couple of follow-ons for others.",
          "createdAt": "2025-10-16T21:07:32Z",
          "updatedAt": "2025-10-16T21:07:32Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws7G9JeX",
          "commit": {
            "abbreviatedOid": "b94e927"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-14T23:56:07Z",
          "updatedAt": "2025-10-14T23:56:07Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "We aren't defining concrete instances...",
              "createdAt": "2025-10-14T23:56:07Z",
              "updatedAt": "2025-10-14T23:56:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7G9Jqz",
          "commit": {
            "abbreviatedOid": "b94e927"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-14T23:56:45Z",
          "updatedAt": "2025-10-14T23:56:46Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I don't love this but what about: \n\n```suggestion\n# Hybrid KEMs (Generic) {#frameworks}\n```",
              "createdAt": "2025-10-14T23:56:45Z",
              "updatedAt": "2025-10-14T23:58:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7G9KhY",
          "commit": {
            "abbreviatedOid": "b94e927"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-14T23:59:26Z",
          "updatedAt": "2025-10-14T23:59:27Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\nThe choice of which framework to use when building a hybrid KEM will depend on\n```",
              "createdAt": "2025-10-14T23:59:26Z",
              "updatedAt": "2025-10-14T23:59:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7G9Ljy",
          "commit": {
            "abbreviatedOid": "6ed3157"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-15T00:02:53Z",
          "updatedAt": "2025-10-15T00:02:54Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "```suggestion\nInstantiate one of these frameworks creates a hybrid KEM `KEM_H` based on the following constituent\n```",
              "createdAt": "2025-10-15T00:02:54Z",
              "updatedAt": "2025-10-15T00:02:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7G9MQ1",
          "commit": {
            "abbreviatedOid": "6ed3157"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-15T00:05:09Z",
          "updatedAt": "2025-10-15T00:05:09Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "'Labels' hm? Yes we want to un-collide labels but are we secretly registering concrete hybrid KEM constructions with this?",
              "createdAt": "2025-10-15T00:05:09Z",
              "updatedAt": "2025-10-15T00:05:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7G9M0o",
          "commit": {
            "abbreviatedOid": "6ed3157"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-15T00:06:32Z",
          "updatedAt": "2025-10-15T00:53:29Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "non-blocking but see comment on IANA registry for 'Labels'\n\nhttps://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/85/files#r2430788084",
              "createdAt": "2025-10-15T00:06:32Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 112,
              "body": "```suggestion\nThe four hybrid KEM frameworks share a substantial amount of structure, which we\n```",
              "createdAt": "2025-10-15T00:07:29Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 1,
              "body": "```suggestion\nThis document defines generic constructions for hybrid key encapsulation\nmechanisms (KEMs) based on combining a post-quantum (PQ) KEM with a traditional\n```",
              "createdAt": "2025-10-15T00:10:02Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 1,
              "body": "```suggestion\ncomputer. KEMs, are a standardized class of\n```",
              "createdAt": "2025-10-15T00:10:34Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 119,
              "body": "```suggestion\nHybrid KEM frameworks that use a KEM for the traditional component invoke the\n`DeriveKeyPair`, `Encaps`, and `Decaps` functions of PQ KEMs, alongside analogous\n```",
              "createdAt": "2025-10-15T00:11:13Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 136,
              "body": "```suggestion\ndef prepareEncapsG(ek_PQ, ek_T):\n```",
              "createdAt": "2025-10-15T00:11:23Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 143,
              "body": "```suggestion\ndef prepareDecapsG(ct_PQ, ct_T, dk_PQ, dk_T):\n```",
              "createdAt": "2025-10-15T00:11:30Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 137,
              "body": "```suggestion\n    (ss_PQ, ct_PQ) = KEM_PQ.Encaps(ek_PQ)\n```",
              "createdAt": "2025-10-15T00:11:35Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 174,
              "body": "```suggestion\ndef prepareEncapsK(ek_PQ, ek_T):\n```",
              "createdAt": "2025-10-15T00:11:53Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 186,
              "body": "```suggestion\ndef prepareDecapsK(ct_PQ, ct_T, dk_PQ, dk_T):\n```",
              "createdAt": "2025-10-15T00:12:00Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 341,
              "body": "```suggestion\n    (ss_PQ, ss_T, ct_PQ, ct_T) = prepareEncapsG(ek_PQ, ek_T)\n```",
              "createdAt": "2025-10-15T00:12:37Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 348,
              "body": "```suggestion\n    (ss_PQ, ss_T) = prepareDecapsG(ct_PQ, ct_T, dk_PQ, dk_T)\n```",
              "createdAt": "2025-10-15T00:12:47Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 367,
              "body": "```suggestion\n    (ss_PQ, ss_T, ct_PQ, ct_T) = prepareEncapsK(ek_PQ, ek_T)\n```",
              "createdAt": "2025-10-15T00:13:01Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 378,
              "body": "```suggestion\n    (ss_PQ, ss_T) = prepareDecapsK(ct_PQ, ct_T, dk_PQ, dk_T)\n```",
              "createdAt": "2025-10-15T00:13:10Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 398,
              "body": "```suggestion\n    (ss_PQ, ss_T, ct_PQ, ct_T) = prepareEncapsG(ek_PQ, ek_T)\n```",
              "createdAt": "2025-10-15T00:13:20Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 406,
              "body": "```suggestion\n    (ss_PQ, ss_T) = prepareDecapsG(ct_PQ, ct_T, dk_PQ, dk_T)\n```",
              "createdAt": "2025-10-15T00:13:31Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 429,
              "body": "```suggestion\n    (ss_PQ, ss_T, ct_PQ, ct_T) = prepareEncapsK(ek_PQ, ek_T)\n```",
              "createdAt": "2025-10-15T00:13:40Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 436,
              "body": "```suggestion\n    (ss_PQ, ss_T) = prepareDecapsK(ct_PQ, ct_T, dk_PQ, dk_T)\n```",
              "createdAt": "2025-10-15T00:13:49Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 121,
              "body": "```suggestion\npublic key group element; the \"ciphertext\" is an ephemeral group element; and\n```",
              "createdAt": "2025-10-15T00:20:12Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 157,
              "body": "We might be risky here, `DecapsKeyK` smells more like `K` the shared secret than `K = KEM`\n",
              "createdAt": "2025-10-15T00:26:42Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 153,
              "body": "```suggestion\n`DeriveKeyPair`, `Encaps`, and `Decaps` functions of the traditional and PQ KEMs in\n```",
              "createdAt": "2025-10-15T00:27:58Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 195,
              "body": "```suggestion\nsecrets output by the constituent component algorithms with contextual information.  This operation is\n```",
              "createdAt": "2025-10-15T00:30:50Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 197,
              "body": "```suggestion\nsecrets output by the component algorithms with metadata.\n```",
              "createdAt": "2025-10-15T00:31:10Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 204,
              "body": "I would rename this as 'universal' scans as the one for all frameworks, not just not-C2PRI ones\n\nWhat about B for Basic:\n\n```suggestion\ndef BasicCombiner(ss_PQ, ss_T, ct_PQ, ct_T, ek_PQ, ek_T, label):\n```\n\nI won't update the other places yet",
              "createdAt": "2025-10-15T00:35:04Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 143,
              "body": "Not sure about 'prepare', this is doing a lot of the work of `Encaps`/`Decaps`, maybe 'process'?",
              "createdAt": "2025-10-15T00:36:31Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 219,
              "body": "```suggestion\nin the hybrid KEM framework are not necessarily the output of a secure KEM. In\nparticular, when the framework is instantiated with a nominal group, the\n\"ciphertext\" component is an ephemeral group element, and the \"encapsulation\nkey\" is the group element that functions as the recipient's public key.\n```",
              "createdAt": "2025-10-15T00:37:05Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 232,
              "body": "```suggestion\nThe choice of combiner brings with it certain assumptions\nunder which the resulting hybrid KEM is secure.\n```",
              "createdAt": "2025-10-15T00:38:13Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 239,
              "body": "```suggestion\nThe `UniversalCombiner` combiner explicitly computes over shared secrets, ciphertexts, and\nencapsulation keys from both components.  This allows the resulting hybrid KEM\nto be secure as long as either component is secure, with no further assumptions on the components.\n```",
              "createdAt": "2025-10-15T00:39:21Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 246,
              "body": "This is incorrect.\n\n```suggestion\nThe `C2PRICombiner` combiner does not compute over the ciphertext or\nencapsulation key from the PQ component. The resulting hybrid KEM will\nbe secure if the PQ component is IND-CCA secure, or, the traditional\ncomponent is secure and the PQ component also satisfies the C2PRI property.\n```",
              "createdAt": "2025-10-15T00:43:41Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 72,
              "body": "```suggestion\n  constituent components being used, as well as which framework is being instantiated.\n```",
              "createdAt": "2025-10-15T00:44:44Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 268,
              "body": "```suggestion\nSome implementations of component schemes do not support the `DeriveKeyPair`\n```",
              "createdAt": "2025-10-15T00:46:06Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 269,
              "body": "```suggestion\nfunction, only `GenerateKeyPair`. Likewise in the nominal group case, a (scalar,\n```",
              "createdAt": "2025-10-15T00:46:13Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 279,
              "body": "```suggestion\n* `DeriveKeyPair` is not implemented.\n* The decapsulation key returned by `GenerateKeyPair` and consumed by `Decaps` is a\n  tuple (dk_PQ, dk_T) of per-constituent decapsulation keys (or pointers/handles\n  to keys).\n```",
              "createdAt": "2025-10-15T00:46:33Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 342,
              "body": "The invocation of `*Combiner` seems to be doing less than the 'prepare*'/'process' functions, I wonder if we can just inline them (as one line each)",
              "createdAt": "2025-10-15T00:48:32Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 353,
              "body": "Repeating 'meh'-ness with 'Universal'",
              "createdAt": "2025-10-15T00:49:30Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 363,
              "body": "Other places have the secret key first, left to right",
              "createdAt": "2025-10-15T00:50:36Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            },
            {
              "originalPosition": 369,
              "body": "We do `concat()` on their own lines in some places but not others, should we try to be consistent?\n",
              "createdAt": "2025-10-15T00:51:29Z",
              "updatedAt": "2025-10-15T00:53:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7HfVfx",
          "commit": {
            "abbreviatedOid": "6ed3157"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-16T20:23:31Z",
          "updatedAt": "2025-10-16T20:23:31Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I would prefer just to go back to Frameworks like we had before.  \r\n\r\n  ",
              "createdAt": "2025-10-16T20:23:31Z",
              "updatedAt": "2025-10-16T20:23:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7HfVt9",
          "commit": {
            "abbreviatedOid": "6ed3157"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-16T20:23:51Z",
          "updatedAt": "2025-10-16T20:23:52Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n# Hybrid KEM Frameworks {#frameworks}\r\n```",
              "createdAt": "2025-10-16T20:23:52Z",
              "updatedAt": "2025-10-16T20:23:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7HfWSo",
          "commit": {
            "abbreviatedOid": "6ed3157"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-16T20:24:34Z",
          "updatedAt": "2025-10-16T20:24:35Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "```suggestion\r\nInstantiating one of these frameworks creates a hybrid KEM `KEM_H` based on the following constituent\r\n```",
              "createdAt": "2025-10-16T20:24:35Z",
              "updatedAt": "2025-10-16T20:24:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7HfYEK",
          "commit": {
            "abbreviatedOid": "6ed3157"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-16T20:27:09Z",
          "updatedAt": "2025-10-16T20:27:09Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "```suggestion\r\nHybrid KEM frameworks that use a nominal group for the traditional component invoke the\r\n```",
              "createdAt": "2025-10-16T20:27:09Z",
              "updatedAt": "2025-10-16T20:27:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7HfYSB",
          "commit": {
            "abbreviatedOid": "6ed3157"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-16T20:27:30Z",
          "updatedAt": "2025-10-16T20:27:30Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "Should be \"that use a nominal group\".  Copy/paste error.",
              "createdAt": "2025-10-16T20:27:30Z",
              "updatedAt": "2025-10-16T20:27:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7HfaX9",
          "commit": {
            "abbreviatedOid": "6ed3157"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-16T20:30:02Z",
          "updatedAt": "2025-10-16T20:30:02Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "\"Prepare\" in the sense of \"preparing the inputs to the KDF\"",
              "createdAt": "2025-10-16T20:30:02Z",
              "updatedAt": "2025-10-16T20:30:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7Hfc0P",
          "commit": {
            "abbreviatedOid": "6ed3157"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-16T20:33:32Z",
          "updatedAt": "2025-10-16T20:33:32Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "My general policy is to reserve backticks for words that start lower-case (so `derive_key_pair` but not DeriveKeyPair), since there's more risk of ambiguity there.  But we should be consistent across the document.  It looks like the current document is mixed (`Encaps()`, but not `DeriveKeyPair`), so let's do a consistency pass in a follow-on PR.  (This could even get fixed in AUTH48.)",
              "createdAt": "2025-10-16T20:33:32Z",
              "updatedAt": "2025-10-16T20:33:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7HfeqE",
          "commit": {
            "abbreviatedOid": "6ed3157"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-16T20:35:52Z",
          "updatedAt": "2025-10-16T20:35:52Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/86",
              "createdAt": "2025-10-16T20:35:52Z",
              "updatedAt": "2025-10-16T20:35:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7HfkgN",
          "commit": {
            "abbreviatedOid": "6ed3157"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-16T20:42:19Z",
          "updatedAt": "2025-10-16T20:42:19Z",
          "comments": [
            {
              "originalPosition": 204,
              "body": "\"Universal\" in the sense that it is secure for any KEM, not just a C2PRI KEM.  Maybe that's the way to phrase it: \"any KEM\" vs. \"only C2PRI\".  I will probably merge this PR to get the structure in, and then we can iterate on the naming.\r\n\r\nhttps://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/87",
              "createdAt": "2025-10-16T20:42:19Z",
              "updatedAt": "2025-10-16T20:42:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7Hfncc",
          "commit": {
            "abbreviatedOid": "6ed3157"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-16T20:46:24Z",
          "updatedAt": "2025-10-16T20:46:24Z",
          "comments": [
            {
              "originalPosition": 342,
              "body": "I don't feel strongly, but I kind of like having the indirection because (a) it highlights the commonality and (b) having a name for it highlights the security assumptions.",
              "createdAt": "2025-10-16T20:46:24Z",
              "updatedAt": "2025-10-16T20:46:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7HfpEV",
          "commit": {
            "abbreviatedOid": "6ed3157"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-16T20:48:57Z",
          "updatedAt": "2025-10-16T20:48:57Z",
          "comments": [
            {
              "originalPosition": 363,
              "body": "It looks like DeriveKeyPair is consistent here, so I'm going to leave it for this PR, but filed https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/88.",
              "createdAt": "2025-10-16T20:48:57Z",
              "updatedAt": "2025-10-16T20:48:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7Hfq3b",
          "commit": {
            "abbreviatedOid": "6ed3157"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-16T20:51:27Z",
          "updatedAt": "2025-10-16T20:51:27Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "```suggestion\r\n  components being used, as well as which framework is being instantiated.\r\n```",
              "createdAt": "2025-10-16T20:51:27Z",
              "updatedAt": "2025-10-16T20:51:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7Hfvyv",
          "commit": {
            "abbreviatedOid": "54f3665"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-16T20:59:28Z",
          "updatedAt": "2025-10-16T20:59:28Z",
          "comments": [
            {
              "originalPosition": 194,
              "body": "```suggestion\r\nsecrets output by the component algorithms with contextual information.\r\n```",
              "createdAt": "2025-10-16T20:59:28Z",
              "updatedAt": "2025-10-16T20:59:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7Hfw8L",
          "commit": {
            "abbreviatedOid": "0488544"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-16T21:01:21Z",
          "updatedAt": "2025-10-16T21:01:22Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "```suggestion\r\n  {{iana-considerations}}).\r\n```",
              "createdAt": "2025-10-16T21:01:22Z",
              "updatedAt": "2025-10-16T21:01:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7Hfz_1",
          "commit": {
            "abbreviatedOid": "470874d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-16T21:06:08Z",
          "updatedAt": "2025-10-16T21:06:09Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "GitHub seems to have broken the link, but I'm assuming it's the comment about \"secretly registering concrete hybrid KEM constructions\"?  Not sure what the concern is there.  The registry is First Come First Served, so (a) it's non-rivalrous, and (b) it's not hard to register something (just email IANA).  The only way to get around this would be to remove the information from the IANA registry about what the label indicates, which seems like it removes most of the utility from the registry.  In any case, this issue seems separate from this PR.",
              "createdAt": "2025-10-16T21:06:08Z",
              "updatedAt": "2025-10-16T21:06:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 89,
      "id": "PR_kwDOMmhxws6uYnxl",
      "title": "Clean up some unnecessary mentions of GHP and QSF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/89",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-10-17T20:53:28Z",
      "updatedAt": "2025-10-17T20:54:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "35b8534bf6f25878f1ade8f7d7da29530b2a5a74",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "cleanup-ghp-qsf",
      "headRefOid": "7dbb973416f61967048c758d3c5ceb2da97abbd0",
      "closedAt": "2025-10-17T20:54:02Z",
      "mergedAt": "2025-10-17T20:54:02Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0c1650a401ecd026e33ce363f38746a8c8570cc7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 90,
      "id": "PR_kwDOMmhxws6uYus0",
      "title": "Update key generation requirements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/90",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR updates the key generation text to loosen the current prohibition on moving keys around in non-seed form.  In exchange, it adds more caveats about the risks that you have to account for in such situations. ",
      "createdAt": "2025-10-17T21:05:03Z",
      "updatedAt": "2025-10-17T22:54:41Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "0c1650a401ecd026e33ce363f38746a8c8570cc7",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "looser-keygen",
      "headRefOid": "4f163f3799085a5e7fb4427b146fa44a9ec8bd7e",
      "closedAt": "2025-10-17T22:54:40Z",
      "mergedAt": "2025-10-17T22:54:40Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2a4fa5eb1d3840d2b1b7fa1ed0b272ab78be9061"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @ounsworth\r\n",
          "createdAt": "2025-10-17T21:05:14Z",
          "updatedAt": "2025-10-17T21:05:14Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "NONE",
          "body": "I have formed my opinion on this, and that is that ECDH.keygen_from_seed() is novel cryptography. I checked SEC1 and SP 800-56A, and they do not specify a keygen function that accepts the randomness from outside the crypto module. I was not able to implement this draft and use your test vectors on top of the standard python cryptography library, and to me, that indicates a major design problem. Python Cryptography does have this:\r\n\r\n```\r\nec.derive_private_key(int.from_bytes(TSeed, \"little\"), ec.SECP256R1())\r\n```\r\nbut it did not give me the same private key -- perhaps we should debug this more?\r\nBut even if we can make this work with python cryptography, it's clear that this function is not FIPS-allowed, so there will many crypto libraries that don't implement it, and many production environments where, even if the software supports it, it is not allowed to be used due to US Gov regulations around FIPS compliance.\r\n\r\nSo, if you're going to extol the dangers of not using seeds for ECDH, then I think you equally need to extol the dangers of requiring readers of this document to implement their own EC point multiplication on private key data. I think that the security gained by the seeds binding thing will be undone multiple times over when people write bad ECC code.\r\n\r\nI feel quite strongly that the RECOMMENDED implementation here should be \"Go find a hardened ML-KEM module, and go find a harnened ECDH module, and then use them unmodified\", and unfortunately, that is going to mean no seed-based EC keygen, at least not in the RECOMMENDED implementation.\r\n\r\nI understand that HPKE needs deterministic keygen, so I would have no problem with an appendix or something that specifies it as an alternate implementation, but I think it needs the appropriate HERE BE DRAGONS text:\r\n\r\n> Note that a seed-based keygen for elliptic curve, while similar to the keygen routines specified in [SEC1] and [SP800-56A], is not actually standardized and allowed by those specifications. This has a couple of implications. First, an implementation of this specification cannot be done in a FIPS-compliant way. Second, although ML-KEM and ECDH are standardized components, this specification cannot be implemented on top of most existing cryptographic libraries and cryptographic hardware. Implementing the seed-based elliptic curve keygen requires implementing EC point multiplication handling private key data, and SHOULD NOT be done except by expert cryptographers who are aware of the side-channel requirements of their implementation and who are qualified to write such hardened code.\r\n\r\nNote that none of this applies to the X25519 variant because there the private key is already a seed in all the standardized implementations, and that's why we were able to trivially do interop-testing between this draft and the LAMPS draft.",
          "createdAt": "2025-10-17T21:36:35Z",
          "updatedAt": "2025-10-17T21:36:35Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It's a little strong to call deterministic EC key generation \"novel cryptography\".  It is, for example, essential to MLS (via HPKE), which is used in production millions of times per day across multiple products.\r\n\r\nI agree that there are not great standards for it, which is why HPKE had to [define its own rejection sampling loop](https://rfcs.online/rfcs/rfc9180.html#section-7.1.3) and we're having to do the same thing [in the concrete doc](https://github.com/cfrg/draft-irtf-cfrg-concrete-hybrid-kems/pull/30).  But given that there are a bunch of HPKE implementations out there, using several different cryptographic libraries, I don't think library support is really a blocker here.\r\n\r\nIt seems like we're down to a question of emphasis here, since the current text allows both, just with a bias toward shared-seed.  I'm going to go with this text as a compromise for now, and we can solicit more feedback from the rest of CFRG.",
          "createdAt": "2025-10-17T21:46:50Z",
          "updatedAt": "2025-10-17T21:46:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws7HzM1W",
          "commit": {
            "abbreviatedOid": "3c55c2f"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-17T21:06:14Z",
          "updatedAt": "2025-10-17T21:06:14Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\nSeparate key generation / handling also reduces binding properties from\n```",
              "createdAt": "2025-10-17T21:06:14Z",
              "updatedAt": "2025-10-17T21:06:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7HzR9w",
          "commit": {
            "abbreviatedOid": "4f163f3"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I like this",
          "createdAt": "2025-10-17T21:12:39Z",
          "updatedAt": "2025-10-17T21:12:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 91,
      "id": "PR_kwDOMmhxws6uiErp",
      "title": "Use PRGs instead of seeds",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/91",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR replaces seeds with PRGs as inputs to randomized algorithms.  For the most part, this is just saying the same thing: Either you pass a seed full of bytes you just drew from a PRG or you hand the PRG and let the seed reading be done interior to the function.\r\n\r\nThe PRG approach has the advantage that if the entropy demands of the function are not known up front, then the function can read a variable amount from the PRG.  The case in point for this is [rejection sampling for NIST curve keygen](https://github.com/cfrg/draft-irtf-cfrg-concrete-hybrid-kems/pull/30#pullrequestreview-3353961597).  This approach thus solves some issues at the [concrete hybrid KEM](https://github.com/hpkewg/hpke-pq/issues/30) and [HPKE](https://github.com/cfrg/draft-irtf-cfrg-concrete-hybrid-kems/issues/22) levels.\r\n\r\nThe PRG also makes it easier to discuss derandomized versions of key generation and encapsulation.  You just define a trivial PRG that reads an existing string of random bytes.  This is the mirror image of what FIPS 203 does with KeyGen/Encaps vs. KeyGen_Internal/Encaps_Internal, choosing the PRG as the primary interface because some things need variable randomness.",
      "createdAt": "2025-10-19T23:19:12Z",
      "updatedAt": "2025-10-27T20:11:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "2a4fa5eb1d3840d2b1b7fa1ed0b272ab78be9061",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "generate-prg",
      "headRefOid": "9e0763608e9fa9d6fd411358965dde69fbc7f4d3",
      "closedAt": "2025-10-27T20:11:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@dconnolly Thanks for the feedback.  Do you have a preferred alternative approach in mind for solving for the \"NIST curves need variable amounts of entropy\" problem?  The alternatives that came to mind seemed worse to me, namely (a) making seeds larger by an integer factor, or (b) having a PRG internal to the curve implementation.",
          "createdAt": "2025-10-20T18:11:02Z",
          "updatedAt": "2025-10-20T18:11:02Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@dconnolly and I talked some offline.  There was some concern that this proposal would upset the proofs by changing the nature of the PRG thing we rely on, and I made the claim that this change is just changing the API to the PRG, not the claims we rely on about the statistics of the PRG.  To try to make this clearer, I this up in a series of smaller steps:\r\n\r\nhttps://gist.github.com/bifurcation/0386e43c846bbdff42fa544266dc1ffc\r\n\r\nWhat I'm trying to illustrate here is that at each of these stages, the pseudo-random data are generated in exactly the same way, and the subroutines get access to exactly the same data.  The only thing that changes is how the data is managed, and the fact that the `expandDecapsKey` ends up not knowing exactly how much data it needs to generate up front.\r\n\r\nIf folks are still concerned that this cause some impact to the proofs, I would be curious at which stage I lose you, i.e., which of these smaller changes is the one that puts us over the line between OK and not OK.",
          "createdAt": "2025-10-21T04:48:37Z",
          "updatedAt": "2025-10-21T04:48:37Z"
        },
        {
          "author": "ThadThompson",
          "authorAssociation": "NONE",
          "body": "I'm a fan of the direction. \r\n\r\nHaving two key generation functions in HPKE felt awkward, especially when the pseudocode for Encap didn't also provide a way to inject a seed for the ephemeral keys. Having it in the appendix now helps, but it seems cleaner to have a single function and pass in the randomness function.\r\n\r\nIs there a reason it's named specifically as a 'PRG' and not just an opaque 'random' function, good for at least N bytes of entropy? Surely a working implementation would want to pass in the system rand function without worrying about the specific source under the hood.\r\n\r\nThen outside the main flow of the framework you could say \"for deterministic keys, proofs or testing you need a DRBG/PRG for the 'random' function and you're going to use SHAKE-256\".",
          "createdAt": "2025-10-21T05:28:09Z",
          "updatedAt": "2025-10-21T05:28:09Z"
        },
        {
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "body": "I suggested the switch from wide reduction to rejection sampling for P-256 because HPKE already has P-256 rejection sampling, and having both is two set of APIs to carry and test on the elliptic curve layer.\r\n\r\nI think using the PRG we already have makes a lot more sense than unnecessarily calling SHAKE twice in a row.\r\n\r\nThis might be easier and more reassuring to see with abstractions and document splits peeled off. Note that the RandomScalar \"API\" is only an API between the two documents (a split which I am finding very painful for both analysis and implementation), not an API that's exposed to anyone.\r\n\r\nThe P-256 hybrid keygen as of a few days ago was\r\n\r\n```\r\ns = SHAKE-256(seed)\r\npq = ML-KEM-Keygen(read(s, 64))\r\nt = read(r, 48) % N\r\n```\r\n\r\nThe P-256 hybrid keygen in the current draft is\r\n\r\n```\r\ns = SHAKE-256(seed)\r\npq = ML-KEM-Keygen(read(s, 64))\r\nss = SHAKE-256(read(s, 32))\r\nt = read(ss, 32)\r\nwhile t >= N: t = read(ss, 32)\r\n```\r\n\r\nThe P-256 hybrid keygen I _think_ is being proposed (although tbh it's not clear to me, again because we are looking at a PR for half the algorithm) is\r\n\r\n```\r\ns = SHAKE-256(seed)\r\npq = ML-KEM-Keygen(read(s, 64))\r\nt = read(s, 32)\r\nwhile t >= N: t = read(s, 32)\r\n```\r\n\r\nI can't imagine the third scheme being less secure or harder to prove than the first, and it avoids a whole SHAKE-256 on keygen, which is not insignificant. The story for Encaps is similar.\r\n\r\nIf you have a single-shot SHAKE API (which is kinda weird), we can help you by mentioning in the document that P-256 will never need more than four samples, so you never read more than 192 bytes from SHAKE-256, and that P-384 will never need more than one, so you never read more than 112 bytes from SHAKE-256.",
          "createdAt": "2025-10-21T07:37:27Z",
          "updatedAt": "2025-10-21T07:55:38Z"
        },
        {
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "body": "Here's an alternative wording for the same design, if folks don't like passing a PRG state between documents. we make no changes to draft-irtf-cfrg-hybrid-kems, and instead make the following changes to draft-irtf-cfrg-concrete-hybrid-kems:\r\n\r\n1. Change Nseed for P-256 to 128 (and keep Nseed for P-384 at 48)\r\n2. Define max_rejects as 3 for P-256, and 0 for P-384\r\n    * Each rejection has [< 2\u207b\u00b3\u00b2](https://www.wolframalpha.com/input?i=log2%281+-+115792089210356248762697446949407573529996955224135760342422259061068512044369+%2F+2%5E256%29) probability for P-256, and [< 2\u207b\u00b9\u2079\u2074](https://www.wolframalpha.com/input?i=log2%281+-+39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643+%2F+2%5E384%29) for P-384, so this puts the chance of failure to \"never\" and \"above the security level\" (for people who believe in that)\r\n4. Update RandomScalar to\r\n\r\n```\r\ndef RandomScalar(seed):\r\n  rejects = 0\r\n  sk = seed[:Nscalar]\r\n  while sk == 0 || sk >= order:\r\n    rejects += 1\r\n    if rejects > max_rejects: fail\r\n    sk = seed[Nscalar * rejects : Nscalar * rejects + Nscalar]\r\n  return (sk, pk(sk))\r\n```\r\n\r\nIf you squint, you will notice this is the same on the wire as the third option above, and can be implemented the same way, but avoids any PRG passing, and has built-in guidance for one-shot SHAKE APIs.",
          "createdAt": "2025-10-21T13:33:07Z",
          "updatedAt": "2025-10-21T13:33:07Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> Here's an alternative wording for the same design, if folks don't like passing a PRG state between documents. we make no changes to draft-irtf-cfrg-hybrid-kems, and instead make the following changes to draft-irtf-cfrg-concrete-hybrid-kems:\n> \n> 1. Change Nseed for P-256 to 128 (and keep Nseed for P-384 at 48)\n> 2. Define max_rejects as 3 for P-256, and 0 for P-384\n>     * Each rejection has [< 2\u207b\u00b3\u00b2](https://www.wolframalpha.com/input?i=log2%281+-+115792089210356248762697446949407573529996955224135760342422259061068512044369+%2F+2%5E256%29) probability for P-256, and [< 2\u207b\u00b9\u2079\u2074](https://www.wolframalpha.com/input?i=log2%281+-+39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643+%2F+2%5E384%29) for P-384, so this puts the chance of failure to \"never\" and \"above the security level\" (for people who believe in that)\n> 4. Update RandomScalar to\n> \n> ```\n> def RandomScalar(seed):\n>   rejects = 0\n>   sk = seed[:Nscalar]\n>   while sk == 0 || sk >= order:\n>     rejects += 1\n>     if rejects > max_rejects: fail\n>     sk = seed[Nscalar * rejects : Nscalar * rejects + Nscalar]\n>   return (sk, pk(sk))\n> ```\n> \n> If you squint, you will notice this is the same on the wire as the third option above, and can be implemented the same way, but avoids any PRG passing, and has built-in guidance for one-shot SHAKE APIs.\n\nI support this, cheers",
          "createdAt": "2025-10-21T13:39:19Z",
          "updatedAt": "2025-10-21T13:39:19Z"
        },
        {
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "body": "Sent it as a PR at https://github.com/cfrg/draft-irtf-cfrg-concrete-hybrid-kems/pull/33.",
          "createdAt": "2025-10-21T14:51:38Z",
          "updatedAt": "2025-10-21T14:51:38Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds like there is more energy for the \"long seeds\" approach (https://github.com/cfrg/draft-irtf-cfrg-concrete-hybrid-kems/pull/33/files) than this one.",
          "createdAt": "2025-10-27T20:11:12Z",
          "updatedAt": "2025-10-27T20:11:12Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws7H-qNj",
          "commit": {
            "abbreviatedOid": "9e07636"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-20T05:54:42Z",
          "updatedAt": "2025-10-20T05:54:42Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "There's a small inconsistency here between `state` (used here) and `prg` (used elsewhere).  Would it make sense to `s/state/prg` here?",
              "createdAt": "2025-10-20T05:54:42Z",
              "updatedAt": "2025-10-20T05:54:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7H-snV",
          "commit": {
            "abbreviatedOid": "9e07636"
          },
          "author": "rohanmahy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-20T06:02:08Z",
          "updatedAt": "2025-10-20T06:02:09Z",
          "comments": [
            {
              "originalPosition": 214,
              "body": "```suggestion\r\nThe GenerateKeyPair methods in the frameworks below describe \"shared seed\" key\r\n```",
              "createdAt": "2025-10-20T06:02:09Z",
              "updatedAt": "2025-10-20T06:02:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7H-tFv",
          "commit": {
            "abbreviatedOid": "9e07636"
          },
          "author": "rohanmahy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-20T06:03:34Z",
          "updatedAt": "2025-10-20T06:03:35Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "This sentence is a mouthful. I attempted to rework it.\r\n```suggestion\r\nPRGs used with the frameworks in this document MUST provide sufficient bit-security to provide input randomness for both PQ/T components from a seed that is\r\nexpanded to the target output length. A subset of the output length is passed to each of the component key\r\ngeneration algorithms.\r\n```",
              "createdAt": "2025-10-20T06:03:35Z",
              "updatedAt": "2025-10-20T06:03:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7H_Oyj",
          "commit": {
            "abbreviatedOid": "9e07636"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-20T07:09:28Z",
          "updatedAt": "2025-10-20T07:09:29Z",
          "comments": [
            {
              "originalPosition": 246,
              "body": "```suggestion\r\n    (ct_PQ, ct_T) = split(KEM_PQ.Nct, Group_T.Nct, ct)\r\n```",
              "createdAt": "2025-10-20T07:09:29Z",
              "updatedAt": "2025-10-20T07:09:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7H_O7n",
          "commit": {
            "abbreviatedOid": "9e07636"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-20T07:09:45Z",
          "updatedAt": "2025-10-20T07:09:46Z",
          "comments": [
            {
              "originalPosition": 272,
              "body": "```suggestion\r\n    (ct_PQ, ct_T) = split(KEM_PQ.Nct, Group_T.Nct, ct)\r\n```",
              "createdAt": "2025-10-20T07:09:45Z",
              "updatedAt": "2025-10-20T07:09:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7IHndN",
          "commit": {
            "abbreviatedOid": "9e07636"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-20T18:05:25Z",
          "updatedAt": "2025-10-20T18:05:26Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I'd be careful with new APIs introduced now, the PRGs used in our concrete instances don't use this API (SHAKE), they just have a one shot invocation; who needs a multi-step API? @bifurcation ",
              "createdAt": "2025-10-20T18:05:26Z",
              "updatedAt": "2025-10-20T18:05:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7IHoZt",
          "commit": {
            "abbreviatedOid": "9e07636"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-20T18:07:08Z",
          "updatedAt": "2025-10-20T18:07:08Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Don't love this, I would be very annoyed to wrap a SHAKE function in a stateful representation to match this spec ",
              "createdAt": "2025-10-20T18:07:08Z",
              "updatedAt": "2025-10-20T18:07:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7IHoxz",
          "commit": {
            "abbreviatedOid": "9e07636"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I don't think this API helps implementers (including the concrete instances we are doing in the other document)",
          "createdAt": "2025-10-20T18:07:50Z",
          "updatedAt": "2025-10-20T18:07:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws7ILNVo",
          "commit": {
            "abbreviatedOid": "9e07636"
          },
          "author": "sophieschmieg",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-21T00:19:44Z",
          "updatedAt": "2025-10-21T00:19:45Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "this is incorrect. A PRG does not necessarily produce more output than inputs.",
              "createdAt": "2025-10-21T00:19:44Z",
              "updatedAt": "2025-10-21T00:51:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7ILQcX",
          "commit": {
            "abbreviatedOid": "9e07636"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-21T00:30:34Z",
          "updatedAt": "2025-10-21T00:30:34Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "The citation in the doc is to https://eprint.iacr.org/2024/843.pdf, which basically says \"a function whose outputs are indistinguishable from uniform given a uniform input\".  I can't speak to how standard this is.",
              "createdAt": "2025-10-21T00:30:34Z",
              "updatedAt": "2025-10-21T00:30:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7ILRa_",
          "commit": {
            "abbreviatedOid": "9e07636"
          },
          "author": "sophieschmieg",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-21T00:34:14Z",
          "updatedAt": "2025-10-21T00:34:14Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "TrivialPRG is not defined, from what I can tell. I think it might be a projection to the first or second half of the seed, depending on the call, but I only get that assumption from reading the old version.",
              "createdAt": "2025-10-21T00:34:14Z",
              "updatedAt": "2025-10-21T00:34:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7IMj2T",
          "commit": {
            "abbreviatedOid": "9e07636"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-21T04:42:04Z",
          "updatedAt": "2025-10-21T04:42:04Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Implementations seem decidedly split on this.  For example, [Go](https://pkg.go.dev/golang.org/x/crypto/sha3#ShakeHash) and [Rust Crypto](https://docs.rs/sha3/latest/sha3/#examples) implement reader interfaces, [Python](https://docs.python.org/3/library/hashlib.html#hashlib.shake_256) and [OpenSSL](https://docs.openssl.org/3.5/man7/EVP_MD-SHAKE/) implement one-shot interfaces.  And of course, basically every DRBG in the universe (which also meets this definition of PRG) has a reader interface.\r\n\r\nClearly you can emulate one-shot with a reader.  You can emulate a reader with one-shot at the cost of storage and/or recomputation.\r\n\r\nDo we have an example of a non-SHAKE PRG that always uses a single-shot interface?",
              "createdAt": "2025-10-21T04:42:04Z",
              "updatedAt": "2025-10-21T04:43:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7IOc8W",
          "commit": {
            "abbreviatedOid": "9e07636"
          },
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-21T07:52:36Z",
          "updatedAt": "2025-10-21T07:52:36Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "I am not following how this is described. This PR is changing GenerateKeyPair to take a PRG, read from it a seed to pass to expandDecapsKeyG, which then goes back to a PRG somehow\r\n\r\n```\r\ndef GenerateKeyPair(prg):\r\n    seed = prg.read(Nseed)\r\n    (ek_PQ, ek_T, dk_PQ, dk_T) = expandDecapsKeyG(seed)\r\n    return (concat(ek_PQ, ek_T), seed)\r\n\r\ndef expandDecapsKeyG(seed):\r\n    prg = TrivialPRG.new(seed)\r\n\r\n    (ek_PQ, dk_PQ) = KEM_PQ.GenerateKeyPair(prg)\r\n    dk_T = Group_T.RandomScalar(prg)\r\n    ek_T = Group_T.Exp(Group_T.g, dk_T)\r\n\r\n    return (ek_PQ, ek_T, dk_PQ, dk_T)\r\n```\r\n\r\nwhile I expected we'd only be changing RandomScalar to take a PRG based on the discussion:\r\n\r\n```\r\ndef GenerateKeyPair():\r\n    seed = random(Nseed)\r\n    return DeriveKeyPair(seed)\r\n\r\ndef DeriveKeyPair(seed):\r\n    (ek_PQ, ek_T, dk_PQ, dk_T) = expandDecapsKeyG(seed)\r\n    return (concat(ek_PQ, ek_T), seed)\r\n\r\ndef expandDecapsKeyG(seed):\r\n    prg = PRG.New(seed)\r\n\r\n    (ek_PQ, dk_PQ) = KEM_PQ.GenerateKeyPair(prg.Read(KEM_PQ.Nseed))\r\n    dk_T = Group_T.RandomScalar(prg) # uses prg for rejection sampling for P-256, just a read for X25519\r\n    ek_T = Group_T.Exp(Group_T.g, dk_T)\r\n\r\n    return (ek_PQ, ek_T, dk_PQ, dk_T)\r\n```\r\n\r\nI think that would be a much smaller change in how the process is described, that still gets us to rejection sampling while avoiding the nested PRGs.",
              "createdAt": "2025-10-21T07:52:36Z",
              "updatedAt": "2025-10-21T07:55:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 92,
      "id": "PR_kwDOMmhxws6uqYHE",
      "title": "new security analysis subsection to reflect changes elsewhere",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/92",
      "state": "MERGED",
      "author": "pag-crypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "started sketching out changes to security analysis. added some todo notes for things we need to fill in. provided brief summary of ind-cca proofs for UG. Changed hybrid KEM names throughout doc to reflect new naming conventions.",
      "createdAt": "2025-10-20T15:59:40Z",
      "updatedAt": "2025-10-20T19:17:56Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "2a4fa5eb1d3840d2b1b7fa1ed0b272ab78be9061",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "ug-sec-analysis",
      "headRefOid": "0c5842ab8db66b57d0ae4cedc76063e9cb954456",
      "closedAt": "2025-10-20T19:17:55Z",
      "mergedAt": "2025-10-20T19:17:55Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "c5f30bb8416529a74d8a7083fb65043b9b396378"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws7IHrci",
          "commit": {
            "abbreviatedOid": "e32fe74"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-20T18:11:05Z",
          "updatedAt": "2025-10-20T18:11:05Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\n    (ek_PQ, ek_T, dk_PQ, dk_T) = expandDecapsKeyK(seed)\n```",
              "createdAt": "2025-10-20T18:11:05Z",
              "updatedAt": "2025-10-20T18:11:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7IHznZ",
          "commit": {
            "abbreviatedOid": "9d60ad3"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-20T18:25:47Z",
          "updatedAt": "2025-10-20T18:57:29Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\ngiven access to `g^x` and `g^y` and an oracle `DH(Y, Z)` that answers whether\n`Y^x = Z`. (This is the notion specified in {{XWING}}, not the notion of the same\nname used in the context of bilinear pairings {{Cheon06}}.)\n```",
              "createdAt": "2025-10-20T18:25:47Z",
              "updatedAt": "2025-10-20T18:57:29Z"
            },
            {
              "originalPosition": 39,
              "body": "```suggestion\nhybrid KEM constructions: most IND-CCA analyses for the four frameworks require\nonly that the KDF is some kind of pseudorandom function, but the SDH-based IND-CCA\n```",
              "createdAt": "2025-10-20T18:27:11Z",
              "updatedAt": "2025-10-20T18:57:29Z"
            },
            {
              "originalPosition": 45,
              "body": "```suggestion\nanalysis of CG in {{XWING}}, and the corresponding analysis for UG (forthcoming)\nrelies on the KDF being a RO. Proofs of our target binding properties for our\nhybrid KEMs require the KDF is a collision-resistant function.\n```",
              "createdAt": "2025-10-20T18:27:54Z",
              "updatedAt": "2025-10-20T18:57:29Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\nsecrets output by the constituent KEMs - to the other inputs. Thus, analyses\nwhich require the KDF to be a PRF, such as the one given in GHP {{GHP2018}}\nfor UK, or the standard-model analysis of CG in {{XWING}}, apply.\n```",
              "createdAt": "2025-10-20T18:28:19Z",
              "updatedAt": "2025-10-20T18:57:29Z"
            },
            {
              "originalPosition": 73,
              "body": "```suggestion\nSome IND-CCA analyses do not strictly require the KDF to be indifferentiable\nfrom a random oracle; they instead only require a kind of PRF assumption on\nthe KDF. For simplicity we ignore this here; the security analyses described\nbelow for our constructions will elaborate on this point when appropriate.\n```",
              "createdAt": "2025-10-20T18:29:11Z",
              "updatedAt": "2025-10-20T18:57:29Z"
            },
            {
              "originalPosition": 96,
              "body": "```suggestion\nThe UG construction has two complementary IND-CCA analyses: one for when the\nSDH problem holds but the PQ KEM is broken, and one for the reverse. Both are\ntechnically novel but are substantially similar to the existing peer-reviewed\nanalyses of the CG {{XWING}} and UK {{GHP18}} constructions. A forthcoming\ndocument by the editorial team will describe the analysis of UG in detail.\n```",
              "createdAt": "2025-10-20T18:31:02Z",
              "updatedAt": "2025-10-20T18:57:29Z"
            },
            {
              "originalPosition": 106,
              "body": "```suggestion\nThe first IND-CCA analysis, based on SDH, is very similar to the corresponding\nanalysis of CG given in {{XWING}}: it gives a straightforward reduction to the\nSDH hardness in the underlying group. Notably, since the PQ KEM key and ciphertext are\nhashed, the C2PRI security of the PQ KEM does not appear in the bound.\n```",
              "createdAt": "2025-10-20T18:33:59Z",
              "updatedAt": "2025-10-20T18:57:29Z"
            },
            {
              "originalPosition": 111,
              "body": "```suggestion\nThe second IND-CCA analysis is a straightforward reduction to the IND-CCA security\n```",
              "createdAt": "2025-10-20T18:34:09Z",
              "updatedAt": "2025-10-20T18:57:29Z"
            },
            {
              "originalPosition": 113,
              "body": "```suggestion\n<!-- TODO: where, if anywhere, does the split-key PRF requirement come up?-->\n\nThis was originally trying to just prove the PQ side from non-ROM assumptions and the GHP2018 paper used split-key PRF to do so; I think we're ignoring that now and just copying the X-Wing argument but with more KEM_1 data included in the preimage (ciphertext, public key)\n```",
              "createdAt": "2025-10-20T18:36:21Z",
              "updatedAt": "2025-10-20T18:57:29Z"
            },
            {
              "originalPosition": 113,
              "body": "```suggestion\n```",
              "createdAt": "2025-10-20T18:36:32Z",
              "updatedAt": "2025-10-20T18:57:29Z"
            },
            {
              "originalPosition": 121,
              "body": "```suggestion\nThis document's UK construction does not have an IND-CCA analysis; the\nGHP paper on which the construction is based gives a slightly different\nversion, namely they do not include the public encapsulation keys in\nthe KDF. However, we argue that the proof goes through with trivial\nmodifications if the public encapsulation keys are\n```",
              "createdAt": "2025-10-20T18:47:04Z",
              "updatedAt": "2025-10-20T18:57:29Z"
            },
            {
              "originalPosition": 135,
              "body": "```suggestion\nLike UG, the CG construction has two complementary IND-CCA analyses. Both were\ngiven in {{XWING}}. We summarize them but elide some details.\n\nOne analysis (Theorem 1) {{XWING}} shows that if the KDF is modelled as a RO,\nIND-CCA holds if the PQ KEM is broken, as long as the SDH problem holds in\nthe nominal group and the PQ KEM satisfies C2PRI. The other (Theorem 2)\n{{XWING}} shows that if the PQ-KEM is IND-CCA and the KDF is a PRF keyed on\nthe PQ-KEM's shared secret, IND-CCA holds.\n```",
              "createdAt": "2025-10-20T18:47:32Z",
              "updatedAt": "2025-10-20T18:57:29Z"
            },
            {
              "originalPosition": 142,
              "body": "```suggestion\nThe CK construction's IND-CCA analysis is based on forthcoming work by the editorial team.\n\nThe CK construction has two complementary IND-CCA analyses: one for when the IND-CCA\nsecurity of the traditional PKE-based KEM holds but the PQ KEM is broken, except for\nthe PQ KEM's C2PRI security, and one for where the IND-CCA security of the PQ KEM holds.\nBoth are technically novel but are substantially similar to the existing peer-reviewed\nanalyses of the CG {{XWING}} and UK {{GHP18}} constructions. A forthcoming document by\nthe editorial team will describe the analysis of CK in detail.\n```",
              "createdAt": "2025-10-20T18:55:33Z",
              "updatedAt": "2025-10-20T18:57:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws7IISsV",
          "commit": {
            "abbreviatedOid": "1360da8"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-20T19:13:07Z",
          "updatedAt": "2025-10-20T19:13:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 93,
      "id": "PR_kwDOMmhxws6utuX4",
      "title": "Fix copy/paste errors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/93",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-10-20T21:20:17Z",
      "updatedAt": "2025-10-20T21:21:04Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "c5f30bb8416529a74d8a7083fb65043b9b396378",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "copy-paste-errors",
      "headRefOid": "70bcae9fad9cef8acf6b33d7fd49d2a950bd10d8",
      "closedAt": "2025-10-20T21:21:02Z",
      "mergedAt": "2025-10-20T21:21:02Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3ab36d52a461511a363400a8cf4779bc1a264fbd"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 94,
      "id": "PR_kwDOMmhxws6ut3A0",
      "title": "Fill out the rest of the BIND proofs for CK and UG",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/94",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #51 ",
      "createdAt": "2025-10-20T21:35:59Z",
      "updatedAt": "2025-10-20T21:45:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "3ab36d52a461511a363400a8cf4779bc1a264fbd",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "proofs",
      "headRefOid": "8dca2c1c964e135da59d715784e44dd649486de0",
      "closedAt": "2025-10-20T21:45:10Z",
      "mergedAt": "2025-10-20T21:45:10Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "dbce8daf774565d2059f9e00a680843e81734791"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 95,
      "id": "PR_kwDOMmhxws6uuO6r",
      "title": "Todos",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/95",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/56",
      "createdAt": "2025-10-20T22:20:02Z",
      "updatedAt": "2025-10-20T22:20:50Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "dbce8daf774565d2059f9e00a680843e81734791",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "todos",
      "headRefOid": "b036962acbe1afe96d3eb8485babe6eaa4331ae3",
      "closedAt": "2025-10-20T22:20:48Z",
      "mergedAt": "2025-10-20T22:20:48Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "4a780d39cfb78e71e3e00c286e2cd1903de15cbe"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 96,
      "id": "PR_kwDOMmhxws6uuWJm",
      "title": "Backticks",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/96",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #86",
      "createdAt": "2025-10-20T22:36:10Z",
      "updatedAt": "2025-10-20T22:37:48Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "4a780d39cfb78e71e3e00c286e2cd1903de15cbe",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "backticks",
      "headRefOid": "05faa7dd78e8e8ae253d049fd853c1464aeb0299",
      "closedAt": "2025-10-20T22:37:47Z",
      "mergedAt": "2025-10-20T22:37:47Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "25bd5cb5c981f356c0ed3e9ee1e13ade2c4b9d45"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 97,
      "id": "PR_kwDOMmhxws6uubq8",
      "title": "Tildas not backticks",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/97",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-10-20T22:48:58Z",
      "updatedAt": "2025-10-20T22:49:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "25bd5cb5c981f356c0ed3e9ee1e13ade2c4b9d45",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "tildas-not-backticks",
      "headRefOid": "cdd6c3b61dad6a93862091009e130aa8ee83d0b3",
      "closedAt": "2025-10-20T22:49:41Z",
      "mergedAt": "2025-10-20T22:49:41Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "a4e98394e028e4051e4747c1b846353a9fc72053"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 98,
      "id": "PR_kwDOMmhxws6ztOPq",
      "title": "Clarify RandomScalar seed MUST be uniformly random",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/98",
      "state": "OPEN",
      "author": "FiloSottile",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-11-16T11:15:11Z",
      "updatedAt": "2025-11-17T04:44:32Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "a4e98394e028e4051e4747c1b846353a9fc72053",
      "headRepository": "FiloSottile/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "patch-1",
      "headRefOid": "644eac7ad699eaf69a340eedcfc35da89859c10b",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws7O1xgj",
          "commit": {
            "abbreviatedOid": "644eac7"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-11-16T13:45:34Z",
          "updatedAt": "2025-11-16T13:45:34Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws7O4sae",
          "commit": {
            "abbreviatedOid": "644eac7"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-11-17T04:44:32Z",
          "updatedAt": "2025-11-17T04:44:32Z",
          "comments": []
        }
      ]
    }
  ]
}