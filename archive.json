{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-06-01T01:23:34.105129+00:00",
  "repo": "cfrg/draft-irtf-cfrg-hybrid-kems",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "TODO",
      "description": "Known gap in the document",
      "color": "28F613"
    },
    {
      "name": "discuss",
      "description": "Needs discussion to identify the right outcome",
      "color": "C96DEA"
    }
  ],
  "issues": [
    {
      "number": 4,
      "id": "I_kwDOMmhxws6rCIMm",
      "title": "Should instance labels include the XOF that's used for key generation?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/4",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "For example, `QSF-SHA3-256-ML-KEM-768-P-256` doesn't say that it uses SHAKE256 for the XOF. Should we?",
      "createdAt": "2025-02-21T16:15:05Z",
      "updatedAt": "2025-02-25T17:22:50Z",
      "closedAt": "2025-02-25T17:22:50Z",
      "comments": []
    },
    {
      "number": 7,
      "id": "I_kwDOMmhxws6rz1bb",
      "title": "Consider renaming KitchenSink to TranscriptHash",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/7",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See [this post](https://mailarchive.ietf.org/arch/msg/cfrg/L7G1rXH9g_acH1uhs4G2IKRN7dU/).",
      "createdAt": "2025-02-26T18:39:03Z",
      "updatedAt": "2025-05-29T21:54:19Z",
      "closedAt": "2025-05-29T21:54:18Z",
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "NONE",
          "body": "I'm not sure that's right thought\n\n``` \nss = LabeledHKDF(pq_SS, trad_SS, pq_CT, pq_PK, trad_CT, trad_PK, label)\n```\n\nThere's no \"transcript\" in there, unless you jam it into the label, but that's not required by the text? And I think that TLS has a well-defined concept of a \"transcript\", but I think it's less clear what counts as \"transcript\" for example if you have a JWT payload on an HTTP POST -- does \"transcript\" mean that the entire payload of the JWT should be included in the label? Or does \"transcript\" mean the entire sequence of HTTP messages exchanged so far on this connection? Obviously that's not what's intended, but might be how a non-cryptographer interprets the word \"transcript\". I don't have a better suggestion than \"KitchenSink\", but I don't think that \"TranscriptHash\" is the right connotation for protocols that aren't TLS.",
          "createdAt": "2025-02-26T20:06:05Z",
          "updatedAt": "2025-02-26T20:24:15Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Dupe of #20 ",
          "createdAt": "2025-05-29T21:54:18Z",
          "updatedAt": "2025-05-29T21:54:18Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOMmhxws6sPD0w",
      "title": "IANA Register HPKE KDFs?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/8",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The IANA \"Hybrid Public Key Encryption (HPKE)\" page has registries for KEMs, KDFs, and AEADs. Currently, the only KDFs registered are HKDF-SHA256/384512.\n\nI believe that someone needs to register at least these two KDFs in the IANA registry before HPKE key derivation is truly supported:\n- KDF(SHA3-256) \u2014 referring to Section 6.1 of FIPS202\n- XOF(SHAKE256) \u2014 referring to Section 6.2 of FIPS202\n\nThis document seems a likely place for that registration. It may have the nice side effect that the names of the QSF-based KEMs can become shorter.\n",
      "createdAt": "2025-03-02T15:52:34Z",
      "updatedAt": "2025-03-07T20:34:52Z",
      "closedAt": "2025-03-07T20:34:52Z",
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.",
          "createdAt": "2025-03-02T19:48:41Z",
          "updatedAt": "2025-03-02T19:49:02Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.\n\nA separate document to register SHA3 as an HPKE KDF will probably be useful but that's apart from this one",
          "createdAt": "2025-03-02T19:54:50Z",
          "updatedAt": "2025-03-02T19:54:50Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.\n> \n> A separate document to register SHA3 as an HPKE KDF will probably be useful but that's apart from this one\n\nSimilarly, X-Wing is registered In IANA as an HPKE KEM. X-Wing uses SHA3 as its KDF and SHAKE256 as an XOF in its key generation/derivation. Those functions are separate from the HPKE KDFs, same with the KEMs defined and registered in this document and the functions they use internally.",
          "createdAt": "2025-03-02T20:00:26Z",
          "updatedAt": "2025-03-02T20:00:26Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "> > > Sorry no, the KDF and XOF's mentioned in this document are _entirely internal_ to the KEM schemes laid out here. These schemes are to be registered in HPKE KEM IANA, and any other HPKE KDF or AEAD usages are fully independent of the schemes laid out here.\n> > \n> > \n> > A separate document to register SHA3 as an HPKE KDF will probably be useful but that's apart from this one\n> \n> Similarly, X-Wing is registered In IANA as an HPKE KEM. X-Wing uses SHA3 as its KDF and SHAKE256 as an XOF in its key generation/derivation. Those functions are separate from the HPKE KDFs, same with the KEMs defined and registered in this document and the functions they use internally.\n\n@rohanmahy I've created this to register SHA-3 for HPKE KDFs: https://datatracker.ietf.org/doc/draft-connolly-cfrg-sha3-hpke/",
          "createdAt": "2025-03-04T00:03:04Z",
          "updatedAt": "2025-03-04T00:03:04Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "SHA-3 unfortunately doesn't match the Extract/Expand API expected by HPKE spec so it's not as easy but we can keep working on it",
          "createdAt": "2025-03-07T20:34:44Z",
          "updatedAt": "2025-03-07T20:34:44Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOMmhxws6tFcFU",
      "title": "Make concatenation of KDF inputs explicit in concrete pseudocode",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/10",
      "state": "CLOSED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We can clarify this concatenation to match the generic QSF construction more closely using the explicit concat() routine described earlier",
      "createdAt": "2025-03-07T20:35:32Z",
      "updatedAt": "2025-05-29T21:53:00Z",
      "closedAt": "2025-05-29T21:52:58Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in current `main`.",
          "createdAt": "2025-05-29T21:52:59Z",
          "updatedAt": "2025-05-29T21:52:59Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOMmhxws6tFlU6",
      "title": "Type inconsistency for `trad_PK`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/11",
      "state": "CLOSED",
      "author": "bluegate010",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "- In `expandDecapsulationKey` (and therefore in `KeyGen`, `DeriveKey`, and `Decaps`), `trad_PK` is a serialized byte array (`trad_PK = G.SerializeElement(NominalGroup.ScalarMultBase(trad_SK))`)\n- In `Encaps`, `trad_PK` is a deserialized element (`trad_PK = P-256.DeserializeElement(pk[1184:1217])`)\n- In `EncapsDerand` for QSF-P256, `trad_PK` is a deserialized element (`trad_PK = P-256.DeserializeElement(pk[1184:1217])`), but is later treated as a serialized byte array (`ss = SHA3-256(pq_SS, trad_SS, trad_CT, trad_PK, label)`)\n- In `EncapsDerand` for KS-X25519, `trad_PK` is a serialized byte array (`trad_PK = pk[1184:1216]`)\n- In `EncapsDerand` for QSF-P384, `trad_PK` is deserialized element (`trad_PK = P-384.DeserializeElement(pk[1568:1629])`)\n\nFor clarity, it seems reasonable for `trad_PK` to always be a serialized byte array.",
      "createdAt": "2025-03-07T20:55:14Z",
      "updatedAt": "2025-05-29T21:49:21Z",
      "closedAt": "2025-05-29T21:49:21Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This has been fixed in the latest `main`.  All the values the KEM interface deals with are fixed-length byte arrays.",
          "createdAt": "2025-05-29T21:49:21Z",
          "updatedAt": "2025-05-29T21:49:21Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOMmhxws6y1iX9",
      "title": "Flesh out the 'out of scope' details more",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/13",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dconnolly"
      ],
      "labels": [
        "TODO"
      ],
      "body": "",
      "createdAt": "2025-04-16T18:10:07Z",
      "updatedAt": "2025-05-29T21:56:34Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 14,
      "id": "I_kwDOMmhxws6y1lj0",
      "title": "Flesh out tradeoffs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/14",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "TODO"
      ],
      "body": "- [ ] include not looking at 'layered' style hybrids\n- [ ] include not looking at split/dualPRF style",
      "createdAt": "2025-04-16T18:15:46Z",
      "updatedAt": "2025-05-29T21:56:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate / subset of #13 ?",
          "createdAt": "2025-05-29T21:52:38Z",
          "updatedAt": "2025-05-29T21:52:38Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "I_kwDOMmhxws6016Gs",
      "title": "Rename to '-generic-hybrid-kems' to match '-concrete-hybrid-kems'",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/16",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "",
      "createdAt": "2025-05-01T14:50:46Z",
      "updatedAt": "2025-05-29T22:45:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems like more keystrokes for no real value.",
          "createdAt": "2025-05-29T21:57:18Z",
          "updatedAt": "2025-05-29T21:57:18Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOMmhxws63zN4v",
      "title": "Names for the schemes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/20",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "GHP? ",
      "createdAt": "2025-05-22T14:51:19Z",
      "updatedAt": "2025-05-29T21:55:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I presume you mean \"KitchenSink\" \ud83d\ude04  \n\nWhat does \"GHP\" mean?",
          "createdAt": "2025-05-27T21:32:25Z",
          "updatedAt": "2025-05-27T21:32:25Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "body": "I presume [Giacon, Heuer, Poettering](https://eprint.iacr.org/2018/024.pdf)\n",
          "createdAt": "2025-05-27T21:41:19Z",
          "updatedAt": "2025-05-27T21:41:19Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Renamed the issue to be a little more generic.  Current `main` renames things to try to be more neutral / descriptive: HashEverything / PreHashKeys / HashTraditionalOnly.  The original names (KitchenSink / Chempat / QSF) are a little catchier.  It would be nice if there were something catchy that was also more descriptive of what's going on.  Suggestions welcome.",
          "createdAt": "2025-05-29T21:51:45Z",
          "updatedAt": "2025-05-29T21:51:45Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOMmhxws6401jO",
      "title": "Instantiation of KitchenSink / HashEverything with a nominal group instead of a KEM",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/23",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "",
      "createdAt": "2025-05-29T16:31:47Z",
      "updatedAt": "2025-05-29T22:08:32Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It is technically possible to instantiate the KitchenSink / HashEverything scheme with a nominal group (e.g., ECDH) in place of the IND-CCA KEM called for in the current text.  You just define a pseudo-KEM where the CT is a group element and Encap/Decap are DH operations.\n\nOn the one hand, it seems like this should be secure.  In the case where the PQ KEM is broken, it is effecitively DH-KEM, which is IND-CCA.\n\nOn the other hand, it's not clear that this is a construction that has been analyzed in the literature.  The GHP paper that underlies KitchenSink / HashEverything requires that the inputs be IND-CCA KEMs.\n\nIf we are going to specify this, then we have two choices as to how to define it:\n\n1. Define the \"pseudo-KEM\" sketched above.  This option is notationally compact, but risks people implementing ECDH as a KEM even though it's not secure.\n2. Write out the full instantiation using the Group API.  This option is verbose, but doesn't define a KEM that is not IND-CCA.",
          "createdAt": "2025-05-29T22:08:26Z",
          "updatedAt": "2025-05-29T22:08:26Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOMmhxws641cOD",
      "title": "Refactor security properties subsection of Security Considerations section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/24",
      "state": "OPEN",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "TODO"
      ],
      "body": "We have some language on IND-CCA and C2PRI but need more on the rest:\n\n## Security Properties\n\n### INDistinguishability against Chosen-Ciphertext Attacks (IND-CCA)\n\n### Ciphertext Second Preimage Resistance (C2PR)\n\n### Binding Properties (X-BIND-P-Q)\n\n### Survival if One KEM Fails\n\n## Security of the Combiners\n\n### Everything {#everything-sec}\n\n### OnlyTraditional {#only-traditional-sec}\n\n### OnlySharedSecrets {#only-shared-secrets-sec}",
      "createdAt": "2025-05-29T17:36:01Z",
      "updatedAt": "2025-05-29T21:56:35Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 25,
      "id": "I_kwDOMmhxws643qD-",
      "title": "Specify the security requirements for constituent elements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/25",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "pag-crypto"
      ],
      "labels": [
        "discuss"
      ],
      "body": "We have three types of constituents that go into our hybrid schemes:\n\n1. KEMs\n2. Nominal groups\n3. Hash functions\n\nThe security requirements for the former two are pretty clear: A KEM needs to be IND-CCA, and if it is going to be used with QSF / HashTraditionalOnly, it needs to have some additional binding properties.  A nominal group needs to be secure in the sense of [ABH+20].\n\nFor the \"hash functions\", we should define a requirement that aligns well with the constructions in the literature, some combination of notions of XOF, KDF, and RO.",
      "createdAt": "2025-05-29T22:12:54Z",
      "updatedAt": "2025-05-29T22:16:54Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 26,
      "id": "I_kwDOMmhxws643qoZ",
      "title": "Define the desired security properties for the hybrid KEMs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/26",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "pag-crypto"
      ],
      "labels": [
        "TODO"
      ],
      "body": "Normal KEM security notions apply, particularly IND-CCA and X-BIND-P-Q.\n\nThe interesting thing will be how to discuss the \"hybrid\" security notion, i.e., the survival of at least IND-CCA when at least one KEM fails -- for some definition of \"fails\".",
      "createdAt": "2025-05-29T22:14:34Z",
      "updatedAt": "2025-05-29T22:45:38Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 27,
      "id": "I_kwDOMmhxws643rU2",
      "title": "Describe how the hybrid schemes meet the security goals",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/27",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "pag-crypto"
      ],
      "labels": [
        "TODO"
      ],
      "body": "We should provide citations to proofs in the literature that the schemes we describe are secure given our requirements on the inputs.\n\n* HashEverything should map to one of the schemes in GHP20\n* PreHashKeys - not clear what the right citation is here?\n* HashTraditionalOnly maps to the QSF construction in BCD+24",
      "createdAt": "2025-05-29T22:16:33Z",
      "updatedAt": "2025-05-29T22:16:55Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 28,
      "id": "I_kwDOMmhxws643s8r",
      "title": "Serialization of compound values",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/28",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "The values that a hybrid KEM deals with are compound:\n\n* `dk_H = (dk_T, dk_PQ)`\n* `ek_H = (ek_T, ek_PQ)`\n* `ct_H = (ct_T, ct_PQ)`\n\nThe constituent values are fixed-length byte strings, which is needed because we want to feed them into hash functions without ambiguity and without length prefixes.\n\nThe current text specifies that the hybrid values are just the concatenation of the constituent values, and does `concat()` and `split()` as appropriate.  On the one hand, this is a simple construction (avoiding encoding ambiguities one sees, e.g., with ECDSA signatures), and means that the hybrid KEM meets the same KEM API as the constituents.  On the other hand, there's no real need to specify an encoding for these values, so we could punt on the question.",
      "createdAt": "2025-05-29T22:21:23Z",
      "updatedAt": "2025-05-29T23:03:24Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 29,
      "id": "I_kwDOMmhxws6437i1",
      "title": "Should DeriveKeyPair be optional?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/29",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "In the KEM interface, we currently require a DeriveKeyPair algorithm.  We could make this optional, in the same way that `EncapsDerand` is optional.\n\nOn the one hand, this algorithm is not typically included in descriptions of KEMs in the literature.  On the other hand, it is important for integration with things like HPKE and MLS, and most KEMs provide such an algorithm in practice (even if just by making the randomness used by GenerateKeyPair explicit).",
      "createdAt": "2025-05-29T23:05:53Z",
      "updatedAt": "2025-05-29T23:05:53Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 30,
      "id": "I_kwDOMmhxws6438FT",
      "title": "EncapsDerand: Use it or lose it.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/30",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, we define `EncapsDerand` as an optional method on the KEM interface.  But we don't use it anywhere, and we don't define it for the hybrid KEMs.  We should either define this method for the hybrid KEMs when the constituents support it (and thus use it), or delete it.\n\nIf we want it just for purposes of test vectors, we could move it to an appendix.",
      "createdAt": "2025-05-29T23:07:52Z",
      "updatedAt": "2025-05-29T23:07:52Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOMmhxws6G-GIs",
      "title": "Fix build and references",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/1",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-01-07T18:01:15Z",
      "updatedAt": "2025-01-08T04:15:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "8f18831dc6e7d2b4cbe13e809c0481aa350625e6",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/fix-refs",
      "headRefOid": "f795b47e09e04f14fc9afae5b8591ec55dd4fd58",
      "closedAt": "2025-01-08T04:15:08Z",
      "mergedAt": "2025-01-08T04:15:08Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "503214de9161bbabeb9ffeb76d24596d8af66752"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6XJ7HM",
          "commit": {
            "abbreviatedOid": "f795b47"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-01-08T04:14:54Z",
          "updatedAt": "2025-01-08T04:14:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 2,
      "id": "PR_kwDOMmhxws6HIQRB",
      "title": "Refactor, cleanup, reorganize",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/2",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This change refactors some stuff and cleans up the in-lined KEM implementation details.",
      "createdAt": "2025-01-08T21:24:34Z",
      "updatedAt": "2025-01-23T18:47:30Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ea0a9337871b8f52777783e10780d40f21b6ca14",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/reorg",
      "headRefOid": "75a1f6564a51ae64ddb2ae86cb25355a8997b705",
      "closedAt": "2025-01-23T18:47:30Z",
      "mergedAt": "2025-01-23T18:47:30Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "5557ce637cb791f95f09cf3271ec5623825047b1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6XcYyA",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-09T19:48:22Z",
          "updatedAt": "2025-01-09T19:48:23Z",
          "comments": [
            {
              "originalPosition": 477,
              "body": "\ud83d\udc4d",
              "createdAt": "2025-01-09T19:48:22Z",
              "updatedAt": "2025-01-09T19:48:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOLdI",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:01:46Z",
          "updatedAt": "2025-01-23T18:01:47Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "```suggestion\r\n- `EncapsDerand(pk, randomness) -> (ct, shared_secret)`: A deterministic encapsulation\r\n   algorithm, which takes as input a public encapsulation key `pk` and randomness\r\n   `randomness`, and outputs a ciphertext `ct` and shared secret `shared_secret`.\r\n```",
              "createdAt": "2025-01-23T18:01:46Z",
              "updatedAt": "2025-01-23T18:01:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOMAE",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:02:53Z",
          "updatedAt": "2025-01-23T18:02:53Z",
          "comments": [
            {
              "originalPosition": 610,
              "body": "```suggestion\r\ndef EncapsDerand(pk, randomness):\r\n  pq_PK = pk[0:1184]\r\n  trad_PK = pk[1184:1217]\r\n  (pq_SS, pq_CT) = ML-KEM-768.EncapsDerand(pq_PK, randomness[0:32])\r\n  ek = randomness[32:65]\r\n  trad_CT = P-256.ScalarMultBase(ek)\r\n  trad_SS = P-256.ScalarMult(ek, trad_PK)\r\n  ss = SHA3-256(pq_SS, trad_SS, trad_CT, trad_PK, label)\r\n  ct = concat(pq_CT, trad_CT)\r\n```",
              "createdAt": "2025-01-23T18:02:53Z",
              "updatedAt": "2025-01-23T18:02:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOMGw",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:03:05Z",
          "updatedAt": "2025-01-23T18:03:06Z",
          "comments": [
            {
              "originalPosition": 619,
              "body": "```suggestion\r\nNote that `randomness` MUST be 65 bytes.\r\n```",
              "createdAt": "2025-01-23T18:03:05Z",
              "updatedAt": "2025-01-23T18:03:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOMoP",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:04:11Z",
          "updatedAt": "2025-01-23T18:04:12Z",
          "comments": [
            {
              "originalPosition": 864,
              "body": "```suggestion\r\ndef EncapsDerand(pk, randomness):\r\n  pq_PK = pk[0:1184]\r\n  trad_PK = pk[1184:1216]\r\n  (pq_SS, pq_CT) = PQ-KEM.EncapsDerand(pq_PK, randomness[0:32])\r\n  ek = randomness[32:64]\r\n```",
              "createdAt": "2025-01-23T18:04:11Z",
              "updatedAt": "2025-01-23T18:04:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZONxs",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:06:33Z",
          "updatedAt": "2025-01-23T18:06:34Z",
          "comments": [
            {
              "originalPosition": 877,
              "body": "```suggestion\r\nNote that `randomness` MUST be 64 bytes.\r\n```",
              "createdAt": "2025-01-23T18:06:33Z",
              "updatedAt": "2025-01-23T18:06:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOPiO",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:10:14Z",
          "updatedAt": "2025-01-23T18:10:14Z",
          "comments": [
            {
              "originalPosition": 1161,
              "body": "```suggestion\r\ndef EncapsDerand(pk, randomness):\r\n  pq_PK = pk[0:1568]\r\n  trad_PK = pk[1568:1629]\r\n  (pq_SS, pq_CT) = ML-KEM-1024.EncapsDerand(pq_PK, randomness[0:32])\r\n  ek = randomness[32:80]\r\n  trad_CT = P-384.ScalarMultBase(ek)\r\n  trad_SS = P-384.ScalarMult(ek, trad_PK)\r\n  ss = SHA3-256(pq_SS, trad_SS, trad_CT, trad_PK, label)\r\n  ct = concat(pq_CT, trad_CT)\r\n```",
              "createdAt": "2025-01-23T18:10:14Z",
              "updatedAt": "2025-01-23T18:10:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOPoo",
          "commit": {
            "abbreviatedOid": "db08f00"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T18:10:28Z",
          "updatedAt": "2025-01-23T18:10:28Z",
          "comments": [
            {
              "originalPosition": 1170,
              "body": "```suggestion\r\nNote that `randomness` MUST be 80 bytes.\r\n```",
              "createdAt": "2025-01-23T18:10:28Z",
              "updatedAt": "2025-01-23T18:10:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ZOk4A",
          "commit": {
            "abbreviatedOid": "75a1f65"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-01-23T18:46:24Z",
          "updatedAt": "2025-01-23T18:46:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 3,
      "id": "PR_kwDOMmhxws6I0Zg9",
      "title": "Preliminary reference implementations and test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/3",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This mirrors the spec implementation for X-Wing, but it uses Sage for the NIST curve implementation. (Primarily because I had that laying around from other specs. We can replace with a Python implementation in the future if desired.) It fixes some things in the primary spec around key generation (formatting keys as byte strings), fully specifying the DH operations, etc. It also includes preliminary HPKE KEM codepoint registration requests. And, importantly, adds the test vectors produced from the reference implementation.",
      "createdAt": "2025-01-23T21:30:19Z",
      "updatedAt": "2025-02-03T18:44:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "5557ce637cb791f95f09cf3271ec5623825047b1",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/vectors",
      "headRefOid": "9771afd2307ec7032d8d6e8298849e06017c0264",
      "closedAt": "2025-02-03T18:44:49Z",
      "mergedAt": "2025-02-03T18:44:49Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "2f0ea74c9e3e93b7dd4fbd3f0c33fb76256e6fef"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@dconnolly I added a `ScalarFromBytes` function, distinct from `DeserializeScalar`, as an infallible constructor that takes bytes and produces `Scalar` values, with an implementation that matches the reference code under the hood. Please take another look!",
          "createdAt": "2025-02-03T17:35:02Z",
          "updatedAt": "2025-02-03T17:35:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6aOQeU",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\ud83d\ude4f",
          "createdAt": "2025-01-31T17:50:01Z",
          "updatedAt": "2025-01-31T17:50:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6aOT4_",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-31T17:52:25Z",
          "updatedAt": "2025-01-31T17:52:25Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "`%` needs defining above",
              "createdAt": "2025-01-31T17:52:25Z",
              "updatedAt": "2025-01-31T17:52:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6aOXz0",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-31T17:55:37Z",
          "updatedAt": "2025-01-31T17:55:37Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "We could leverage the text above about `Scalar`s and `Element`s to enforce that all instances of `Scalar`s MUST be modulo their order, otherwise they aren't real `Scalar`s ",
              "createdAt": "2025-01-31T17:55:37Z",
              "updatedAt": "2025-01-31T17:55:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6aOYml",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Do we want to enforce the `Scalar` being always modulo its `Order()` via its instantiation? Otherwise we need to define `%` as used in `expandDecapsulationKey` etc",
          "createdAt": "2025-01-31T17:57:13Z",
          "updatedAt": "2025-01-31T17:57:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6aaI9p",
          "commit": {
            "abbreviatedOid": "8d619bd"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-03T17:11:55Z",
          "updatedAt": "2025-02-03T17:11:55Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "That's a cleaner way to handle this. I'll update the textual description of Scalar to include something about mapping from bytes, and say that the bytes are reduced modulo the order, or something.",
              "createdAt": "2025-02-03T17:11:55Z",
              "updatedAt": "2025-02-03T17:11:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6aa29j",
          "commit": {
            "abbreviatedOid": "9771afd"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-03T18:44:32Z",
          "updatedAt": "2025-02-03T18:44:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOMmhxws6MFI2K",
      "title": "Update labels to include XOF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/5",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hopefully these labels are not too terrible on the eyes \ud83e\udd37 \r\n\r\nCloses #4.",
      "createdAt": "2025-02-21T17:19:15Z",
      "updatedAt": "2025-02-25T17:22:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "a1093192626f720d448880692a5d8b258fbf783c",
      "headRepository": "chris-wood/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "caw/update-labels",
      "headRefOid": "9abc6fcfb262e42878b0b67cece04cec09bba491",
      "closedAt": "2025-02-25T17:22:49Z",
      "mergedAt": "2025-02-25T17:22:49Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "10867607a87847ff4d9e03029dcfcd4117b83620"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6dAy3d",
          "commit": {
            "abbreviatedOid": "a7175ff"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T21:14:24Z",
          "updatedAt": "2025-02-21T21:14:24Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\n2. `KitchenSink-KEM(ML-KEM-768,X25519)-XOF(SHAKE256)-KDF(HKDF-SHA-256)` {{ks-x25519}}:\r\n```\r\n\r\nHm I worry about a comma in a label like this, have we done this in other i*tf crypto protocols? Is it fine in practice?",
              "createdAt": "2025-02-21T21:14:24Z",
              "updatedAt": "2025-02-21T21:14:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6deCz8",
          "commit": {
            "abbreviatedOid": "a7175ff"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-25T17:21:26Z",
          "updatedAt": "2025-02-25T17:21:27Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "merging for now, but may want to keep an eye on it",
              "createdAt": "2025-02-25T17:21:27Z",
              "updatedAt": "2025-02-25T17:21:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOMmhxws6MGGlY",
      "title": "Add generic keygen and derivation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/6",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@chris-wood wdyt of the attempt at including slicing of the XOF output into the bytes that go into each component algorithm? \ud83d\ude05",
      "createdAt": "2025-02-21T19:50:44Z",
      "updatedAt": "2025-02-25T17:20:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "f50c9557531cb1237d8be28871842f6fa8675134",
      "headRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "generic-keygen",
      "headRefOid": "9fcef57ff286640cf383b48579c201ecec104507",
      "closedAt": "2025-02-25T17:20:28Z",
      "mergedAt": "2025-02-25T17:20:28Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "a1093192626f720d448880692a5d8b258fbf783c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6dASs8",
          "commit": {
            "abbreviatedOid": "d76eae8"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T19:57:03Z",
          "updatedAt": "2025-02-21T19:57:11Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Maybe we replace `Nxofout` with `Npqseed + Ntradseed`? I think the `expanded[..Npqseed]` is fairly clear, but we should probably add some text to the terminology section that describes how it works. Something like:\r\n\r\n```\r\nWhen `x` is a byte string, we use the notation `x[..i]` and `x[i..]` to denote the slice of bytes in `x` starting from the beginning of `x` and leading up to index `i`, including the `i`-th byte, and the slice the bytes in `x` starting from index `i` to the end of `x`, respectively. For example, if `x = [0, 1, 2, 3]`, then `x[..2] = [0, 1]` and `x[2..] = [2, 3]`.\r\n```",
              "createdAt": "2025-02-21T19:57:03Z",
              "updatedAt": "2025-02-21T19:57:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6dAzLR",
          "commit": {
            "abbreviatedOid": "d76eae8"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-21T21:15:08Z",
          "updatedAt": "2025-02-21T21:15:08Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done; can you cross check the numbers for Ntradseed for the p256 and p384 instances?",
              "createdAt": "2025-02-21T21:15:08Z",
              "updatedAt": "2025-02-21T21:15:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6deB_p",
          "commit": {
            "abbreviatedOid": "9fcef57"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-25T17:20:13Z",
          "updatedAt": "2025-02-25T17:20:13Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "confirmed out of bad - they are larger than expected  to make sure the Scalar isn't biased (not a power of 2), these match HashToCurve",
              "createdAt": "2025-02-25T17:20:13Z",
              "updatedAt": "2025-02-25T17:20:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 9,
      "id": "PR_kwDOMmhxws6N0rBY",
      "title": "Clarify concatenation operations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/9",
      "state": "CLOSED",
      "author": "bluegate010",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Clarify that SHA3-256 takes one input which is a concatenation of multiple values.",
      "createdAt": "2025-03-07T20:30:38Z",
      "updatedAt": "2025-05-29T22:03:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ca4807c8b1249830e36a18dbc8b218087eb7bcb8",
      "headRepository": "bluegate010/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "patch-1",
      "headRefOid": "ec575c84b83fe47edd02460667e9e1eda3cc561b",
      "closedAt": "2025-05-29T22:03:37Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "We can clarify this concatenation to match the generic QSF construction more closely using the explicit `concat()` routine described earlier ",
          "createdAt": "2025-03-07T20:33:31Z",
          "updatedAt": "2025-03-07T20:33:31Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "Opened https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/10 for this ",
          "createdAt": "2025-03-07T20:35:50Z",
          "updatedAt": "2025-03-07T20:35:50Z"
        },
        {
          "author": "bluegate010",
          "authorAssociation": "NONE",
          "body": "> We can clarify this concatenation to match the generic QSF construction more closely using the explicit `concat()` routine described earlier\r\n\r\nGot it, have made this adjustment.",
          "createdAt": "2025-03-07T21:01:07Z",
          "updatedAt": "2025-03-07T21:01:07Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by events",
          "createdAt": "2025-05-29T22:03:37Z",
          "updatedAt": "2025-05-29T22:03:37Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOMmhxws6N01c3",
      "title": "Make trad_PK consistently a serialized byte array.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/12",
      "state": "CLOSED",
      "author": "bluegate010",
      "authorAssociation": "NONE",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Resolves https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/11",
      "createdAt": "2025-03-07T20:55:55Z",
      "updatedAt": "2025-05-29T22:03:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ca4807c8b1249830e36a18dbc8b218087eb7bcb8",
      "headRepository": "bluegate010/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "trad_PK",
      "headRefOid": "96dac879d6c53b62e542a06d902b46db8666e6ab",
      "closedAt": "2025-05-29T22:03:18Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by events.",
          "createdAt": "2025-05-29T22:03:18Z",
          "updatedAt": "2025-05-29T22:03:18Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 15,
      "id": "PR_kwDOMmhxws6UNmZE",
      "title": "Remove concrete instantiations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/15",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR removes the following content from this document:\r\n\r\n* The sections defining concrete combiners\r\n* The test vectors section\r\n* The IANA considerations section\r\n* Mentions of specific combinations in the prose\r\n\r\nMost of this text should be moved to the concrete document (https://github.com/cfrg/draft-irtf-cfrg-concrete-hybrid-kems/pull/1).  The only exception is the IANA considerations section, which should be handled by the HPKE WG.",
      "createdAt": "2025-04-28T18:26:12Z",
      "updatedAt": "2025-05-01T14:47:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "ca4807c8b1249830e36a18dbc8b218087eb7bcb8",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "no-concrete",
      "headRefOid": "b7fbef939decc1ce486dabe8a60147f4a846fefd",
      "closedAt": "2025-05-01T14:47:40Z",
      "mergedAt": "2025-05-01T14:47:39Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "55400d76088569aad2bffda3dc1aca2ad5095cde"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6nfIH5",
          "commit": {
            "abbreviatedOid": "b7fbef9"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-01T14:47:33Z",
          "updatedAt": "2025-05-01T14:47:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOMmhxws6VGG6-",
      "title": "Refactor KEM Constructions section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/17",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The basic proposal here is to refactor the Hybrid KEM Constructions section so that:\r\n\r\n* It more clearly addresses the whole definition of the hybrid KEM (including all the specified methods)\r\n* It includes a slightly broader range of options (Chempat-like, TLS-like)\r\n\r\nThe current text is just a sketch; it needs to be turned into actual prose.  But it should give a pretty clear idea of the intended direction.",
      "createdAt": "2025-05-06T12:03:54Z",
      "updatedAt": "2025-05-22T14:03:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "55400d76088569aad2bffda3dc1aca2ad5095cde",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "draft-text",
      "headRefOid": "b774ed6c28b8d6a8d7a23a9ae36aaaae5b5efb25",
      "closedAt": "2025-05-22T14:03:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Replaced by #19 ",
          "createdAt": "2025-05-22T14:03:27Z",
          "updatedAt": "2025-05-22T14:03:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6oNUv0",
          "commit": {
            "abbreviatedOid": "b774ed6"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-07T14:46:08Z",
          "updatedAt": "2025-05-07T17:28:00Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "* Treat Generate-only as an exception case; default assumption is DeriveKeyPair\r\n* RSA for example is missing DKP, though in principle it could be defined",
              "createdAt": "2025-05-07T14:46:08Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 50,
              "body": "TODO: Make sure that we have all the security properties we need for this.\r\n\r\n* SHAKE calls it the \"flat sponge property\" -- capacity is 2x security level.\r\n* Might need to be a dual PRF for some definition?\r\n* Might not be if we use a different tool (KDF) for the combiners.\r\n\r\nTODO: Re-add / maintain that distinction (XOF + KDF)",
              "createdAt": "2025-05-07T14:52:16Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 83,
              "body": "* Having seed expansion makes it hard to manipulate seeds\r\n* Should be `Nseed = max(KEM_T.Nseed, KEM_PQ.Nseed)` ?\r\n* In concept, 2x security level (would need to state the security level)\r\n    * Might have a birthday collision issue?\r\n    * Could lead to generating shorter secrets from longer secrets at the higher security level",
              "createdAt": "2025-05-07T15:03:45Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 86,
              "body": "* Might not be natural for CT to be fixed size in some case\r\n* Only implication to variable length would be length prefixes in combiners\r\n* Assume fixed size for now, let people push back on it\r\n* Fall-back: Document how you could fit a variable-size values",
              "createdAt": "2025-05-07T15:12:13Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 77,
              "body": "* Could start with one label field, then build a structured label that has (construction + app)\r\n* Having a single label field can get the discussion started in the WG about why people want labels\r\n* Might call it a \"context\" if provided by the app\r\n* Some KEMs (e.g., ML-KEM) have a context input, could reflect in KEM API, probably not worthwhile",
              "createdAt": "2025-05-07T15:21:31Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 180,
              "body": "* Might need some additional assumptions on the KEMs to get here.\r\n* Why does it work with X25519 and ML-KEM?\r\n",
              "createdAt": "2025-05-07T15:36:04Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            },
            {
              "originalPosition": 180,
              "body": "cc @bwesterb ",
              "createdAt": "2025-05-07T15:36:21Z",
              "updatedAt": "2025-05-07T17:28:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 18,
      "id": "PR_kwDOMmhxws6VpV7t",
      "title": "Several editorial changes and rewrites",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/18",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR makes several primarily editorial changes, in preparation for the more significant edits to the combiners and security properties sections.\r\n\r\n* (pk, sk) -> (ek, dk)\r\n* New text in the abstract and introduction\r\n* Removes a couple of unnecessary function definitions\r\n* Clean up in the definition of the KEM interface\r\n* Rewrote the DH section as a KEM-to-DH construction\r\n\r\nThe last change is the most substantial one.  The current combiner constructions make explicit reference to the DH functions of the T algorithm.  The idea of this rewrite is to handle both the PQ and T algorithms through the KEM interface.  \r\n\r\nHandling both algorithms through the same interface is aesthetically nicer, since things will be more parallel, but could also allow for non-DH options like RSA.  At least in principle; I would object to actually spending words on such a possibility in this document.  In fact, I'm not totally sure we need to have the DH KEM construction in the main text, as opposed to having it in an appendix that is referred to as necessary.  (I also thought about moving it to the concrete combiners document, but it seems generic enough and useful enough as a motivator to be included here.)\r\n\r\nI'm not sure why `includes.mk` got deleted.  I presume it was was something in the tooling; I didn't do it deliberately.",
      "createdAt": "2025-05-09T22:09:06Z",
      "updatedAt": "2025-05-27T21:26:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "55400d76088569aad2bffda3dc1aca2ad5095cde",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "edit-pass",
      "headRefOid": "37bda778108e222e735cd5f1f630da10a421c730",
      "closedAt": "2025-05-22T14:56:21Z",
      "mergedAt": "2025-05-22T14:56:21Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "9e85013a9da7226a2e54c098de0ab5043034a158"
      },
      "comments": [
        {
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for this revision. I think it looks largely good (a few comments added). I similarly would recommend punting description of RSA. For DH, I think it depends on whether the concrete options will be DH-based or DHKEM-based. The latter can be generalized for KEM, but we talked about efficiencies of the former. It would see odd to have a concrete document that uses DH instead of DHKEM, if the generalism is all KEM-based or DH doesn't feature heavily. So I am somewhat inclined to have the DH discussion fairly prominent.",
          "createdAt": "2025-05-10T20:22:47Z",
          "updatedAt": "2025-05-10T20:22:47Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed on authors call, will revert the IND-CPA DH section back to an explicit group section.\r\n\r\nAlso @dconnolly sorry I missed your comments here, will address them in the next round.",
          "createdAt": "2025-05-22T14:57:44Z",
          "updatedAt": "2025-05-22T14:57:44Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6ovoVv",
          "commit": {
            "abbreviatedOid": "e20cca7"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-10T20:14:33Z",
          "updatedAt": "2025-05-10T20:14:34Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I recommend that we avoid \"timed\" statements in the draft that might not age well. This can be changed to:\r\n\r\nPost-quantum (PQ) algorithms offer a redesign of traditional algorithms tailored towards resisting attack from a quantum computer. Key Encapsulation Mechanisms (KEMs), are a standardized algorithm type that can be used to build protocols in lieu of traditional, quantum-vulnerable variants such as Diffie-Hellman (DH) based protocols. Given the novelty of PQ algorithms, however....",
              "createdAt": "2025-05-10T20:14:33Z",
              "updatedAt": "2025-05-10T20:14:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQnn8",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T10:49:19Z",
          "updatedAt": "2025-05-14T10:49:20Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Feel free to ignore this stylistic blabbering: personally I like to write \"post-quantum algorithms are designed to resist attack of quantum computers\". Then we don't need any qualifications like \"promise\" or \"believe to\" etc. Of course it's not completely true: several schemes were first designed before quantum computers were known about.",
              "createdAt": "2025-05-14T10:49:19Z",
              "updatedAt": "2025-05-14T10:49:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQqh5",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T10:53:16Z",
          "updatedAt": "2025-05-14T10:53:17Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "There are two more affordances of hybrids\u2014not sure we should go into that now.\r\n\r\n1. You can satisfy an old policy (or expectation) while already adopting PQ.\r\n2. You protect against implementation mistakes. (Say, using a hybrid we protect against a say timing-based active attack in either component.\r\n",
              "createdAt": "2025-05-14T10:53:16Z",
              "updatedAt": "2025-05-14T10:53:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQrRn",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T10:54:20Z",
          "updatedAt": "2025-05-14T10:54:21Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "`brken` typo",
              "createdAt": "2025-05-14T10:54:21Z",
              "updatedAt": "2025-05-14T10:54:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQwCU",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T11:00:44Z",
          "updatedAt": "2025-05-14T11:00:45Z",
          "comments": [
            {
              "originalPosition": 277,
              "body": "IND-CCA and IND-CPA might be meaningless to the reader at this point. What about the following\r\n\r\n> This KEM is not secure against active attack (not IND-CCA).",
              "createdAt": "2025-05-14T11:00:44Z",
              "updatedAt": "2025-05-14T11:00:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQ6Zp",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T11:14:42Z",
          "updatedAt": "2025-05-14T11:14:43Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "I know it makes sense to define the IND-CPA KEM like this, but I'm worried that once it's defined, it's very tempting for implementors to put it in the KEM slot and have it available to users, which do not understand warnings such as \"this is only IND-CPA\".\r\n\r\nNot assigning a code points helps, but maybe we can do more.\r\n\r\nIdeally we'd make the interface of a component incompatible with a proper KEM, but I don't see any non-artificial way to do that.\r\n\r\nDifferent naming only goes so far: I think *Component* or say *PreKEM* would be better.\r\n",
              "createdAt": "2025-05-14T11:14:42Z",
              "updatedAt": "2025-05-14T11:14:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQ7DH",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T11:15:46Z",
          "updatedAt": "2025-05-14T11:15:47Z",
          "comments": [
            {
              "originalPosition": 392,
              "body": "This is breaking abstraction.",
              "createdAt": "2025-05-14T11:15:46Z",
              "updatedAt": "2025-05-14T11:15:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pQ8Pv",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-14T11:17:42Z",
          "updatedAt": "2025-05-14T11:17:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6pQ8r8",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T11:18:28Z",
          "updatedAt": "2025-05-14T11:18:28Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Typo",
              "createdAt": "2025-05-14T11:18:28Z",
              "updatedAt": "2025-05-14T11:18:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6psmmU",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-16T15:55:48Z",
          "updatedAt": "2025-05-16T15:55:48Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Added a couple of sentences to this effect in the Introduction.",
              "createdAt": "2025-05-16T15:55:48Z",
              "updatedAt": "2025-05-16T15:55:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6psr9D",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-16T16:05:45Z",
          "updatedAt": "2025-05-16T16:05:45Z",
          "comments": [
            {
              "originalPosition": 277,
              "body": "Reworded this to be more reader-friendly, and provide a forward pointer to the security considerations.",
              "createdAt": "2025-05-16T16:05:45Z",
              "updatedAt": "2025-05-16T16:05:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pss52",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-16T16:07:31Z",
          "updatedAt": "2025-05-16T16:07:31Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "I added some text that explicitly says \"This KEM should not be used on its own.\"  Unfortunately the \ud83d\udea8 emoji isn't allowed in RFCs.",
              "createdAt": "2025-05-16T16:07:31Z",
              "updatedAt": "2025-05-16T16:07:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6pstwr",
          "commit": {
            "abbreviatedOid": "41085b5"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-16T16:09:15Z",
          "updatedAt": "2025-05-16T16:09:24Z",
          "comments": [
            {
              "originalPosition": 392,
              "body": "Yep, this will get fixed in the next PR.  The only reason this part is getting touched is the global `(sk, pk) -> (dk, ek)` terminology change.",
              "createdAt": "2025-05-16T16:09:15Z",
              "updatedAt": "2025-05-16T16:09:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdlcX",
          "commit": {
            "abbreviatedOid": "6791b79"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:00:09Z",
          "updatedAt": "2025-05-22T06:00:10Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nsecurity against quantum attack. In this document, we define constructions for\r\nhybrid Key Encapsulation Mechanisms (KEMs) based on combining a traditional KEM\r\nand a PQ KEM. Hybrid KEMs using these constructions provide strong security\r\nproperties as long as the undelying algorithms are secure.\r\n```",
              "createdAt": "2025-05-22T06:00:09Z",
              "updatedAt": "2025-05-22T06:00:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdlzu",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:01:02Z",
          "updatedAt": "2025-05-22T06:01:03Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "```suggestion\r\nPost-quantum (PQ) algorithms offer new constructions based on problems tailored\r\ntowards resisting attack from a quantum computer. Key Encapsulation Mechanisms\r\n(KEMs), are a standardized algorithm type that can be used to build protocols in\r\n```",
              "createdAt": "2025-05-22T06:01:02Z",
              "updatedAt": "2025-05-22T06:01:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdmNf",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:02:03Z",
          "updatedAt": "2025-05-22T06:02:03Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "```suggestion\r\nlieu of traditional, quantum-vulnerable variants such as finite field\r\nor elliptic curve Diffie-Hellman (DH) based protocols. Upgrading protocols\r\nto use PQ KEMs is a priority for the\r\n```",
              "createdAt": "2025-05-22T06:02:03Z",
              "updatedAt": "2025-05-22T06:02:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdmvn",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:03:17Z",
          "updatedAt": "2025-05-22T06:03:18Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nbased protocols.  Upgrading key establishment protocols to use PQ KEMs is a\r\npriority for the protocol design community, due to the possibility of\r\n\"harvest now, decrypt later\" attacks.\r\n```",
              "createdAt": "2025-05-22T06:03:18Z",
              "updatedAt": "2025-05-22T06:03:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdnAf",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:03:55Z",
          "updatedAt": "2025-05-22T06:03:55Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "'retains the properties' needs clarity",
              "createdAt": "2025-05-22T06:03:55Z",
              "updatedAt": "2025-05-22T06:03:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdnbg",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:04:28Z",
          "updatedAt": "2025-05-22T06:04:28Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "```suggestion\r\neven if the other KEM is compromised.  If the PQ KEM is broken, then the hybrid\r\nKEM should continue to provide security against\r\n```",
              "createdAt": "2025-05-22T06:04:28Z",
              "updatedAt": "2025-05-22T06:04:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdoAZ",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:05:05Z",
          "updatedAt": "2025-05-22T06:05:06Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "```suggestion\r\nIn addition to guarding against algorithm weakness, this property also guards\r\nagainst flaws in implementations, such as timing attacks.  Hybrid KEMs can also\r\nfacilitate faster deployment of PQ security by allowing applications to\r\n```",
              "createdAt": "2025-05-22T06:05:05Z",
              "updatedAt": "2025-05-22T06:05:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdocC",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:05:58Z",
          "updatedAt": "2025-05-22T06:05:59Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "But not only KEMs as components, as in QSF - we combine traditional components and PQ KEMs",
              "createdAt": "2025-05-22T06:05:59Z",
              "updatedAt": "2025-05-22T06:05:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdoi5",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:06:13Z",
          "updatedAt": "2025-05-22T06:06:14Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "```suggestion\r\nof techniques for constructing hybrid KEMs designed to achieve specific security\r\nproperties given conforming component algorithms, that should be suitable for\r\nthe majority of use cases.\r\n```",
              "createdAt": "2025-05-22T06:06:14Z",
              "updatedAt": "2025-05-22T06:06:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdo3B",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:06:58Z",
          "updatedAt": "2025-05-22T06:06:58Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "nice ",
              "createdAt": "2025-05-22T06:06:58Z",
              "updatedAt": "2025-05-22T06:06:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdpZM",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:08:16Z",
          "updatedAt": "2025-05-22T06:08:17Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "'Yes but', in the literature there is just keygen, so idk if we want to add a word or two to like, make this more 'applied', or applicable just in this document, or something",
              "createdAt": "2025-05-22T06:08:16Z",
              "updatedAt": "2025-05-22T06:08:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdpsH",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:08:58Z",
          "updatedAt": "2025-05-22T06:08:58Z",
          "comments": [
            {
              "originalPosition": 190,
              "body": "```suggestion\r\nWe assume that the values produced and consumed by the above functions are all\r\nbyte strings, with fixed lengths per parameter set:\r\n```",
              "createdAt": "2025-05-22T06:08:58Z",
              "updatedAt": "2025-05-22T06:08:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdqB2",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:09:44Z",
          "updatedAt": "2025-05-22T06:09:44Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "True, but why mention it?",
              "createdAt": "2025-05-22T06:09:44Z",
              "updatedAt": "2025-05-22T06:09:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qdqSP",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T06:10:17Z",
          "updatedAt": "2025-05-22T06:10:17Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "I really don't think we should do this, this is not a secure IND-CCA KEM (it doesn't match DH-KEM in HPKE, for example)",
              "createdAt": "2025-05-22T06:10:17Z",
              "updatedAt": "2025-05-22T06:10:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6qkDOU",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "assuming future changes",
          "createdAt": "2025-05-22T14:56:01Z",
          "updatedAt": "2025-05-22T14:56:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6rOlnI",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-27T21:25:29Z",
          "updatedAt": "2025-05-27T21:25:29Z",
          "comments": [
            {
              "originalPosition": 190,
              "body": "I'm putting in a note for now, but I suspect we should make this optional and parallel to `EncapsDerand`.",
              "createdAt": "2025-05-27T21:25:29Z",
              "updatedAt": "2025-05-27T21:25:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rOmja",
          "commit": {
            "abbreviatedOid": "37bda77"
          },
          "author": "bifurcation",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-27T21:26:52Z",
          "updatedAt": "2025-05-27T21:26:53Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "In case people have already read HPKE and are looking at this.  I have added markup to make it an inset note / aside.  I'm not that committed to it; happy to delete it if people feel strongly.",
              "createdAt": "2025-05-27T21:26:52Z",
              "updatedAt": "2025-05-27T21:26:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 19,
      "id": "PR_kwDOMmhxws6Wgb0y",
      "title": "Hybrid constructions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/19",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR builds on #18 by actually defining the hybrid KEM constructions.  First we define the overall KEM structure, being generic over combiner functions, and then we define the combiners.\r\n\r\nI have focused on functional definitions here, with security notions and arguments punted to the Security Considerations.  I added an outline of what I think we need the Security Considerations to look like at the end, mainly so that I could have targets for the cross-references above.",
      "createdAt": "2025-05-16T18:17:04Z",
      "updatedAt": "2025-05-29T22:02:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "9e85013a9da7226a2e54c098de0ab5043034a158",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "hybrid-constructions",
      "headRefOid": "dcced8928ede11206cddb706f87e15b95b947005",
      "closedAt": "2025-05-29T22:02:53Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed on authors call, will remove the \"OnlySharedSecrets\" option (nobody's asking for it; arguably not sound) and reframe the OnlyTraditional option in terms of a T group.",
          "createdAt": "2025-05-22T14:58:43Z",
          "updatedAt": "2025-05-22T14:58:43Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Subsumed in #22 ",
          "createdAt": "2025-05-29T22:02:50Z",
          "updatedAt": "2025-05-29T22:02:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6qkD1h",
          "commit": {
            "abbreviatedOid": "86bea7e"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "assuming future changes",
          "createdAt": "2025-05-22T14:56:43Z",
          "updatedAt": "2025-05-22T14:56:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOMmhxws6X2tuT",
      "title": "Post #18 edits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/21",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* Addresses a bunch of editorial comments from @dconnolly.  \r\n* Removes the OnlySharedSecrets combiner, as discussed on the authors call",
      "createdAt": "2025-05-27T21:30:37Z",
      "updatedAt": "2025-05-29T22:03:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "9e85013a9da7226a2e54c098de0ab5043034a158",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "post-18",
      "headRefOid": "1138e27278bb141638319d458ea782badc538f59",
      "closedAt": "2025-05-29T22:03:04Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Subsumed in #22 ",
          "createdAt": "2025-05-29T22:03:04Z",
          "updatedAt": "2025-05-29T22:03:04Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 22,
      "id": "PR_kwDOMmhxws6YCzWa",
      "title": "Reframe in terms of groups ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/pull/22",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR rewrites the hybrid KEMs in terms of nominal groups as appropriate.\r\n\r\n* Adds a \"nominal group\" API much like the KEM API.\r\n* The HashEverything hybrid is defined in terms of KEM+KEM\r\n    * The PreHashKeys hybrid is defined as an optimization of HashEverything\r\n    * We define a way of instantiating the above with a group instead of a KEM\r\n* The HashTraditionalOnly hybrid is define in terms of Group+KEM (as in [BCD+24])\r\n",
      "createdAt": "2025-05-29T00:34:54Z",
      "updatedAt": "2025-05-30T15:34:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hybrid-kems",
      "baseRefName": "main",
      "baseRefOid": "9e85013a9da7226a2e54c098de0ab5043034a158",
      "headRepository": "bifurcation/draft-irtf-cfrg-hybrid-kems",
      "headRefName": "kem-vs-curve",
      "headRefOid": "c4d01b2b2566e5cfa3e0deca8f651c3c7369eefd",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation is this branch all the commits from PR #18 and #21? ",
          "createdAt": "2025-05-29T15:23:53Z",
          "updatedAt": "2025-05-29T15:23:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@dconnolly - Yes, i've just been building ahead linearly.",
          "createdAt": "2025-05-29T15:24:54Z",
          "updatedAt": "2025-05-29T15:24:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMmhxws6rkRSP",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T13:55:19Z",
          "updatedAt": "2025-05-29T13:55:19Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Recommend removal of HNDL attacks. Motivation for PQC is not specific to that, but due to quantum threats.",
              "createdAt": "2025-05-29T13:55:19Z",
              "updatedAt": "2025-05-29T13:55:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rkaq8",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T14:07:54Z",
          "updatedAt": "2025-05-29T14:07:54Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "The idea of mentioning HNDL is just to explain why the focus on KEMs vs. Authentication.  But I don't feel super strongly.",
              "createdAt": "2025-05-29T14:07:54Z",
              "updatedAt": "2025-05-29T14:07:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rkmIx",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T14:23:43Z",
          "updatedAt": "2025-05-29T14:23:44Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Well, the whole draft is about KEMs only, so...",
              "createdAt": "2025-05-29T14:23:43Z",
              "updatedAt": "2025-05-29T14:23:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rlSL4",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T15:21:58Z",
          "updatedAt": "2025-05-29T15:21:58Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "And KEMs are not only used for key establishment, sometimes they are used for auth too",
              "createdAt": "2025-05-29T15:21:58Z",
              "updatedAt": "2025-05-29T15:21:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rlTZ0",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T15:23:42Z",
          "updatedAt": "2025-05-29T15:23:43Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Fine, fine, we can delete it :)",
              "createdAt": "2025-05-29T15:23:43Z",
              "updatedAt": "2025-05-29T15:23:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rl8nU",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T16:14:03Z",
          "updatedAt": "2025-05-29T16:14:03Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "```suggestion\r\n# Hybrid KEM Generic Constructions {#generic-constructions}\r\n```",
              "createdAt": "2025-05-29T16:14:03Z",
              "updatedAt": "2025-05-29T16:14:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rl886",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T16:14:37Z",
          "updatedAt": "2025-05-29T16:14:37Z",
          "comments": [
            {
              "originalPosition": 265,
              "body": "```suggestion\r\nIn this section, we define three generic constructions for hybrid KEMs:\r\n```",
              "createdAt": "2025-05-29T16:14:37Z",
              "updatedAt": "2025-05-29T16:14:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rl9km",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T16:15:39Z",
          "updatedAt": "2025-05-29T16:15:39Z",
          "comments": [
            {
              "originalPosition": 279,
              "body": "```suggestion\r\n* HashEverything - A generic construction that is suitable for use with any choice\r\n  of traditional and PQ KEMs, with minimal security assumptions on the\r\n  constituent KEMs\r\n* PreHashedKeys - A performance optimization of HashEverything for the case\r\n  where encapsulation keys are large and frequently reused\r\n* HashTraditionalOnly - An optimized generic construction for the case where the traditional\r\n  component is a nominal group and the PQ component has strong binding\r\n  properties\r\n```",
              "createdAt": "2025-05-29T16:15:39Z",
              "updatedAt": "2025-05-29T16:15:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmAVm",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T16:20:17Z",
          "updatedAt": "2025-05-29T16:20:17Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "Let's duplicate Encaps and Decaps from HashEverything here and just change/add these lines",
              "createdAt": "2025-05-29T16:20:17Z",
              "updatedAt": "2025-05-29T17:57:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmLUB",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T16:33:23Z",
          "updatedAt": "2025-05-29T16:33:23Z",
          "comments": [
            {
              "originalPosition": 496,
              "body": "Let's remove this for now, tracked with #23 ",
              "createdAt": "2025-05-29T16:33:23Z",
              "updatedAt": "2025-05-29T16:33:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmpfv",
          "commit": {
            "abbreviatedOid": "bdd309c"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:17:09Z",
          "updatedAt": "2025-05-29T17:17:09Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "```suggestion\r\nPost-quantum (PQ) cryptographic schemes offer new constructions based on problems conjectured as resistant to attacks possible on a quantum computer. Key Encapsulation Mechanisms\r\n```",
              "createdAt": "2025-05-29T17:17:09Z",
              "updatedAt": "2025-05-29T17:17:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmp0U",
          "commit": {
            "abbreviatedOid": "c8874d0"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:17:43Z",
          "updatedAt": "2025-05-29T17:17:44Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "```suggestion\r\nlieu of traditional, quantum-vulnerable variants such as finite field or\r\nelliptic curve Diffie-Hellman (DH) based protocols.\r\n```",
              "createdAt": "2025-05-29T17:17:43Z",
              "updatedAt": "2025-05-29T17:17:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmrwH",
          "commit": {
            "abbreviatedOid": "d64370f"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:20:11Z",
          "updatedAt": "2025-05-29T17:20:11Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\nPost-quantum (PQ) cryptographic schemes offer new constructions based on problems\r\nconjectured as resistant to attacks possible on a quantum computer. Key Encapsulation\r\nMechanisms (KEMs), are a standardized class of cryptographic scheme that can be used\r\nto build protocols in\r\n```",
              "createdAt": "2025-05-29T17:20:11Z",
              "updatedAt": "2025-05-29T17:20:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmsgF",
          "commit": {
            "abbreviatedOid": "a6ee732"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:21:02Z",
          "updatedAt": "2025-05-29T17:21:03Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nPost-quantum (PQ) cryptographic schemes offer new constructions based on problems\r\nconjectured as resistant to attacks possible on a quantum computer. Key \r\nEncapsulation Mechanisms (KEMs), are a standardized class of cryptographic scheme\r\nthat can be used to build protocols in lieu of traditional, quantum-vulnerable\r\nvariants such as finite field or elliptic curve Diffie-Hellman (DH) based protocols.\r\n```",
              "createdAt": "2025-05-29T17:21:02Z",
              "updatedAt": "2025-05-29T17:21:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmtSu",
          "commit": {
            "abbreviatedOid": "c80503e"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:22:06Z",
          "updatedAt": "2025-05-29T17:22:06Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "```suggestion\r\nIn this document, we define generic constructions for hybrid KEMs based on combining a\r\n```",
              "createdAt": "2025-05-29T17:22:06Z",
              "updatedAt": "2025-05-29T17:22:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmulX",
          "commit": {
            "abbreviatedOid": "7eca073"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:23:25Z",
          "updatedAt": "2025-05-29T17:23:25Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "So this is tricky, it's being used to split secret key material and public key material, and being leaky on one is acceptable and being leaky on the other is not...",
              "createdAt": "2025-05-29T17:23:25Z",
              "updatedAt": "2025-05-29T17:23:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmvel",
          "commit": {
            "abbreviatedOid": "407a07b"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:24:30Z",
          "updatedAt": "2025-05-29T17:24:30Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "```suggestion\r\n  input a seed `seed` and generates a public encapsulation key `ek` and a secret\r\n```",
              "createdAt": "2025-05-29T17:24:30Z",
              "updatedAt": "2025-05-29T17:24:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmxKK",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:26:43Z",
          "updatedAt": "2025-05-29T17:26:43Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "All mention of 'KDF' and 'XOF' has been removed and 'hash functions' has been added, these things are not the same",
              "createdAt": "2025-05-29T17:26:43Z",
              "updatedAt": "2025-05-29T17:26:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rmxhB",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "blocked on KDF, XOF ",
          "createdAt": "2025-05-29T17:27:08Z",
          "updatedAt": "2025-05-29T17:27:08Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMmhxws6rm0Wf",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:31:01Z",
          "updatedAt": "2025-05-29T17:31:01Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "These things are not isomorphic and I don't think we should talk about them this way, I think we should bring back the language about KDFs and XOFs @pag-crypto @br-hale @bwesterb \r\n",
              "createdAt": "2025-05-29T17:31:01Z",
              "updatedAt": "2025-05-29T17:37:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rm2Sl",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:33:47Z",
          "updatedAt": "2025-05-29T17:33:48Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "```suggestion\r\n- `split(N1, N2, x)`: Split a byte string `x` of length `N1 + N2` into its first\r\n  `N1` bytes and its last `N2` bytes.  This function is the inverse of\r\n  `concat(x1, x2)` when `x1` is `N1` bytes long and `x2` is `N2` bytes long. It\r\n  is an error to call this function with a byte string that does not have length\r\n  `N1 + N2`. Since this function operates over secret data it MUST be constant-time.\r\n```",
              "createdAt": "2025-05-29T17:33:47Z",
              "updatedAt": "2025-05-29T17:33:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rm3-k",
          "commit": {
            "abbreviatedOid": "ac43444"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:36:40Z",
          "updatedAt": "2025-05-29T17:36:41Z",
          "comments": [
            {
              "originalPosition": 681,
              "body": "Removed for now but tracked in https://github.com/cfrg/draft-irtf-cfrg-hybrid-kems/issues/24\r\n\r\n```suggestion\r\n```",
              "createdAt": "2025-05-29T17:36:40Z",
              "updatedAt": "2025-05-29T17:36:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rm62L",
          "commit": {
            "abbreviatedOid": "43f5e03"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:41:35Z",
          "updatedAt": "2025-05-29T17:41:35Z",
          "comments": [
            {
              "originalPosition": 375,
              "body": "I might not even define 'split()` in this document, it may be generic enough to decompose into component dk's with an explicit `Decompose()` or something, leave the byte-wise notions to -concrete",
              "createdAt": "2025-05-29T17:41:35Z",
              "updatedAt": "2025-05-29T18:18:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rm9Wb",
          "commit": {
            "abbreviatedOid": "43f5e03"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T17:45:49Z",
          "updatedAt": "2025-05-29T17:45:49Z",
          "comments": [
            {
              "originalPosition": 283,
              "body": "Found it; this is not just a hash function, it has to be a secure KDF (it can't be SHA1 or SHA-256, it should be something like SHA3 or HKDF-SHA256)",
              "createdAt": "2025-05-29T17:45:49Z",
              "updatedAt": "2025-05-29T17:45:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnHxg",
          "commit": {
            "abbreviatedOid": "43f5e03"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:01:02Z",
          "updatedAt": "2025-05-29T18:01:02Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "```suggestion\r\noracle.\r\n\r\nFor QSF, the KDF function must be a secure random oracle in the random oracle\r\nmodel and quantum random oracle model and as a secure pseudorandom\r\nfunction (PRF) in the standard model.\r\n```",
              "createdAt": "2025-05-29T18:01:02Z",
              "updatedAt": "2025-05-29T18:01:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnPN3",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:12:30Z",
          "updatedAt": "2025-05-29T18:12:30Z",
          "comments": [
            {
              "originalPosition": 554,
              "body": "I don't love this name (I don't quite understand what it's trying to say) and think `QSF` is as good a name as any, short, and unless you already know it's associated with X-Wing, non-controversial?",
              "createdAt": "2025-05-29T18:12:30Z",
              "updatedAt": "2025-05-29T18:12:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnPnN",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:13:14Z",
          "updatedAt": "2025-05-29T18:13:14Z",
          "comments": [
            {
              "originalPosition": 498,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-05-29T18:13:14Z",
              "updatedAt": "2025-05-29T18:13:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnPuw",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:13:28Z",
          "updatedAt": "2025-05-29T18:13:28Z",
          "comments": [
            {
              "originalPosition": 504,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-05-29T18:13:28Z",
              "updatedAt": "2025-05-29T18:13:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnP04",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:13:38Z",
          "updatedAt": "2025-05-29T18:13:39Z",
          "comments": [
            {
              "originalPosition": 510,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-05-29T18:13:39Z",
              "updatedAt": "2025-05-29T18:13:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnP_9",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:13:57Z",
          "updatedAt": "2025-05-29T18:13:58Z",
          "comments": [
            {
              "originalPosition": 542,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-05-29T18:13:57Z",
              "updatedAt": "2025-05-29T18:13:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnQKi",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:14:16Z",
          "updatedAt": "2025-05-29T18:14:16Z",
          "comments": [
            {
              "originalPosition": 543,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-05-29T18:14:16Z",
              "updatedAt": "2025-05-29T18:14:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnQWW",
          "commit": {
            "abbreviatedOid": "05af476"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:14:37Z",
          "updatedAt": "2025-05-29T18:14:37Z",
          "comments": [
            {
              "originalPosition": 548,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-05-29T18:14:37Z",
              "updatedAt": "2025-05-29T18:14:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnTkz",
          "commit": {
            "abbreviatedOid": "89fd845"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:20:12Z",
          "updatedAt": "2025-05-29T18:20:12Z",
          "comments": [
            {
              "originalPosition": 292,
              "body": "I really think we should explicitly call these what they are, XOF's and KDF's, 'hash function' blends them together in a way that is not correct and can lead to security issues",
              "createdAt": "2025-05-29T18:20:12Z",
              "updatedAt": "2025-05-29T18:20:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnXG5",
          "commit": {
            "abbreviatedOid": "89fd845"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:26:09Z",
          "updatedAt": "2025-05-29T18:26:09Z",
          "comments": [
            {
              "originalPosition": 453,
              "body": "```suggestion\r\n## PreHash {#prehash}\r\n```",
              "createdAt": "2025-05-29T18:26:09Z",
              "updatedAt": "2025-05-29T18:26:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnX1E",
          "commit": {
            "abbreviatedOid": "09a30e9"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:27:06Z",
          "updatedAt": "2025-05-29T18:27:07Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "```suggestion\r\nGiven the novelty of these PQ schemes however, there is some concern that PQ\r\nalgorithms currently believed to be secure will be broken.  Hybrid\r\nconstructions that combine both PQ and traditional algorithms can help moderate\r\nthis risk while still providing security against quantum attack.  If construted\r\n```",
              "createdAt": "2025-05-29T18:27:07Z",
              "updatedAt": "2025-05-29T18:27:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnZZk",
          "commit": {
            "abbreviatedOid": "487c1fc"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:29:15Z",
          "updatedAt": "2025-05-29T18:29:16Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "```suggestion\r\n- Key Encapsulation Mechanisms {{kems}}\r\n- Nominal Groups {{group}}\r\n- Key-derivation Functions {{kdfs}}\r\n- Extendable-output Functions {{xofs}}\r\n- Hash Functions {{hash}}\r\n```",
              "createdAt": "2025-05-29T18:29:15Z",
              "updatedAt": "2025-05-29T18:29:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rng1R",
          "commit": {
            "abbreviatedOid": "487c1fc"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:39:41Z",
          "updatedAt": "2025-05-29T18:39:41Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "```suggestion\r\n> \"decapsulation\" as opposed to \"public\" and \"secret\".\r\n\r\n## Key Derivation Function `KDF` {#kdf}\r\n\r\nA secure key derivation function (KDF) that is modeled as a secure\r\npseudorandom function (PRF) in the standard model {{GHP2018}} and\r\nindependent random oracle in the random oracle model (ROM) and quantum\r\nrandom oracle model. Generally a strong KDF will have a proof of\r\nindifferentiability from a random oracle.\r\n\r\nExamples of secure KDFs in practice include HKDF-SHA256 and SHA3.\r\nSHA-256 is not generally considered a strong KDF except under\r\nconstrained circumstances {{CDMP2005}}.\r\n\r\n## Extendable-output function `XOF` {#xof}\r\n\r\nExtendable-output function (XOF). A function on bit strings in which the\r\noutput can be extended to any desired length. Ought to satisfy the following\r\nproperties as long as the specified output length is sufficiently long to\r\nprevent trivial attacks:\r\n\r\n1. (One-way) It is computationally infeasible to find any input that maps to\r\n   any new pre-specified output.\r\n\r\n2. (Collision-resistant) It is computationally infeasible to find any two\r\n   distinct inputs that map to the same output.\r\n\r\nMUST provide the bit-security required to source input randomness for PQ/T\r\ncomponents from a seed that is expanded to a output length, of which a subset\r\nis passed to the component key generation algorithms.\r\n\r\n## Hash functions {#hash}\r\n```",
              "createdAt": "2025-05-29T18:39:41Z",
              "updatedAt": "2025-05-29T18:39:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnhBx",
          "commit": {
            "abbreviatedOid": "487c1fc"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:40:02Z",
          "updatedAt": "2025-05-29T18:40:02Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "@br-hale @bwesterb thoughts?",
              "createdAt": "2025-05-29T18:40:02Z",
              "updatedAt": "2025-05-29T18:40:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnknM",
          "commit": {
            "abbreviatedOid": "487c1fc"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:45:33Z",
          "updatedAt": "2025-05-29T18:45:33Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "I would concure that this is 'encapulation' and 'decapsulation' (vs enc / dec). Those are the functions. For the key, a \"secret encapsulation key\" and \"public decapsultation key\" seem appropriate.",
              "createdAt": "2025-05-29T18:45:33Z",
              "updatedAt": "2025-05-29T18:45:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnm1y",
          "commit": {
            "abbreviatedOid": "89fd845"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:48:58Z",
          "updatedAt": "2025-05-29T18:48:59Z",
          "comments": [
            {
              "originalPosition": 292,
              "body": "Concur",
              "createdAt": "2025-05-29T18:48:58Z",
              "updatedAt": "2025-05-29T18:48:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnpJT",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:52:37Z",
          "updatedAt": "2025-05-29T18:52:38Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "Concur",
              "createdAt": "2025-05-29T18:52:38Z",
              "updatedAt": "2025-05-29T18:52:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnr1Q",
          "commit": {
            "abbreviatedOid": "89fd845"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:57:14Z",
          "updatedAt": "2025-05-29T18:57:14Z",
          "comments": [
            {
              "originalPosition": 292,
              "body": "I've added some short sections on what they are and will take a stab at utilizing the them in the generic schemes' pseudocode next",
              "createdAt": "2025-05-29T18:57:14Z",
              "updatedAt": "2025-05-29T18:57:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rnsLg",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T18:57:53Z",
          "updatedAt": "2025-05-29T18:57:54Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Yes, there is a very significant difference for security. The descriptions (generic and concrete) need to match the generic building blocks used in the analyses. \r\n\r\nALSO, we need to look at and discuss if the write concrete choices are used for the end goal (e.g., if something is using SHA256, SHA384, or SHA3). This may or may not be the same as used in the analysis - which means that if we change a building block from what is used in the analysis we need to take a closer look that the right properties are statisfied. \r\n\r\nI am also concerned the properties stated (e.g., collision resistance and second preimage resis) may not align to the properties needed for security, i.e., per what analysis has shown. We need to cite the write attributes.  ",
              "createdAt": "2025-05-29T18:57:54Z",
              "updatedAt": "2025-05-29T18:57:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rn0YG",
          "commit": {
            "abbreviatedOid": "869f45b"
          },
          "author": "dconnolly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T19:12:42Z",
          "updatedAt": "2025-05-29T19:12:42Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Agreed; 'KitchenSink'/'HashEverything' seems closest to GHP2018, QSF to QSF ofc, which both require the KDF to be a 'good' random oracle (and QSF in the standard model requires a 'secure' PRF) which seems to basically mean 'indiff. from an RO' now, even if it's assumed/understated? Chempat doesn't have a proof but maybe we can deduce requirements from GHP2018?",
              "createdAt": "2025-05-29T19:12:42Z",
              "updatedAt": "2025-05-29T19:12:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6ro5H_",
          "commit": {
            "abbreviatedOid": "8f7bcfb"
          },
          "author": "bwesterb",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T21:11:00Z",
          "updatedAt": "2025-05-29T21:11:01Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "I think the proposed change is an improvement. QROM is clearly the strongest requirement on a hash function, and for the PQ KEMs I checked, they all require one anyway.\r\n\r\nLet me entertain a brief tangent. If I could go back a decade or so, I'd propose the CFRG to write a document with the title \"What is a good hash?\". It'd explain ROM, PRF, and all subtle academic differences in security properties. But in the end it'd simply say: length-prefixed-SHA2 & SHA-3 good; MD5, SHA-1 bad.",
              "createdAt": "2025-05-29T21:11:01Z",
              "updatedAt": "2025-05-29T21:11:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rpAiY",
          "commit": {
            "abbreviatedOid": "869f45b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T21:26:41Z",
          "updatedAt": "2025-05-29T21:26:42Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "I think it will actually be cleanest just to delete this text for now, and punt on it like we have for all of the other security descriptions.  I will also add some text at the top of this section clarifying that we're just defining functional definitions here, and the security requirements are below.",
              "createdAt": "2025-05-29T21:26:41Z",
              "updatedAt": "2025-05-29T21:26:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rpB1q",
          "commit": {
            "abbreviatedOid": "869f45b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T21:29:51Z",
          "updatedAt": "2025-05-29T21:33:53Z",
          "comments": [
            {
              "originalPosition": 292,
              "body": "Disagree.  (1) XOF brings a lot more baggage than is necessary, (2) definitions of KDF in the literature are all over the place, and (3) as Bas points out, everyone uses RO for this anyway.\r\n\r\nI agree that the notion of \"hash function\" here is stronger than the usual definition (requiring RO instead of just collision/preimage resistance).  So maybe we need a different word.",
              "createdAt": "2025-05-29T21:29:51Z",
              "updatedAt": "2025-05-29T21:33:53Z"
            },
            {
              "originalPosition": 375,
              "body": "FWIW, we're using it for all of the concatenated things: `dk`, `ek`, and `ct`.\r\n\r\nI agree that the compound serialization doesn't matter.  But the constituent values need to be fixed-length byte strings since they're going into a hash function and you want `concat()` to be unambiguous without length prefixing.  So there's no need for anything more complicated.\r\n\r\nI'm going to leave this for now, and maybe file an issue.",
              "createdAt": "2025-05-29T21:33:45Z",
              "updatedAt": "2025-05-29T21:33:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rpEzD",
          "commit": {
            "abbreviatedOid": "869f45b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T21:36:56Z",
          "updatedAt": "2025-05-29T21:36:56Z",
          "comments": [
            {
              "originalPosition": 554,
              "body": "I don't love it either, but trying to separate from earlier names to be more neutral / give this document more coherence.\r\n\r\nAnother thing to file an issue on. Maybe you could backronym it to something?  ",
              "createdAt": "2025-05-29T21:36:56Z",
              "updatedAt": "2025-05-29T21:36:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rpHsT",
          "commit": {
            "abbreviatedOid": "869f45b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T21:42:43Z",
          "updatedAt": "2025-05-29T21:42:57Z",
          "comments": [
            {
              "originalPosition": 554,
              "body": "@BTW, what it's trying to say is that the only metadata you hash in is on the T side.  \ud83e\udd37 ",
              "createdAt": "2025-05-29T21:42:43Z",
              "updatedAt": "2025-05-29T21:42:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMmhxws6rpRQ6",
          "commit": {
            "abbreviatedOid": "869f45b"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T22:08:26Z",
          "updatedAt": "2025-05-29T22:21:02Z",
          "comments": [
            {
              "originalPosition": 283,
              "body": "@dconnolly citation?",
              "createdAt": "2025-05-29T22:08:26Z",
              "updatedAt": "2025-05-29T22:21:02Z"
            },
            {
              "originalPosition": 375,
              "body": "+1 to @bifurcation -- since these are being thrown into the hash, parsing them at this layer seems necessary.",
              "createdAt": "2025-05-29T22:11:45Z",
              "updatedAt": "2025-05-29T22:21:02Z"
            },
            {
              "originalPosition": 493,
              "body": "Agreed.",
              "createdAt": "2025-05-29T22:20:26Z",
              "updatedAt": "2025-05-29T22:21:02Z"
            },
            {
              "originalPosition": 554,
              "body": "Let's leave it as-is and bike shed the name later. I think it's clear enough for now.",
              "createdAt": "2025-05-29T22:20:49Z",
              "updatedAt": "2025-05-29T22:21:02Z"
            }
          ]
        }
      ]
    }
  ]
}